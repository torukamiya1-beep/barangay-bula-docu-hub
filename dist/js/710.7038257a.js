"use strict";(self["webpackChunkbosfdr"]=self["webpackChunkbosfdr"]||[]).push([[710],{4710:function(t,e,n){n.d(e,{Gv:function(){return l},ei:function(){return a}});n(4114),n(8111),n(7588),n(7642),n(8004),n(3853),n(5876),n(2475),n(5024),n(1698);var o=n(4373);class i{constructor(t){this.userType=t,this.eventSource=null,this.listeners=new Map,this.userContexts=new Map,this.activeContext=null,this.isConnected=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3,this.maxReconnectDelay=3e4,this.baseURL="https://brgybulabackend-production.up.railway.app/api",this.isConnecting=!1,this.pollingInterval=null,this.reconnectTimer=null,console.log(`🔔 Creating ${t} notification service instance`)}validateContext(){const t=localStorage.getItem("auth_token")||sessionStorage.getItem("auth_token"),e=localStorage.getItem("auth_user")||sessionStorage.getItem("auth_user");if(!t||!e)throw new Error("Authentication required");try{const t=JSON.parse(e);if("admin"===this.userType){if("admin"!==t.type)throw new Error("Admin authentication required");return!0}if("client"===this.userType){if("client"!==t.type)throw new Error("Client authentication required");return!0}}catch(n){throw new Error("Invalid user data format")}throw new Error(`Invalid user type: ${this.userType}`)}getAuthToken(){return localStorage.getItem("auth_token")||sessionStorage.getItem("auth_token")}async init(){console.log(`🚀 Initializing ${this.userType} notification service`);try{return this.validateContext(),this.userContexts.has(this.userType)||this.userContexts.set(this.userType,{isConnected:!1,listeners:new Map,eventSource:null}),this.activeContext=this.userType,await this.connect(),console.log(`✅ ${this.userType} notification service initialized successfully`),Promise.resolve()}catch(t){throw console.error(`❌ Failed to initialize ${this.userType} notification service:`,t),t}}detectUserContext(){const t=localStorage.getItem("auth_token")||sessionStorage.getItem("auth_token"),e=localStorage.getItem("auth_user")||sessionStorage.getItem("auth_user");if(!t||!e)return console.log("🔍 No authentication found"),null;try{const t=JSON.parse(e);if(t&&t.type)return console.log("🔍 Detected user context:",t.type),t.type}catch(n){console.warn("⚠️ Invalid user data in localStorage:",n)}return console.log("🔍 No valid user context detected"),null}validateUserContext(t){if(!t||!["admin","client"].includes(t))return!1;const e=localStorage.getItem("auth_token")||sessionStorage.getItem("auth_token"),n=localStorage.getItem("auth_user")||sessionStorage.getItem("auth_user");if(!e||!n)return!1;try{const e=JSON.parse(n);return e&&e.type===t}catch(o){return!1}}switchContext(t){if(!this.validateUserContext(t))return console.warn("⚠️ Cannot switch to invalid user context:",t),!1;const e=this.activeContext;return this.activeContext=t,this.currentUserType=t,console.log("🔄 Context switched:",{from:e,to:t}),this.emit("context_changed",{previousContext:e,currentContext:t}),!0}getCurrentContext(){return this.activeContext}isContextConnected(t){const e=this.userContexts.get(t);return!!e&&e.isConnected}getAvailableContexts(){const t=[];return this.validateUserContext("admin")&&t.push({type:"admin",connected:this.isContextConnected("admin"),active:"admin"===this.activeContext}),this.validateUserContext("client")&&t.push({type:"client",connected:this.isContextConnected("client"),active:"client"===this.activeContext}),t}handleAuthStateChange(){const t=this.detectUserContext();if(!t)return console.log("🔒 No valid authentication detected, cleaning up all contexts"),this.cleanup("admin"),this.cleanup("client"),this.activeContext=null,void(this.currentUserType=null);t!==this.activeContext&&(console.log("🔄 Authentication state changed, switching context:",{from:this.activeContext,to:t}),this.switchContext(t))}startAuthStateMonitoring(){window.addEventListener("storage",(t=>{"adminToken"!==t.key&&"clientToken"!==t.key&&"adminData"!==t.key&&"clientData"!==t.key||(console.log("🔍 Authentication storage changed:",t.key),setTimeout((()=>this.handleAuthStateChange()),100))}));const t=localStorage.setItem;localStorage.setItem=function(e,n){t.call(this,e,n),"adminToken"!==e&&"clientToken"!==e&&"adminData"!==e&&"clientData"!==e||setTimeout((()=>{window.__notificationServiceInstance&&window.__notificationServiceInstance.handleAuthStateChange()}),100)}}cleanup(t=null){if(t){const e=this.userContexts.get(t);e&&(console.log("🧹 Cleaning up context:",t),e.eventSource&&(e.eventSource.close(),e.eventSource=null),e.isConnected=!1,e.listeners.clear(),window[`__sseConnection_${t}`]&&delete window[`__sseConnection_${t}`])}else console.log("🧹 General notification service cleanup")}connect(){return this.isConnected||this.isConnecting||this.eventSource?(console.log(`🔗 ${this.userType} notification service already connected`),Promise.resolve()):(this.isConnecting=!0,console.log(`🔗 Establishing SSE connection for ${this.userType}`),new Promise(((t,e)=>{try{this.validateContext();const n=this.getAuthToken();if(!n)return this.isConnecting=!1,void e(new Error(`No authentication token for ${this.userType}`));const o=`${this.baseURL}/notifications/stream?token=${encodeURIComponent(n)}`;console.log(`🔗 SSE URL for ${this.userType}:`,o.replace(/token=[^&]+/,"token=***")),this.eventSource=new EventSource(o),window[`__sseConnection_${this.userType}`]=this.eventSource,this.eventSource.onopen=()=>{console.log(`✅ SSE Connection established for ${this.userType}`),this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.emit("connected"),t()},this.eventSource.onmessage=t=>{try{const e=JSON.parse(t.data);if(console.log(`📨 SSE Message for ${this.userType}:`,e),e.recipient_type&&e.recipient_type!==this.userType)return void console.log(`🚫 ${this.userType} service ignoring ${e.recipient_type} notification:`,e.id);this.handleNotification(e)}catch(e){console.error(`❌ ${this.userType} SSE message parse error:`,e)}},this.eventSource.addEventListener("connected",(()=>{console.log(`🎯 Connected event received for ${this.userType}`)})),this.eventSource.addEventListener("heartbeat",(()=>{console.log(`💓 Heartbeat received for ${this.userType}`)})),this.eventSource.onerror=t=>{console.error(`❌ SSE Error for ${this.userType}:`,t),this.isConnected=!1,this.isConnecting=!1,this.eventSource.readyState===EventSource.CLOSED?(console.log(`🔌 SSE Connection closed by server for ${this.userType}`),this.emit("disconnected")):this.eventSource.readyState===EventSource.CONNECTING&&console.log(`🔄 SSE Reconnecting for ${this.userType}`),this.reconnectAttempts<this.maxReconnectAttempts?this.scheduleReconnect():(console.error(`🚫 Max reconnection attempts reached for ${this.userType}`),this.emit("max_reconnect_attempts"),e(new Error(`Max reconnection attempts reached for ${this.userType}`)))}}catch(n){console.error("Failed to create SSE connection:",n),this.isConnecting=!1,e(n)}})))}async pollNotifications(t="admin"){try{const e="admin"===t?localStorage.getItem("adminToken"):localStorage.getItem("clientToken");if(!e)return;const n=await fetch(`${this.baseURL}/notifications/unread-count`,{headers:{Authorization:`Bearer ${e}`}});if(n.ok){const t=await n.json(),e=t.data?.count||t.count||0;this.lastCount&&this.lastCount===e&&this.pollCount%10!==0||(this.emit("notification",{type:"unread_count_update",count:e,timestamp:(new Date).toISOString()}),this.lastCount=e),this.pollCount=(this.pollCount||0)+1}}catch(e){console.error("Failed to poll notifications:",e)}}disconnect(){console.log("🔌 Disconnecting SSE connection"),this.isConnected=!1,this.isConnecting=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.eventSource&&(console.log("🔌 Closing EventSource"),this.eventSource.close(),this.eventSource=null),window.__sseConnection&&delete window.__sseConnection,window.__notificationEventSource&&delete window.__notificationEventSource,this.pollingInterval&&(clearInterval(this.pollingInterval),this.pollingInterval=null),console.log("✅ SSE Disconnected cleanly"),this.emit("disconnected")}scheduleReconnect(t=null){const e=t||this.currentUserType||this.detectUserContext();if(this.reconnectAttempts>=this.maxReconnectAttempts)return console.error("🚫 Max reconnection attempts reached for:",e),void this.emit("max_reconnect_attempts",{userType:e});this.reconnectAttempts++;const n=Math.min(this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1),this.maxReconnectDelay);console.log(`🔄 Scheduling reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${e} in ${n}ms`),this.reconnectTimer=setTimeout((()=>{const t=this.userContexts.get(e);!t||t.isConnected||this.isConnecting||(console.log(`🔄 Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${e}`),this.connect(e).catch((t=>{console.error("Reconnection failed for",e,":",t)})))}),n)}handleNotification(t){console.log(`📢 ${this.userType} service processing notification:`,t),t.recipient_type&&t.recipient_type!==this.userType?console.warn(`🚫 ${this.userType} service received wrong notification type:`,t.recipient_type):(this.emit(t.type,t),this.emit("notification",t),this.showBrowserNotification(t))}showBrowserNotification(t){if("Notification"in window&&"granted"===Notification.permission){const e={body:t.message,icon:"/favicon.ico",badge:"/favicon.ico",tag:`notification-${t.id}`,requireInteraction:"high"===t.priority||"urgent"===t.priority},n=new Notification(t.title,e);n.onclick=()=>{window.focus(),this.emit("notification_click",t),n.close()},"high"!==t.priority&&"urgent"!==t.priority&&setTimeout((()=>{n.close()}),5e3)}}async requestNotificationPermission(){if("Notification"in window){const t=await Notification.requestPermission();return"granted"===t}return!1}on(t,e,n=null){const o=n||this.activeContext||this.detectUserContext();if(this.userContexts||(this.userContexts=new Map),this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(e),o&&this.userContexts.has(o)){const n=this.userContexts.get(o);n.listeners.has(t)||n.listeners.set(t,new Set),n.listeners.get(t).add(e),console.log("📝 Event listener registered for",o,":",t)}}off(t,e,n=null){const o=n||this.activeContext||this.detectUserContext();if(this.userContexts||(this.userContexts=new Map),this.listeners.has(t)&&this.listeners.get(t).delete(e),o&&this.userContexts.has(o)){const n=this.userContexts.get(o);n.listeners.has(t)&&n.listeners.get(t).delete(e),console.log("🗑️ Event listener removed for",o,":",t)}}emit(t,e=null,n=null){const o=n?.userType||this.activeContext;if(this.userContexts||(this.userContexts=new Map),this.listeners.has(t)&&this.listeners.get(t).forEach((o=>{try{o(e,n)}catch(i){console.error(`Error in global notification listener for ${t}:`,i)}})),o&&this.userContexts.has(o)){const i=this.userContexts.get(o);i.listeners.has(t)&&i.listeners.get(t).forEach((i=>{try{i(e,n)}catch(s){console.error(`Error in ${o} notification listener for ${t}:`,s)}}))}}async getNotifications(t=1,e=20,n=!1){try{this.validateContext();const i=this.getAuthToken();if(console.log(`🔍 Getting notifications for ${this.userType}:`,{page:t,limit:e,unread_only:n}),!i)throw new Error(`No authentication token found for ${this.userType}`);const s=await o.A.get(`${this.baseURL}/notifications`,{params:{page:t,limit:e,unread_only:n},headers:{Authorization:`Bearer ${i}`}});return console.log(`✅ ${this.userType} notifications retrieved:`,s.data),s.data}catch(i){throw console.error(`❌ Failed to get ${this.userType} notifications:`,i),i}}async getUnreadCount(){try{this.validateContext();const t=this.getAuthToken();if(console.log(`🔍 Getting unread count for ${this.userType}`),!t)throw new Error(`No authentication token found for ${this.userType}`);const e=await o.A.get(`${this.baseURL}/notifications/unread-count`,{headers:{Authorization:`Bearer ${t}`}});console.log(`✅ ${this.userType} unread count response:`,e.data);let n=0;return e.data&&e.data.data&&"undefined"!==typeof e.data.data.count?(n=e.data.data.count,console.log("📊 NotificationService: Found count in data.data.count:",n)):e.data&&"undefined"!==typeof e.data.count?(n=e.data.count,console.log("📊 NotificationService: Found count in data.count:",n)):(n=0,console.log("⚠️ NotificationService: No count found, defaulting to 0")),n}catch(t){throw console.error("❌ NotificationService: Failed to get unread count:",t),t.response&&(console.error("📊 NotificationService: Error response status:",t.response.status),console.error("📊 NotificationService: Error response data:",t.response.data)),t}}async markAsRead(t){try{if(!t||"undefined"===t)throw new Error("Invalid notification ID provided");this.validateContext();const e=this.getAuthToken();if(!e)throw new Error(`No authentication token found for ${this.userType}`);console.log(`Marking notification as read for ${this.userType}:`,t);const n=await o.A.put(`${this.baseURL}/notifications/${t}/read`,{},{headers:{Authorization:`Bearer ${e}`}});return n.data}catch(e){throw console.error(`Failed to mark ${this.userType} notification as read:`,e),e}}async markAllAsRead(){try{this.validateContext();const t=this.getAuthToken();if(!t)throw new Error(`No authentication token found for ${this.userType}`);console.log(`Marking all notifications as read for ${this.userType}`);const e=await o.A.put(`${this.baseURL}/notifications/mark-all-read`,{},{headers:{Authorization:`Bearer ${t}`}});return e.data}catch(t){throw console.error(`Failed to mark all ${this.userType} notifications as read:`,t),t}}async sendTestNotification(t){try{const e=localStorage.getItem("adminToken"),n=await o.A.post(`${this.baseURL}/notifications/test`,t,{headers:{Authorization:`Bearer ${e}`}});return n.data}catch(e){throw console.error("Failed to send test notification:",e),e}}async getStatistics(){try{const t=localStorage.getItem("adminToken"),e=await o.A.get(`${this.baseURL}/notifications/statistics`,{headers:{Authorization:`Bearer ${t}`}});return e.data}catch(t){throw console.error("Failed to get notification statistics:",t),t}}async testConnection(){console.log("🧪 Testing SSE connection...");try{this.eventSource&&(console.log("🧪 Clearing existing connection"),this.eventSource.close(),this.eventSource=null,this.isConnected=!1,this.isConnecting=!1),this.connectionRefs=1,await this.connect("admin"),console.log("🧪 Test connection established"),setTimeout((()=>{console.log("🧪 Test completed, keeping connection")}),1e4)}catch(t){console.error("🧪 Test connection failed:",t)}}async cleanupOldNotifications(t=90){try{const e=localStorage.getItem("adminToken"),n=await o.A.delete(`${this.baseURL}/notifications/cleanup`,{params:{days:t},headers:{Authorization:`Bearer ${e}`}});return n.data}catch(e){throw console.error("Failed to cleanup old notifications:",e),e}}}function s(t){if(!t||!["admin","client"].includes(t))throw new Error(`Invalid user type: ${t}. Must be 'admin' or 'client'`);return new i(t)}let r=null,c=null;function a(){return r||(r=s("admin"),window.__adminNotificationService=r),r}function l(){return c||(c=s("client"),window.__clientNotificationService=c),c}function h(){const t=localStorage.getItem("adminToken"),e=localStorage.getItem("clientToken");return t?a():e?l():a()}e.Ay=h(),window.__createNotificationService=s,window.__getAdminNotificationService=a,window.__getClientNotificationService=l}}]);