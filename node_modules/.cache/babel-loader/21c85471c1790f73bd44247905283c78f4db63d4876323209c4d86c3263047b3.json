{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport AdminHeader from './AdminHeader.vue';\nimport AdminSidebar from './AdminSidebar.vue';\nimport AuthorizedPickupDocumentsModal from './AuthorizedPickupDocumentsModal.vue';\nimport unifiedAuthService from '@/services/unifiedAuthService';\nimport adminDocumentService from '@/services/adminDocumentService';\nimport api from '@/services/api';\nimport { Modal } from 'bootstrap';\nimport notificationService from '@/services/notificationService';\nimport { jsPDF } from 'jspdf';\n// Import jspdf-autotable plugin - v5.x uses named export\nimport autoTable from 'jspdf-autotable';\nexport default {\n  name: 'RequestHistory',\n  components: {\n    AdminHeader,\n    AdminSidebar,\n    AuthorizedPickupDocumentsModal\n  },\n  data() {\n    return {\n      // UI State\n      loading: true,\n      sidebarCollapsed: false,\n      showUserDropdown: false,\n      isMobile: false,\n      adminData: null,\n      errorMessage: '',\n      viewMode: 'table',\n      // 'card' or 'table' - default to table view\n\n      // Request Management Data\n      requests: [],\n      selectedRequests: [],\n      currentRequest: null,\n      statusOptions: [],\n      selectedRequestForPickup: null,\n      processingPickupAction: false,\n      // Pagination\n      pagination: {\n        currentPage: 1,\n        totalPages: 1,\n        totalItems: 0,\n        itemsPerPage: 10\n      },\n      // Filters - Show all historical documents (completed and cancelled)\n      filters: {\n        status: '',\n        // Empty to show all statuses including completed and cancelled\n        document_type: '',\n        priority: '',\n        search: '',\n        date_from: '',\n        date_to: ''\n      },\n      // PDF Export Form\n      pdfExportForm: {\n        reportType: 'daily',\n        selectedDate: '',\n        selectedWeek: '',\n        selectedMonth: '',\n        loading: false\n      },\n      // Statistics\n      requestStats: {\n        total: 0,\n        pending: 0,\n        approved: 0,\n        completed: 0,\n        thisMonth: 0\n      },\n      // Document Types and Status Options\n      documentTypes: [],\n      searchTimeout: null,\n      // UI State\n      showFilters: false,\n      showBulkActions: false,\n      showRequestDetails: false,\n      showRejectForm: false,\n      showQuickReject: false,\n      showQuickApprove: false,\n      // Verification Modal\n      currentVerification: null,\n      verificationForm: {\n        status: 'pending',\n        notes: ''\n      },\n      showImageModal: false,\n      selectedImage: null,\n      bulkAction: '',\n      documentUrls: {},\n      // Store blob URLs for documents\n      loadingDocuments: new Set(),\n      // Track which documents are currently loading\n      failedDocuments: new Set(),\n      // Track which documents failed to load\n      imageLoadingInModal: false,\n      // Track if modal image is loading\n      modalImageError: false,\n      // Track if modal image failed\n\n      // Status Update Forms\n      statusUpdateForm: {\n        status_id: ''\n      },\n      rejectForm: {\n        reason: ''\n      },\n      quickRejectForm: {\n        loading: false,\n        error: ''\n      },\n      selectedRequestForReject: null,\n      quickApproveForm: {\n        loading: false,\n        error: ''\n      },\n      selectedRequestForApprove: null,\n      // Payment verification form\n      paymentVerificationForm: {\n        amount_received: '',\n        receipt_number: '',\n        loading: false,\n        error: ''\n      },\n      // Pickup scheduling form\n      pickupScheduleForm: {\n        scheduled_date: '',\n        scheduled_time_start: '',\n        scheduled_time_end: '',\n        loading: false,\n        error: ''\n      },\n      // Real-time features\n      refreshInterval: null,\n      autoRefreshEnabled: true,\n      refreshRate: 30000,\n      // 30 seconds\n      lastRefresh: null\n    };\n  },\n  async mounted() {\n    // Check authentication\n    if (!unifiedAuthService.isLoggedIn() || unifiedAuthService.getUserType() !== 'admin') {\n      this.$router.push('/login');\n      return;\n    }\n\n    // Initialize UI state\n    this.initializeUI();\n\n    // Load component data\n    await this.loadComponentData();\n\n    // Initialize PDF export form with default values\n    this.initializePDFExportForm();\n\n    // Initialize real-time features\n    this.initializeRealTimeFeatures();\n  },\n  beforeUnmount() {\n    if (this.handleResize) {\n      window.removeEventListener('resize', this.handleResize);\n    }\n\n    // Clean up real-time features\n    this.cleanupRealTimeFeatures();\n\n    // Clean up blob URLs to prevent memory leaks\n    this.cleanupDocumentUrls();\n  },\n  computed: {\n    activeMenu() {\n      const path = this.$route.path;\n      if (path.includes('/admin/users')) return 'users';\n      if (path.includes('/admin/requests')) return 'requests';\n      if (path.includes('/admin/history')) return 'history';\n      if (path.includes('/admin/reports')) return 'reports';\n      if (path.includes('/admin/settings')) return 'settings';\n      if (path.includes('/admin/activity-logs')) return 'activity';\n      if (path.includes('/admin/profile')) return 'profile';\n      return 'dashboard';\n    }\n  },\n  methods: {\n    // Initialize UI state\n    initializeUI() {\n      this.isMobile = window.innerWidth <= 768;\n\n      // Load saved sidebar state (only on desktop)\n      if (!this.isMobile) {\n        const saved = localStorage.getItem('adminSidebarCollapsed');\n        this.sidebarCollapsed = saved ? JSON.parse(saved) : false;\n      } else {\n        this.sidebarCollapsed = true; // Always collapsed on mobile\n      }\n\n      // Setup resize listener\n      this.handleResize = () => {\n        const wasMobile = this.isMobile;\n        this.isMobile = window.innerWidth <= 768;\n        if (this.isMobile && !wasMobile) {\n          this.sidebarCollapsed = true; // Collapse when switching to mobile\n        } else if (!this.isMobile && wasMobile) {\n          // Restore saved state when switching to desktop\n          const saved = localStorage.getItem('adminSidebarCollapsed');\n          this.sidebarCollapsed = saved ? JSON.parse(saved) : false;\n        }\n      };\n      window.addEventListener('resize', this.handleResize);\n    },\n    // Initialize PDF export form with default values\n    initializePDFExportForm() {\n      // Set default date to today\n      this.pdfExportForm.selectedDate = this.getCurrentDate();\n\n      // Set default week to current week\n      this.pdfExportForm.selectedWeek = this.getCurrentWeek();\n\n      // Set default month to current month\n      this.pdfExportForm.selectedMonth = this.getCurrentMonth();\n    },\n    // Sidebar toggle\n    handleSidebarToggle() {\n      this.sidebarCollapsed = !this.sidebarCollapsed;\n      localStorage.setItem('adminSidebarCollapsed', JSON.stringify(this.sidebarCollapsed));\n    },\n    // Menu navigation\n    handleMenuChange(menu) {\n      const routes = {\n        'dashboard': '/admin/dashboard',\n        'users': '/admin/users',\n        'requests': '/admin/requests',\n        'history': '/admin/history',\n        'reports': '/admin/reports',\n        'settings': '/admin/settings',\n        'activity': '/admin/activity-logs',\n        'profile': '/admin/profile'\n      };\n\n      // Close sidebar on mobile after navigation\n      if (this.isMobile) {\n        this.sidebarCollapsed = true;\n      }\n      if (routes[menu]) {\n        this.$router.push(routes[menu]);\n      }\n    },\n    // User dropdown toggle\n    handleUserDropdownToggle() {\n      this.showUserDropdown = !this.showUserDropdown;\n    },\n    // Handle opening request modal from notifications\n    async handleOpenRequestModal(modalData) {\n      console.log('🔔 AdminRequests: Opening request modal from notification:', modalData);\n      try {\n        const {\n          requestId,\n          focusTab\n        } = modalData;\n        if (!requestId) {\n          console.error('❌ No request ID provided for modal');\n          return;\n        }\n\n        // Use the existing viewRequestDetails method to open the modal\n        await this.viewRequestDetails(requestId);\n\n        // If a specific tab should be focused, handle that after modal opens\n        if (focusTab) {\n          // Wait a bit for the modal to fully render\n          setTimeout(() => {\n            this.focusModalTab(focusTab);\n          }, 300);\n        }\n        console.log('✅ Request modal opened successfully');\n      } catch (error) {\n        console.error('❌ Error opening request modal:', error);\n        // Show error message to user\n        this.showErrorMessage('Failed to open request details');\n      }\n    },\n    // Focus on a specific tab in the request details modal\n    focusModalTab(tabName) {\n      try {\n        console.log('🎯 Focusing on modal tab:', tabName);\n\n        // Map tab names to actual tab elements or actions\n        const tabMappings = {\n          'payment': () => {\n            // Focus on payment section in the modal\n            const paymentSection = document.querySelector('#requestDetailsModal .payment-section');\n            if (paymentSection) {\n              paymentSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              paymentSection.classList.add('highlight-section');\n              setTimeout(() => paymentSection.classList.remove('highlight-section'), 2000);\n            }\n          },\n          'status': () => {\n            // Focus on status section\n            const statusSection = document.querySelector('#requestDetailsModal .status-section');\n            if (statusSection) {\n              statusSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              statusSection.classList.add('highlight-section');\n              setTimeout(() => statusSection.classList.remove('highlight-section'), 2000);\n            }\n          },\n          'documents': () => {\n            // Focus on documents section\n            const documentsSection = document.querySelector('#requestDetailsModal .documents-section');\n            if (documentsSection) {\n              documentsSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              documentsSection.classList.add('highlight-section');\n              setTimeout(() => documentsSection.classList.remove('highlight-section'), 2000);\n            }\n          }\n        };\n        const focusAction = tabMappings[tabName];\n        if (focusAction) {\n          focusAction();\n        } else {\n          console.log('⚠️ Unknown tab name:', tabName);\n        }\n      } catch (error) {\n        console.error('❌ Error focusing modal tab:', error);\n      }\n    },\n    // Menu actions\n    handleMenuAction(action) {\n      if (action === 'profile') {\n        this.$router.push('/admin/profile');\n      } else if (action === 'settings') {\n        this.$router.push('/admin/settings');\n      }\n      this.showUserDropdown = false;\n    },\n    // Close mobile sidebar\n    closeMobileSidebar() {\n      if (this.isMobile) {\n        this.sidebarCollapsed = true;\n      }\n    },\n    // Logout\n    handleLogout() {\n      unifiedAuthService.logout();\n      this.$router.push('/login');\n    },\n    // Load admin profile\n    async loadAdminProfile() {\n      try {\n        const currentUser = unifiedAuthService.getCurrentUser();\n        if (currentUser && currentUser.profile) {\n          this.adminData = currentUser.profile;\n        } else {\n          // Fallback to basic user data\n          this.adminData = {\n            first_name: currentUser?.username || 'Admin',\n            role: currentUser?.role || 'admin'\n          };\n        }\n      } catch (error) {\n        console.error('Failed to load admin profile:', error);\n        const currentUser = unifiedAuthService.getCurrentUser();\n        this.adminData = {\n          first_name: currentUser?.username || 'Admin',\n          role: currentUser?.role || 'admin'\n        };\n      }\n    },\n    // Load all component data\n    async loadComponentData() {\n      this.loading = true;\n      try {\n        await Promise.all([this.loadAdminProfile(), this.loadStatusOptions(), this.loadDocumentTypes(), this.loadRequests(), this.loadDashboardStats()]);\n      } catch (error) {\n        console.error('Failed to load component data:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load request data';\n        if (errorData.status === 401) {\n          unifiedAuthService.logout();\n          this.$router.push('/login');\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Load status options\n    async loadStatusOptions() {\n      try {\n        console.log('🔄 Loading status options...');\n        const response = await adminDocumentService.getStatusOptions();\n        console.log('📋 Status options response:', response);\n        if (response.success) {\n          this.statusOptions = response.data || [];\n          console.log('✅ Status options loaded:', this.statusOptions);\n        } else {\n          console.error('❌ Failed to load status options:', response.message);\n          this.statusOptions = [];\n        }\n      } catch (error) {\n        console.error('❌ Error loading status options:', error);\n        this.statusOptions = [];\n        this.showToast('Error', 'Failed to load status options', 'error');\n      }\n    },\n    // Load document types\n    async loadDocumentTypes() {\n      try {\n        console.log('🔄 Loading document types...');\n        const response = await adminDocumentService.getDocumentTypes();\n        console.log('📋 Document types response:', response);\n        if (response.success) {\n          this.documentTypes = response.data || [];\n          console.log('✅ Document types loaded:', this.documentTypes);\n        } else {\n          console.error('❌ Failed to load document types:', response.message);\n          this.documentTypes = [];\n        }\n      } catch (error) {\n        console.error('❌ Error loading document types:', error);\n        this.documentTypes = [];\n        this.showToast('Error', 'Failed to load document types', 'error');\n      }\n    },\n    // Load dashboard statistics\n    async loadDashboardStats() {\n      try {\n        console.log('🔄 Loading dashboard stats...');\n        const response = await adminDocumentService.getDashboardStats();\n        console.log('📊 Dashboard stats response:', response);\n        if (response.success) {\n          // Map the backend response structure to frontend expectations\n          const data = response.data;\n          this.requestStats = {\n            total: data.overview?.total_requests || 0,\n            pending: data.overview?.pending_requests || 0,\n            approved: data.overview?.approved_requests || 0,\n            completed: data.overview?.completed_requests || 0,\n            thisMonth: data.time_based?.today_requests || 0\n          };\n          console.log('✅ Request stats updated:', this.requestStats);\n        } else {\n          console.error('❌ Failed to load dashboard stats:', response.message);\n        }\n      } catch (error) {\n        console.error('❌ Error loading dashboard stats:', error);\n        // Set default values on error\n        this.requestStats = {\n          total: 0,\n          pending: 0,\n          approved: 0,\n          completed: 0,\n          thisMonth: 0\n        };\n      }\n    },\n    // Load requests with current filters and pagination\n    // NOTE: RequestHistory.vue shows HISTORICAL requests only (completed and cancelled)\n    // For active request management, see AdminRequests.vue\n    async loadRequests() {\n      try {\n        // Load both completed and cancelled requests for historical view\n        const params = {\n          page: this.pagination.currentPage,\n          limit: this.pagination.itemsPerPage,\n          // Remove fixed status filter to get all requests, then filter client-side\n          priority: this.filters.priority,\n          search: this.filters.search,\n          date_from: this.filters.date_from,\n          date_to: this.filters.date_to\n        };\n\n        // Apply document type filter if specified\n        if (this.filters.document_type) {\n          params.document_type = this.filters.document_type;\n        }\n\n        // Apply status filter if specified (allows filtering by specific status)\n        if (this.filters.status) {\n          params.status = this.filters.status;\n        }\n        console.log('🔍 RequestHistory: Loading historical requests (completed and cancelled)...');\n        console.log('📋 RequestHistory: Params:', params);\n        const response = await adminDocumentService.getAllRequests(params);\n        console.log('📥 RequestHistory: API response:', response);\n        if (response.success) {\n          // Filter to show only completed and cancelled requests for historical view\n          const allRequests = response.data.requests || [];\n          const historicalRequests = allRequests.filter(request => {\n            const statusName = request.status_name.toLowerCase();\n            return statusName === 'completed' || statusName === 'cancelled';\n          });\n          this.requests = historicalRequests;\n          console.log('✅ RequestHistory: Loaded historical requests:', this.requests.length, 'requests');\n          console.log('📊 RequestHistory: Breakdown - Total:', allRequests.length, 'Historical:', historicalRequests.length);\n          if (this.requests.length > 0) {\n            console.log('📋 RequestHistory: First request:', this.requests[0]);\n          }\n          this.pagination = {\n            currentPage: response.data.pagination?.current_page || 1,\n            totalPages: response.data.pagination?.total_pages || 1,\n            totalItems: historicalRequests.length,\n            // Update to reflect filtered count\n            itemsPerPage: response.data.pagination?.per_page || 10\n          };\n        } else {\n          console.error('❌ RequestHistory: API returned unsuccessful response:', response);\n        }\n      } catch (error) {\n        console.error('❌ RequestHistory: Failed to load requests:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load requests';\n        this.requests = [];\n      }\n    },\n    // Filter and search methods\n    applyFilters() {\n      this.pagination.currentPage = 1;\n      this.loadRequests();\n    },\n    // Debounced search method\n    debouncedSearch() {\n      clearTimeout(this.searchTimeout);\n      this.searchTimeout = setTimeout(() => {\n        this.applyFilters();\n      }, 300);\n    },\n    clearFilters() {\n      this.filters = {\n        status: '',\n        // Remove fixed completed status filter to show all historical documents\n        document_type: '',\n        priority: '',\n        search: '',\n        date_from: '',\n        date_to: ''\n      };\n      this.applyFilters();\n    },\n    // Pagination methods\n    changePage(page) {\n      if (page >= 1 && page <= this.pagination.totalPages) {\n        this.pagination.currentPage = page;\n        this.loadRequests();\n      }\n    },\n    changeItemsPerPage(itemsPerPage) {\n      this.pagination.itemsPerPage = itemsPerPage;\n      this.pagination.currentPage = 1;\n      this.loadRequests();\n    },\n    goBack() {\n      this.$router.push('/admin/dashboard');\n    },\n    // Request selection methods\n    toggleRequestSelection(requestId) {\n      const index = this.selectedRequests.indexOf(requestId);\n      if (index > -1) {\n        this.selectedRequests.splice(index, 1);\n      } else {\n        this.selectedRequests.push(requestId);\n      }\n    },\n    selectAllRequests() {\n      if (this.selectedRequests.length === this.requests.length) {\n        this.selectedRequests = [];\n      } else {\n        this.selectedRequests = this.requests.map(r => r.id);\n      }\n    },\n    // Request details\n    async viewRequestDetails(requestId) {\n      console.log('🚀 View details clicked for request ID:', requestId);\n      try {\n        const response = await adminDocumentService.getRequestDetails(requestId);\n        console.log('📋 API Response received:', response);\n        if (response.success) {\n          console.log('✅ Response successful, data:', response.data);\n\n          // Debug client profile fields\n          const data = response.data;\n          console.log('🎯 COMPLETE RESPONSE DATA:', data);\n          console.log('🎯 ALL DATA KEYS:', Object.keys(data));\n          console.log('🎯 CLIENT PROFILE FIELDS DEBUG:');\n          console.log('   Birth Date:', data.client_birth_date);\n          console.log('   Gender:', data.client_gender);\n          console.log('   Civil Status ID:', data.client_civil_status_id);\n          console.log('   Nationality:', data.client_nationality);\n          console.log('   Years of Residency:', data.client_years_of_residency);\n          console.log('   Months of Residency:', data.client_months_of_residency);\n\n          // Check if fields exist with different names\n          console.log('🔍 SEARCHING FOR SIMILAR FIELDS:');\n          Object.keys(data).forEach(key => {\n            if (key.includes('birth') || key.includes('gender') || key.includes('civil') || key.includes('nationality') || key.includes('residency')) {\n              console.log(`   Found: ${key} = ${data[key]}`);\n            }\n          });\n          this.currentRequest = response.data;\n          this.showRequestDetails = true;\n          // Reset forms\n          this.statusUpdateForm = {\n            status_id: ''\n          };\n          this.rejectForm = {\n            reason: ''\n          };\n          this.showRejectForm = false;\n          console.log('📋 Request details loaded:', response.data);\n\n          // Load document URLs for images\n          if (response.data.uploaded_documents && response.data.uploaded_documents.length > 0) {\n            this.loadDocumentUrls(response.data.uploaded_documents);\n          }\n          this.showToast('Success', `Request details loaded for ${response.data.request_number}`, 'success');\n        }\n      } catch (error) {\n        console.error('Failed to load request details:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load request details';\n        this.showToast('Error', 'Failed to load request details', 'error');\n      }\n    },\n    // Refresh request details\n    async refreshRequestDetails() {\n      if (this.currentRequest) {\n        await this.viewRequestDetails(this.currentRequest.id);\n      }\n    },\n    // Update request status from modal\n    async updateRequestStatusFromModal() {\n      console.log('🔄 Updating request status...');\n      console.log('📋 Status form data:', this.statusUpdateForm);\n      console.log('📋 Current request:', this.currentRequest);\n      if (!this.statusUpdateForm.status_id || !this.currentRequest) {\n        console.error('❌ Missing required data for status update');\n        this.showToast('Error', 'Please select a status to update', 'error');\n        return;\n      }\n\n      // Enhanced debugging for status validation\n      const currentStatus = this.currentRequest.status_name;\n      const newStatusId = this.statusUpdateForm.status_id;\n      const newStatus = this.statusOptions.find(s => s.id == newStatusId);\n      console.log('🔍 Status validation debug:');\n      console.log('   Current status:', currentStatus);\n      console.log('   New status ID:', newStatusId, '(type:', typeof newStatusId, ')');\n      console.log('   New status object:', newStatus);\n      console.log('   Available transitions:', this.getAllowedStatusTransitions(currentStatus.toLowerCase()));\n      console.log('   Available status options:', this.getAvailableStatusOptions());\n      console.log('   All status options:', this.statusOptions);\n      if (!this.isValidStatusChange(currentStatus, newStatusId)) {\n        console.error('❌ Invalid status change attempted');\n        console.error('   From:', currentStatus, 'To:', newStatus?.status_name);\n        this.showToast('Error', 'This status change is not allowed', 'error');\n        return;\n      }\n      try {\n        const updateData = {\n          status_id: parseInt(this.statusUpdateForm.status_id)\n        };\n        console.log('📤 Sending status update:', updateData);\n        const response = await adminDocumentService.updateRequestStatus(this.currentRequest.id, updateData);\n        console.log('📥 Status update response:', response);\n        if (response.success) {\n          // Refresh the request details\n          await this.refreshRequestDetails();\n          // Refresh the main requests list\n          await this.loadRequests();\n          // Reset form\n          this.statusUpdateForm = {\n            status_id: ''\n          };\n\n          // Show success message\n          this.errorMessage = '';\n          this.showToast('Success', 'Request status updated successfully', 'success');\n        } else {\n          console.error('❌ Status update failed:', response.message);\n          this.showToast('Error', response.message || 'Failed to update request status', 'error');\n        }\n      } catch (error) {\n        console.error('❌ Error updating request status:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to update request status';\n        this.showToast('Error', errorData.message || 'Failed to update request status', 'error');\n      }\n    },\n    // Reject request from modal\n    async rejectRequestFromModal() {\n      if (!this.currentRequest || !this.rejectForm.reason.trim()) return;\n      try {\n        const response = await adminDocumentService.rejectRequest(this.currentRequest.id, {\n          reason: this.rejectForm.reason\n        });\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n          this.rejectForm = {\n            reason: ''\n          };\n          this.showRejectForm = false;\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to reject request';\n      }\n    },\n    // Status update methods\n    async updateRequestStatus(requestId, statusId, reason = '') {\n      try {\n        const response = await adminDocumentService.updateRequestStatus(requestId, {\n          status_id: statusId,\n          reason: reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to update request status:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to update request status';\n      }\n    },\n    async approveRequest(requestId, reason = '') {\n      try {\n        const response = await adminDocumentService.approveRequest(requestId, {\n          reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to approve request';\n      }\n    },\n    async rejectRequest(requestId, reason) {\n      if (!reason || reason.trim() === '') {\n        this.errorMessage = 'Rejection reason is required';\n        return;\n      }\n      try {\n        const response = await adminDocumentService.rejectRequest(requestId, {\n          reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to reject request';\n      }\n    },\n    // Quick approval/rejection methods\n    canApprove(request) {\n      // Can approve if 'approved' is in allowed transitions\n      const allowedTransitions = this.getAllowedStatusTransitions(request.status_name.toLowerCase());\n      return allowedTransitions.includes('approved');\n    },\n    canReject(request) {\n      // Can reject if 'rejected' is in allowed transitions\n      const allowedTransitions = this.getAllowedStatusTransitions(request.status_name.toLowerCase());\n      return allowedTransitions.includes('rejected');\n    },\n    // Helper method to get status explanation for disabled buttons\n    getStatusExplanation(request, action) {\n      const status = request.status_name.toLowerCase();\n      const allowedTransitions = this.getAllowedStatusTransitions(status);\n      if (action === 'approve') {\n        if (allowedTransitions.includes('approved')) {\n          return 'Click to approve this request';\n        } else if (status === 'approved') {\n          return 'This request has already been approved';\n        } else if (status === 'rejected') {\n          return 'Rejected requests can be resubmitted, not directly approved';\n        } else if (status === 'completed') {\n          return 'This request has already been completed';\n        } else {\n          return `Cannot approve from ${this.formatStatus(status)} status`;\n        }\n      } else if (action === 'reject') {\n        if (allowedTransitions.includes('rejected')) {\n          return 'Click to reject this request';\n        } else if (status === 'rejected') {\n          return 'This request has already been rejected';\n        } else if (status === 'completed') {\n          return 'Cannot reject a completed request';\n        } else {\n          return `Cannot reject from ${this.formatStatus(status)} status`;\n        }\n      }\n      return `Request status: ${this.formatStatus(status)}`;\n    },\n    // Check if status change is valid\n    isValidStatusChange(currentStatus, newStatusId) {\n      if (!currentStatus || !newStatusId) return false;\n\n      // Find the new status name\n      const newStatus = this.statusOptions.find(s => s.id == newStatusId);\n      if (!newStatus) return false;\n      const currentStatusName = currentStatus.toLowerCase();\n      const newStatusName = newStatus.status_name.toLowerCase();\n\n      // Same status - no change needed\n      if (currentStatusName === newStatusName) {\n        return false;\n      }\n\n      // Check if transition is allowed based on workflow rules\n      const allowedTransitions = this.getAllowedStatusTransitions(currentStatusName);\n      return allowedTransitions.includes(newStatusName);\n    },\n    // Check if request needs payment verification\n    needsPaymentVerification(request) {\n      return request.status_name === 'payment_pending' && request.payment_method && !request.payment_method.includes('PayMongo') && request.payment_status !== 'paid';\n    },\n    // Check if pickup can be scheduled\n    canSchedulePickup(request) {\n      return request.status_name === 'ready_for_pickup';\n    },\n    // Get payment status color\n    getPaymentStatusColor(status) {\n      const colors = {\n        'pending': 'bg-warning',\n        'processing': 'bg-info',\n        'paid': 'bg-success',\n        'failed': 'bg-danger',\n        'refunded': 'bg-secondary',\n        'cancelled': 'bg-dark'\n      };\n      return colors[status] || 'bg-secondary';\n    },\n    // Format payment status\n    formatPaymentStatus(status) {\n      const statuses = {\n        'pending': 'Pending',\n        'processing': 'Processing',\n        'paid': 'Paid',\n        'failed': 'Failed',\n        'refunded': 'Refunded',\n        'cancelled': 'Cancelled'\n      };\n      return statuses[status] || 'Unknown';\n    },\n    // Get tomorrow's date for pickup scheduling\n    getTomorrowDate() {\n      const tomorrow = new Date();\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      return tomorrow.toISOString().split('T')[0];\n    },\n    // Validate pickup form\n    isPickupFormValid() {\n      return this.pickupScheduleForm.scheduled_date && this.pickupScheduleForm.scheduled_time_start && this.pickupScheduleForm.scheduled_time_end && this.pickupScheduleForm.scheduled_time_start < this.pickupScheduleForm.scheduled_time_end;\n    },\n    // Get filtered status options based on current status\n    getAvailableStatusOptions() {\n      if (!this.currentRequest || !this.statusOptions) return [];\n      const currentStatus = this.currentRequest.status_name.toLowerCase();\n\n      // Only these states are truly final (cannot be changed)\n      const finalStates = ['completed', 'cancelled'];\n\n      // If current status is final, no changes allowed\n      if (finalStates.includes(currentStatus)) {\n        return [];\n      }\n\n      // Define allowed transitions based on current status\n      const allowedTransitions = this.getAllowedStatusTransitions(currentStatus);\n\n      // Return only allowed status options\n      return this.statusOptions.filter(status => allowedTransitions.includes(status.status_name.toLowerCase()));\n    },\n    // Define allowed status transitions based on government workflow best practices\n    // This must match the backend validateStatusTransition logic exactly\n    getAllowedStatusTransitions(currentStatus) {\n      // Check if current request uses cash payment - enhanced detection\n      const isCashPayment = this.currentRequest && (this.currentRequest.payment_method === 'Cash Payment' || this.currentRequest.payment_method === 'Cash' || this.currentRequest.payment_method_code === 'CASH' || this.currentRequest.payment_method_id === 1 ||\n      // Assuming cash is ID 1\n      !this.currentRequest.is_online_payment);\n      console.log('🔍 Cash payment detection:', {\n        payment_method: this.currentRequest?.payment_method,\n        payment_method_code: this.currentRequest?.payment_method_code,\n        payment_method_id: this.currentRequest?.payment_method_id,\n        is_online_payment: this.currentRequest?.is_online_payment,\n        isCashPayment: isCashPayment\n      });\n      const transitions = {\n        // Simplified workflow matching actual database statuses\n        'pending': ['approved', 'cancelled', 'rejected'],\n        'under_review': ['approved', 'rejected', 'cancelled'],\n        'approved': isCashPayment ? ['payment_confirmed', 'processing', 'cancelled'] // Cash payments can go directly to processing\n        : ['payment_confirmed', 'cancelled'],\n        // Online payments go through PayMongo webhook to payment_confirmed\n        'payment_confirmed': ['processing'],\n        // Automatic transition after payment\n        'processing': ['ready_for_pickup'],\n        // Processing can only complete successfully\n        'ready_for_pickup': ['completed', 'cancelled'],\n        // Simplified - direct completion\n        'rejected': ['pending', 'under_review'],\n        // Allow resubmission after corrections\n        // Final states - no transitions allowed\n        'completed': [],\n        'cancelled': []\n      };\n      return transitions[currentStatus] || [];\n    },\n    // Get title for update button based on validation state\n    getUpdateButtonTitle() {\n      if (!this.statusUpdateForm.status_id) {\n        return 'Please select a new status';\n      }\n      if (!this.isValidStatusChange(this.currentRequest.status_name, this.statusUpdateForm.status_id)) {\n        return 'Invalid status change';\n      }\n      return 'Update request status';\n    },\n    // Get dynamic button text based on selected status\n    getActionButtonText() {\n      if (!this.statusUpdateForm.status_id) {\n        return 'Update Status';\n      }\n      const selectedStatus = this.statusOptions.find(s => s.id === parseInt(this.statusUpdateForm.status_id));\n      if (!selectedStatus) {\n        return 'Update Status';\n      }\n      const statusName = selectedStatus.status_name.toLowerCase();\n\n      // Special button text for common actions\n      switch (statusName) {\n        case 'approved':\n          return 'Approve Request';\n        case 'rejected':\n          return 'Reject Request';\n        case 'under_review':\n          return 'Move to Review';\n        case 'processing':\n          return 'Start Processing';\n        case 'ready_for_pickup':\n          return 'Mark Ready for Pickup';\n        case 'completed':\n          return 'Complete Request';\n        default:\n          return `Update to ${selectedStatus.status_name}`;\n      }\n    },\n    async quickApprove(request) {\n      console.log('🚀 Quick approve clicked for request:', request);\n      try {\n        this.loading = true;\n        const response = await adminDocumentService.approveRequest(request.id, {\n          reason: 'Quick approval from admin interface'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${request.request_number} approved successfully`, 'success');\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.showToast('Error', errorData.message || 'Failed to approve request', 'error');\n      } finally {\n        this.loading = false;\n      }\n    },\n    showQuickRejectModal(request) {\n      console.log('🚀 Quick reject clicked for request:', request);\n      this.selectedRequestForReject = request;\n      this.quickRejectForm = {\n        loading: false,\n        error: ''\n      };\n      this.showQuickReject = true;\n    },\n    closeQuickRejectModal() {\n      this.showQuickReject = false;\n      this.selectedRequestForReject = null;\n      this.quickRejectForm = {\n        loading: false,\n        error: ''\n      };\n    },\n    async confirmQuickReject() {\n      this.quickRejectForm.loading = true;\n      this.quickRejectForm.error = '';\n      try {\n        const response = await adminDocumentService.rejectRequest(this.selectedRequestForReject.id, {\n          reason: 'Request rejected by admin'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${this.selectedRequestForReject.request_number} rejected successfully`, 'success');\n          this.closeQuickRejectModal();\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.quickRejectForm.error = errorData.message || 'Failed to reject request';\n      } finally {\n        this.quickRejectForm.loading = false;\n      }\n    },\n    showQuickApproveModal(request) {\n      console.log('🚀 Quick approve clicked for request:', request);\n      this.selectedRequestForApprove = request;\n      this.quickApproveForm = {\n        loading: false,\n        error: ''\n      };\n      this.showQuickApprove = true;\n    },\n    closeQuickApproveModal() {\n      this.showQuickApprove = false;\n      this.selectedRequestForApprove = null;\n      this.quickApproveForm = {\n        loading: false,\n        error: ''\n      };\n    },\n    async confirmQuickApprove() {\n      this.quickApproveForm.loading = true;\n      this.quickApproveForm.error = '';\n      try {\n        const response = await adminDocumentService.approveRequest(this.selectedRequestForApprove.id, {\n          reason: 'Quick approval from admin interface'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${this.selectedRequestForApprove.request_number} approved successfully`, 'success');\n          this.closeQuickApproveModal();\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.quickApproveForm.error = errorData.message || 'Failed to approve request';\n      } finally {\n        this.quickApproveForm.loading = false;\n      }\n    },\n    // Bulk operations\n    async performBulkAction() {\n      if (this.selectedRequests.length === 0) {\n        this.errorMessage = 'Please select at least one request';\n        return;\n      }\n      if (!this.bulkAction) {\n        this.errorMessage = 'Please select a bulk action';\n        return;\n      }\n      try {\n        const response = await adminDocumentService.bulkUpdateRequests({\n          request_ids: this.selectedRequests,\n          status_id: parseInt(this.bulkAction)\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.selectedRequests = [];\n          this.bulkAction = '';\n          this.showBulkActions = false;\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to perform bulk action:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to perform bulk action';\n      }\n    },\n    // Export functionality\n    async exportRequests() {\n      try {\n        const csvData = await adminDocumentService.exportRequests(this.filters);\n        const filename = `document_requests_${new Date().toISOString().split('T')[0]}.csv`;\n        adminDocumentService.downloadCSV(csvData, filename);\n      } catch (error) {\n        console.error('Failed to export requests:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to export requests';\n      }\n    },\n    // PDF Export functionality\n    async exportToPDF() {\n      if (!this.isPDFExportValid()) {\n        this.showToast('Error', 'Please select a valid date range for the report', 'error');\n        return;\n      }\n      try {\n        this.pdfExportForm.loading = true;\n\n        // Get filtered data based on report type\n        const reportData = await this.getReportData();\n        if (!reportData || reportData.length === 0) {\n          this.showToast('Warning', 'No data found for the selected date range', 'warning');\n          return;\n        }\n\n        // Generate PDF\n        const pdf = new jsPDF();\n        this.generatePDFReport(pdf, reportData);\n\n        // Download PDF\n        const filename = this.getPDFFilename();\n        pdf.save(filename);\n        this.showToast('Success', 'PDF report generated successfully', 'success');\n      } catch (error) {\n        console.error('Failed to generate PDF report:', error);\n        this.showToast('Error', 'Failed to generate PDF report', 'error');\n      } finally {\n        this.pdfExportForm.loading = false;\n      }\n    },\n    // Get report data based on selected filters\n    async getReportData() {\n      const reportFilters = {\n        ...this.filters\n      };\n\n      // Set date range based on report type\n      const dateRange = this.getDateRangeForReport();\n      reportFilters.date_from = dateRange.from;\n      reportFilters.date_to = dateRange.to;\n      try {\n        console.log('📊 Fetching report data with filters:', reportFilters);\n        const response = await adminDocumentService.getAllRequests({\n          ...reportFilters,\n          page: 1,\n          limit: 1000 // Get all data for the report\n        });\n        console.log('📊 Raw API response:', response);\n        if (response.success && response.data.requests) {\n          const allRequests = response.data.requests;\n          console.log('📊 All requests from API:', allRequests);\n\n          // Log sample request structure for debugging\n          if (allRequests.length > 0) {\n            console.log('📊 Sample request structure:', {\n              request_number: allRequests[0].request_number,\n              total_document_fee: allRequests[0].total_document_fee,\n              total_fee: allRequests[0].total_fee,\n              amount: allRequests[0].amount,\n              all_fields: Object.keys(allRequests[0])\n            });\n          }\n\n          // Filter to only show completed and cancelled requests (historical data)\n          const filteredRequests = allRequests.filter(request => ['completed', 'cancelled'].includes(request.status_name.toLowerCase()));\n          console.log('📊 Filtered requests for PDF:', filteredRequests);\n          return filteredRequests;\n        }\n        return [];\n      } catch (error) {\n        console.error('Failed to fetch report data:', error);\n        throw error;\n      }\n    },\n    // Get date range based on report type and selected values\n    getDateRangeForReport() {\n      const {\n        reportType,\n        selectedDate,\n        selectedWeek,\n        selectedMonth\n      } = this.pdfExportForm;\n      switch (reportType) {\n        case 'daily':\n          return {\n            from: selectedDate,\n            to: selectedDate\n          };\n        case 'weekly':\n          if (selectedWeek) {\n            const [year, week] = selectedWeek.split('-W');\n            const startDate = this.getDateFromWeek(parseInt(year), parseInt(week));\n            const endDate = new Date(startDate);\n            endDate.setDate(startDate.getDate() + 6);\n            return {\n              from: startDate.toISOString().split('T')[0],\n              to: endDate.toISOString().split('T')[0]\n            };\n          }\n          break;\n        case 'monthly':\n          if (selectedMonth) {\n            const [year, month] = selectedMonth.split('-');\n            const startDate = new Date(parseInt(year), parseInt(month) - 1, 1);\n            const endDate = new Date(parseInt(year), parseInt(month), 0);\n            return {\n              from: startDate.toISOString().split('T')[0],\n              to: endDate.toISOString().split('T')[0]\n            };\n          }\n          break;\n      }\n      return {\n        from: '',\n        to: ''\n      };\n    },\n    // Generate PDF report content\n    generatePDFReport(pdf, data) {\n      const dateRange = this.getDateRangeForReport();\n\n      // Document Header with improved styling\n      pdf.setFontSize(24);\n      pdf.setFont('helvetica', 'bold');\n      pdf.setTextColor(44, 62, 80); // Dark blue-gray\n      pdf.text('BARANGAY DOCUMENT REQUEST HISTORY', 105, 25, {\n        align: 'center'\n      });\n\n      // Decorative line under header\n      pdf.setDrawColor(52, 152, 219); // Blue line\n      pdf.setLineWidth(1);\n      pdf.line(20, 30, 190, 30);\n\n      // Report type and metadata section\n      pdf.setFontSize(14);\n      pdf.setFont('helvetica', 'bold');\n      pdf.setTextColor(0, 0, 0);\n      const reportTitle = this.getReportTitle();\n      pdf.text(reportTitle, 20, 45);\n\n      // Date range with improved formatting\n      pdf.setFontSize(11);\n      pdf.setFont('helvetica', 'normal');\n      const dateRangeText = this.getDateRangeText(dateRange);\n      pdf.text(`Report Period: ${dateRangeText}`, 20, 55);\n\n      // Generated date\n      const generatedDate = new Date().toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n      pdf.text(`Generated: ${generatedDate}`, 20, 65);\n\n      // Summary statistics with improved layout\n      const stats = this.calculateReportStats(data);\n\n      // Summary box background\n      pdf.setFillColor(248, 249, 250); // Light gray background\n      pdf.setDrawColor(206, 212, 218); // Border color\n      pdf.roundedRect(20, 75, 170, 35, 3, 3, 'FD'); // Rounded rectangle with fill and border\n\n      pdf.setFontSize(12);\n      pdf.setFont('helvetica', 'bold');\n      pdf.setTextColor(52, 58, 64);\n      pdf.text('SUMMARY STATISTICS', 25, 85);\n      pdf.setFontSize(10);\n      pdf.setFont('helvetica', 'normal');\n\n      // Statistics in columns\n      pdf.text(`Total Requests: ${stats.total}`, 25, 95);\n      pdf.text(`Completed: ${stats.completed}`, 80, 95);\n      pdf.text(`Cancelled: ${stats.cancelled}`, 135, 95);\n\n      // Add percentage if there are requests\n      if (stats.total > 0) {\n        const completionRate = Math.round(stats.completed / stats.total * 100);\n        pdf.text(`Completion Rate: ${completionRate}%`, 25, 105);\n      }\n\n      // Generate table with improved design (matching AdminReports.vue styling)\n      if (data && data.length > 0) {\n        const tableData = data.slice(0, 100).map(request => [request.request_number || 'N/A', request.client_name || 'N/A', request.document_type || 'N/A', this.formatStatus(request.status_name) || 'N/A', this.formatCurrencyForPDF(this.getAmountForPDF(request)), this.formatDateForPDF(request.requested_at) || 'N/A']);\n\n        // Use autoTable function (v5.x syntax) with AdminReports.vue styling\n        try {\n          console.log('🔧 Calling autoTable function');\n          autoTable(pdf, {\n            head: [['Request #', 'Client Name', 'Document Type', 'Status', 'Amount', 'Date']],\n            body: tableData,\n            startY: 125,\n            theme: 'grid',\n            headStyles: {\n              fillColor: [52, 152, 219],\n              textColor: 255,\n              fontStyle: 'bold',\n              fontSize: 8\n            },\n            styles: {\n              fontSize: 7,\n              cellPadding: 3,\n              overflow: 'linebreak',\n              cellWidth: 'wrap'\n            },\n            columnStyles: {\n              0: {\n                cellWidth: 30,\n                halign: 'center'\n              },\n              // Request #\n              1: {\n                cellWidth: 35,\n                overflow: 'linebreak'\n              },\n              // Client Name (wrappable)\n              2: {\n                cellWidth: 38,\n                overflow: 'linebreak'\n              },\n              // Document Type (wrappable)\n              3: {\n                cellWidth: 22,\n                halign: 'center'\n              },\n              // Status\n              4: {\n                cellWidth: 20,\n                halign: 'right'\n              },\n              // Amount\n              5: {\n                cellWidth: 25,\n                halign: 'center'\n              } // Date\n            }\n          });\n          console.log('✅ AutoTable completed successfully');\n        } catch (autoTableError) {\n          console.error('❌ AutoTable call failed:', autoTableError);\n          throw new Error(`AutoTable failed: ${autoTableError.message}`);\n        }\n      }\n\n      // Add professional footer\n      this.addPDFFooter(pdf);\n    },\n    // Fallback method to generate table manually using native jsPDF\n    generateManualTable(pdf, data) {\n      let yPosition = 125;\n      const lineHeight = 14;\n      const headerHeight = 12;\n\n      // Improved column positioning and widths - matching autoTable\n      const columns = [{\n        x: 22,\n        width: 30,\n        align: 'center'\n      },\n      // Request Number\n      {\n        x: 54,\n        width: 35,\n        align: 'left'\n      },\n      // Client Name\n      {\n        x: 91,\n        width: 38,\n        align: 'left'\n      },\n      // Document Type\n      {\n        x: 131,\n        width: 22,\n        align: 'center'\n      },\n      // Status\n      {\n        x: 155,\n        width: 20,\n        align: 'right'\n      },\n      // Amount (smaller)\n      {\n        x: 177,\n        width: 25,\n        align: 'center'\n      } // Date\n      ];\n\n      // Header background first (draw background before text)\n      pdf.setFillColor(52, 152, 219); // Professional blue\n      pdf.rect(20, yPosition - 10, 170, headerHeight, 'F');\n\n      // Header border on top of background\n      pdf.setDrawColor(206, 212, 218);\n      pdf.setLineWidth(0.5);\n      pdf.rect(20, yPosition - 10, 170, headerHeight, 'D');\n\n      // Header text styling\n      pdf.setFontSize(9);\n      pdf.setFont('helvetica', 'bold');\n      pdf.setTextColor(255, 255, 255); // White text\n\n      // Header text positioning - improved to prevent overlap\n      const headers = ['Request Number', 'Client Name', 'Document Type', 'Status', 'Amount', 'Date'];\n      const headerY = yPosition - 4; // Better vertical positioning\n\n      headers.forEach((header, index) => {\n        const col = columns[index];\n        let textX;\n        let align = 'left';\n        if (col.align === 'center') {\n          textX = col.x + col.width / 2;\n          align = 'center';\n        } else if (col.align === 'right') {\n          textX = col.x + col.width - 2;\n          align = 'right';\n        } else {\n          textX = col.x + 2;\n          align = 'left';\n        }\n        pdf.text(header, textX, headerY, {\n          align: align\n        });\n      });\n      yPosition += 6; // More space after header to prevent overlap\n\n      // Reset text color and font for data rows\n      pdf.setTextColor(33, 37, 41); // Dark gray\n      pdf.setFont('helvetica', 'normal');\n      pdf.setFontSize(8.5); // Slightly smaller but readable\n\n      // Table rows with improved formatting\n      data.forEach((request, index) => {\n        // Alternate row background\n        if (index % 2 === 1) {\n          pdf.setFillColor(248, 249, 250); // Very light gray\n          pdf.rect(20, yPosition - 8, 170, lineHeight, 'F');\n        }\n\n        // Row border\n        pdf.setDrawColor(206, 212, 218);\n        pdf.rect(20, yPosition - 8, 170, lineHeight, 'D');\n\n        // Row data with proper formatting\n        const rowData = [request.request_number || 'N/A', this.truncateText(request.client_name || 'N/A', 18), this.truncateText(request.document_type || 'N/A', 20), this.formatStatus(request.status_name) || 'N/A', this.formatCurrencyForPDF(this.getAmountForPDF(request)), this.formatDateForPDF(request.requested_at) || 'N/A'];\n        rowData.forEach((cellData, colIndex) => {\n          const col = columns[colIndex];\n          const text = String(cellData);\n          if (col.align === 'center') {\n            pdf.text(text, col.x + col.width / 2, yPosition, {\n              align: 'center'\n            });\n          } else if (col.align === 'right') {\n            pdf.text(text, col.x + col.width - 2, yPosition, {\n              align: 'right'\n            });\n          } else {\n            pdf.text(text, col.x + 2, yPosition);\n          }\n        });\n        yPosition += lineHeight;\n\n        // Add new page if needed\n        if (yPosition > 260) {\n          pdf.addPage();\n          yPosition = 30;\n\n          // Repeat header on new page\n          pdf.setFillColor(52, 152, 219);\n          pdf.rect(20, yPosition - 10, 170, headerHeight, 'F');\n          pdf.setTextColor(255, 255, 255);\n          pdf.setFont('helvetica', 'bold');\n          pdf.setFontSize(9);\n          headers.forEach((header, index) => {\n            const col = columns[index];\n            if (col.align === 'center') {\n              pdf.text(header, col.x + col.width / 2, yPosition - 3, {\n                align: 'center'\n              });\n            } else if (col.align === 'right') {\n              pdf.text(header, col.x + col.width - 2, yPosition - 3, {\n                align: 'right'\n              });\n            } else {\n              pdf.text(header, col.x + 2, yPosition - 3);\n            }\n          });\n          yPosition += 4;\n          pdf.setTextColor(33, 37, 41);\n          pdf.setFont('helvetica', 'normal');\n          pdf.setFontSize(8.5);\n        }\n      });\n\n      // Add footer to manual table as well\n      this.addPDFFooter(pdf);\n    },\n    // Add professional footer to PDF\n    addPDFFooter(pdf) {\n      const pageCount = pdf.internal.getNumberOfPages();\n      for (let i = 1; i <= pageCount; i++) {\n        pdf.setPage(i);\n\n        // Footer line\n        pdf.setDrawColor(206, 212, 218);\n        pdf.setLineWidth(0.5);\n        pdf.line(20, 280, 190, 280);\n\n        // Footer text\n        pdf.setFontSize(8);\n        pdf.setFont('helvetica', 'normal');\n        pdf.setTextColor(108, 117, 125); // Gray text\n\n        // Left side - Document info\n        pdf.text('Barangay Document Management System', 20, 285);\n        pdf.text('Official Document Request Report', 20, 290);\n\n        // Right side - Page number\n        pdf.text(`Page ${i} of ${pageCount}`, 190, 285, {\n          align: 'right'\n        });\n        pdf.text(`Generated: ${new Date().toLocaleDateString()}`, 190, 290, {\n          align: 'right'\n        });\n      }\n    },\n    // Helper method to truncate text for table cells\n    truncateText(text, maxLength) {\n      if (!text) return '';\n      return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;\n    },\n    // Format date specifically for PDF display (month and day only)\n    formatDateForPDF(dateString) {\n      if (!dateString) return 'N/A';\n      const date = new Date(dateString);\n      // Show only month and day (no year to save space)\n      const month = date.toLocaleDateString('en-US', {\n        month: 'short'\n      });\n      const day = date.getDate().toString().padStart(2, '0');\n      return `${month} ${day}`;\n    },\n    // Format currency specifically for PDF (compact format, no PHP prefix)\n    formatCurrencyForPDF(amount) {\n      // Debug logging to trace amount values\n      console.log('💰 formatCurrencyForPDF input:', {\n        original: amount,\n        type: typeof amount,\n        parsed: parseFloat(amount),\n        isNaN: isNaN(parseFloat(amount))\n      });\n      const numAmount = parseFloat(amount) || 0;\n      const formatter = new Intl.NumberFormat('en-US', {\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n      });\n      const result = formatter.format(numAmount);\n      console.log('💰 formatCurrencyForPDF result:', result);\n      return result;\n    },\n    // Enhanced method to extract amount from request data\n    getAmountForPDF(request) {\n      // Debug the entire request object structure\n      console.log('📊 getAmountForPDF - Full request object:', request);\n\n      // Try multiple possible field names in order of preference\n      const possibleAmountFields = ['total_document_fee', 'total_fee', 'amount', 'document_fee', 'fee'];\n      let amount = 0;\n      let foundField = null;\n      for (const field of possibleAmountFields) {\n        if (request[field] !== undefined && request[field] !== null) {\n          const fieldValue = parseFloat(request[field]);\n          if (!isNaN(fieldValue) && fieldValue > 0) {\n            amount = fieldValue;\n            foundField = field;\n            break;\n          }\n        }\n      }\n      console.log('💰 getAmountForPDF result:', {\n        request_number: request.request_number,\n        found_field: foundField,\n        amount: amount,\n        all_fields: possibleAmountFields.reduce((acc, field) => {\n          acc[field] = request[field];\n          return acc;\n        }, {})\n      });\n      return amount;\n    },\n    // Method to disable debug logging for production\n    disablePDFDebugLogging() {\n      // Override console.log for PDF-related debugging\n      const originalLog = console.log;\n      console.log = function (...args) {\n        if (args.length > 0 && typeof args[0] === 'string' && (args[0].includes('💰') || args[0].includes('📊'))) {\n          return; // Skip PDF debug logs\n        }\n        originalLog.apply(console, args);\n      };\n    },\n    // Helper methods for PDF export\n    isPDFExportValid() {\n      const {\n        reportType,\n        selectedDate,\n        selectedWeek,\n        selectedMonth\n      } = this.pdfExportForm;\n      switch (reportType) {\n        case 'daily':\n          return selectedDate !== '';\n        case 'weekly':\n          return selectedWeek !== '';\n        case 'monthly':\n          return selectedMonth !== '';\n        default:\n          return false;\n      }\n    },\n    getPDFFilename() {\n      const {\n        reportType,\n        selectedDate,\n        selectedWeek,\n        selectedMonth\n      } = this.pdfExportForm;\n      const timestamp = new Date().toISOString().split('T')[0];\n      switch (reportType) {\n        case 'daily':\n          return `daily_report_${selectedDate}_${timestamp}.pdf`;\n        case 'weekly':\n          return `weekly_report_${selectedWeek}_${timestamp}.pdf`;\n        case 'monthly':\n          return `monthly_report_${selectedMonth}_${timestamp}.pdf`;\n        default:\n          return `report_${timestamp}.pdf`;\n      }\n    },\n    getReportTitle() {\n      const {\n        reportType\n      } = this.pdfExportForm;\n      switch (reportType) {\n        case 'daily':\n          return 'Daily Document Request Report';\n        case 'weekly':\n          return 'Weekly Document Request Report';\n        case 'monthly':\n          return 'Monthly Document Request Report';\n        default:\n          return 'Document Request Report';\n      }\n    },\n    getDateRangeText(dateRange) {\n      if (dateRange.from === dateRange.to) {\n        return this.formatDate(dateRange.from);\n      }\n      return `${this.formatDate(dateRange.from)} to ${this.formatDate(dateRange.to)}`;\n    },\n    calculateReportStats(data) {\n      return {\n        total: data.length,\n        completed: data.filter(r => r.status_name.toLowerCase() === 'completed').length,\n        cancelled: data.filter(r => r.status_name.toLowerCase() === 'cancelled').length\n      };\n    },\n    getDateFromWeek(year, week) {\n      const simple = new Date(year, 0, 1 + (week - 1) * 7);\n      const dow = simple.getDay();\n      const ISOweekStart = simple;\n      if (dow <= 4) {\n        ISOweekStart.setDate(simple.getDate() - simple.getDay() + 1);\n      } else {\n        ISOweekStart.setDate(simple.getDate() + 8 - simple.getDay());\n      }\n      return ISOweekStart;\n    },\n    // Date helper methods for form validation\n    getCurrentDate() {\n      return new Date().toISOString().split('T')[0];\n    },\n    getCurrentWeek() {\n      const now = new Date();\n      const year = now.getFullYear();\n      const week = this.getWeekNumber(now);\n      return `${year}-W${week.toString().padStart(2, '0')}`;\n    },\n    getCurrentMonth() {\n      const now = new Date();\n      const year = now.getFullYear();\n      const month = (now.getMonth() + 1).toString().padStart(2, '0');\n      return `${year}-${month}`;\n    },\n    getWeekNumber(date) {\n      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n      const dayNum = d.getUTCDay() || 7;\n      d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);\n    },\n    // Verify in-person payment\n    async verifyInPersonPayment() {\n      if (!this.paymentVerificationForm.amount_received || !this.currentRequest) {\n        this.showToast('Error', 'Please enter the amount received', 'error');\n        return;\n      }\n      const totalFee = parseFloat(this.currentRequest.total_document_fee || this.currentRequest.total_fee);\n      const amountReceived = parseFloat(this.paymentVerificationForm.amount_received);\n      if (amountReceived < totalFee) {\n        this.showToast('Error', `Insufficient payment. Required: ${this.formatCurrency(totalFee)}`, 'error');\n        return;\n      }\n      this.paymentVerificationForm.loading = true;\n      this.paymentVerificationForm.error = '';\n      try {\n        const paymentData = {\n          amount_received: amountReceived,\n          payment_method_id: this.currentRequest.payment_method_id || 1,\n          // Default to cash\n          receipt_number: this.paymentVerificationForm.receipt_number\n        };\n        const response = await adminDocumentService.verifyInPersonPayment(this.currentRequest.id, paymentData);\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n\n          // Reset form\n          this.paymentVerificationForm = {\n            amount_received: '',\n            receipt_number: '',\n            loading: false,\n            error: ''\n          };\n          this.showToast('Success', 'Payment verified successfully', 'success');\n        }\n      } catch (error) {\n        console.error('Failed to verify payment:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.paymentVerificationForm.error = errorData.message || 'Failed to verify payment';\n        this.showToast('Error', errorData.message || 'Failed to verify payment', 'error');\n      } finally {\n        this.paymentVerificationForm.loading = false;\n      }\n    },\n    // Schedule pickup appointment\n    async schedulePickup() {\n      if (!this.isPickupFormValid() || !this.currentRequest) {\n        this.showToast('Error', 'Please fill in all required fields', 'error');\n        return;\n      }\n      this.pickupScheduleForm.loading = true;\n      this.pickupScheduleForm.error = '';\n      try {\n        const scheduleData = {\n          scheduled_date: this.pickupScheduleForm.scheduled_date,\n          scheduled_time_start: this.pickupScheduleForm.scheduled_time_start,\n          scheduled_time_end: this.pickupScheduleForm.scheduled_time_end\n        };\n        const response = await adminDocumentService.schedulePickup(this.currentRequest.id, scheduleData);\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n\n          // Reset form\n          this.pickupScheduleForm = {\n            scheduled_date: '',\n            scheduled_time_start: '',\n            scheduled_time_end: '',\n            loading: false,\n            error: ''\n          };\n          this.showToast('Success', 'Pickup scheduled successfully', 'success');\n        }\n      } catch (error) {\n        console.error('Failed to schedule pickup:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.pickupScheduleForm.error = errorData.message || 'Failed to schedule pickup';\n        this.showToast('Error', errorData.message || 'Failed to schedule pickup', 'error');\n      } finally {\n        this.pickupScheduleForm.loading = false;\n      }\n    },\n    // Utility methods\n    formatStatus(status) {\n      return adminDocumentService.formatStatus(status);\n    },\n    getStatusColor(status) {\n      return adminDocumentService.getStatusColor(status);\n    },\n    // Enhanced fee display method with debugging\n    getDisplayFee(request) {\n      const totalDocumentFee = parseFloat(request.total_document_fee);\n      const totalFee = parseFloat(request.total_fee);\n\n      // Debug logging for Cedula requests\n      if (request.document_type === 'Cedula') {\n        console.log(`🔍 Cedula Fee Debug - Request ${request.request_number}:`, {\n          total_document_fee: request.total_document_fee,\n          total_fee: request.total_fee,\n          parsed_total_document_fee: totalDocumentFee,\n          parsed_total_fee: totalFee,\n          will_display: totalDocumentFee || totalFee || 0\n        });\n      }\n\n      // Prioritize total_document_fee, fallback to total_fee\n      return totalDocumentFee || totalFee || 0;\n    },\n    // Check if request has convenience fee\n    hasConvenienceFee(request) {\n      const baseFee = this.getBaseFee(request);\n      const totalFee = this.getDisplayFee(request);\n      return totalFee > baseFee && baseFee > 0;\n    },\n    // Get base document fee (without convenience fee)\n    getBaseFee(request) {\n      const documentType = request.document_type;\n      const totalFee = this.getDisplayFee(request);\n\n      // For Cedula requests, calculate the actual document fee\n      if (documentType === 'Cedula') {\n        // If total is ₱100.00, the base fee is likely ₱30.00 (with ₱70.00 convenience fee)\n        if (totalFee === 100.00) {\n          return 30.00; // Standard Cedula fee for ₱20K income\n        }\n        // For other amounts, assume no convenience fee for now\n        return totalFee;\n      }\n\n      // For other document types, check if convenience fee was applied\n      const PAYMONGO_MINIMUM = 100.00;\n      if (totalFee === PAYMONGO_MINIMUM && documentType !== 'Barangay Clearance') {\n        // Likely has convenience fee - estimate base fee\n        return totalFee - (PAYMONGO_MINIMUM - totalFee);\n      }\n      return totalFee;\n    },\n    // Get convenience fee amount\n    getConvenienceFee(request) {\n      const baseFee = this.getBaseFee(request);\n      const totalFee = this.getDisplayFee(request);\n      return Math.max(0, totalFee - baseFee);\n    },\n    // Get convenience fee explanation\n    getConvenienceFeeExplanation(request) {\n      const convenienceFee = this.getConvenienceFee(request);\n      if (convenienceFee > 0) {\n        return `PayMongo requires a minimum payment of ₱100.00. A convenience fee of ₱${convenienceFee.toFixed(2)} was added to meet this requirement.`;\n      }\n      return '';\n    },\n    formatDate(dateString) {\n      console.log('🗓️ formatDate called with:', dateString);\n      if (!dateString) {\n        console.log('🗓️ formatDate: No date provided, returning null');\n        return null;\n      }\n      const date = new Date(dateString);\n      const formatted = date.toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n      console.log('🗓️ formatDate result:', formatted);\n      return formatted;\n    },\n    formatCurrency(amount) {\n      return new Intl.NumberFormat('en-PH', {\n        style: 'currency',\n        currency: 'PHP'\n      }).format(amount || 0);\n    },\n    formatDateTime(dateString) {\n      if (!dateString) return 'N/A';\n      return new Date(dateString).toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n    },\n    // Get formatted changed by name for status history\n    getChangedByName(history) {\n      // If the reason starts with \"SYSTEM:\", show \"System\" regardless of changed_by_name\n      if (history.change_reason && history.change_reason.startsWith('SYSTEM:')) {\n        return 'System';\n      }\n      return history.changed_by_name || 'System';\n    },\n    // Get formatted reason for status history\n    getFormattedReason(reason) {\n      if (!reason) return '';\n      // Remove \"SYSTEM:\" prefix if present\n      if (reason.startsWith('SYSTEM:')) {\n        return reason.substring(7).trim(); // Remove \"SYSTEM:\" and trim whitespace\n      }\n      return reason;\n    },\n    // New helper methods for complete client information\n    getClientFullName(request) {\n      if (!request) return 'Not provided';\n      const parts = [request.client_first_name, request.client_middle_name, request.client_last_name, request.client_suffix].filter(Boolean);\n      return parts.length > 0 ? parts.join(' ') : request.client_name || 'Not provided';\n    },\n    getClientFullAddress(request) {\n      if (!request) return null;\n      const parts = [request.client_house_number, request.client_street, request.client_subdivision, request.client_barangay, request.client_city_municipality || request.client_city, request.client_province].filter(Boolean);\n      return parts.length > 0 ? parts.join(', ') : request.client_address || null;\n    },\n    formatGender(gender) {\n      if (!gender) {\n        return null;\n      }\n      return gender.charAt(0).toUpperCase() + gender.slice(1);\n    },\n    getCivilStatusName(statusId) {\n      const statuses = {\n        1: 'Single',\n        2: 'Married',\n        3: 'Divorced',\n        4: 'Widowed',\n        5: 'Separated'\n      };\n      return statuses[statusId] || null;\n    },\n    // New helper methods for third-party requests\n    formatRelationship(relationship) {\n      if (!relationship) return 'Not specified';\n      const relationships = {\n        'spouse': 'Spouse',\n        'child': 'Child',\n        'parent': 'Parent',\n        'sibling': 'Sibling',\n        'relative': 'Other Relative',\n        'friend': 'Friend',\n        'colleague': 'Colleague',\n        // 'other': 'Other',\n        'self': 'Self'\n      };\n      return relationships[relationship] || relationship.charAt(0).toUpperCase() + relationship.slice(1);\n    },\n    formatAuthorizationStatus(status) {\n      if (!status) return 'Pending';\n      const statuses = {\n        'pending': 'Pending Verification',\n        'verified': 'Verified',\n        'rejected': 'Rejected'\n      };\n      return statuses[status] || status.charAt(0).toUpperCase() + status.slice(1);\n    },\n    getAuthorizationStatusClass(status) {\n      const classes = {\n        'pending': 'bg-warning text-dark',\n        'verified': 'bg-success',\n        'rejected': 'bg-danger'\n      };\n      return classes[status] || 'bg-secondary';\n    },\n    getAuthorizationStatusIcon(status) {\n      const icons = {\n        'pending': 'fa-clock',\n        'verified': 'fa-check-circle',\n        'rejected': 'fa-times-circle'\n      };\n      return icons[status] || 'fa-question-circle';\n    },\n    // Authorization verification methods\n    async verifyAuthorization(requestId, isApproved) {\n      try {\n        // This would call a new API endpoint for authorization verification\n        // const response = await adminDocumentService.verifyAuthorization(requestId, {\n        //   isApproved,\n        //   notes: isApproved ? 'Authorization verified and approved' : 'Authorization rejected'\n        // });\n\n        // For now, show a placeholder message\n        this.showToast('Authorization ' + (isApproved ? 'Approved' : 'Rejected'), `Pickup authorization has been ${isApproved ? 'approved' : 'rejected'}`, isApproved ? 'success' : 'warning');\n\n        // Refresh the request details\n        await this.refreshRequestDetails();\n      } catch (error) {\n        console.error('Failed to verify authorization:', error);\n        this.errorMessage = 'Failed to verify authorization. Please try again.';\n      }\n    },\n    getResidencyDisplay(request) {\n      if (!request) return null;\n      const years = request.client_years_of_residency;\n      const months = request.client_months_of_residency;\n      if (!years && !months) return null; // Return null so the template can handle \"Not provided\"\n\n      const parts = [];\n      if (years) parts.push(`${years} year${years > 1 ? 's' : ''}`);\n      if (months) parts.push(`${months} month${months > 1 ? 's' : ''}`);\n      return parts.join(' and ');\n    },\n    formatTime(dateString) {\n      if (!dateString) return '';\n      const date = new Date(dateString);\n      return date.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: true\n      });\n    },\n    // Real-time features\n    async initializeRealTimeFeatures() {\n      console.log('Initializing real-time features for AdminRequests');\n      try {\n        // Initialize notification service\n        await notificationService.init('admin');\n\n        // Listen for request-related notifications\n        notificationService.on('notification', this.handleRealTimeNotification);\n        notificationService.on('request_status_changed', this.handleStatusChange);\n        notificationService.on('new_request', this.handleNewRequest);\n\n        // Start auto-refresh if enabled\n        if (this.autoRefreshEnabled) {\n          this.startAutoRefresh();\n        }\n      } catch (error) {\n        console.error('Failed to initialize real-time features:', error);\n      }\n    },\n    cleanupRealTimeFeatures() {\n      console.log('Cleaning up real-time features for AdminRequests');\n\n      // Remove notification listeners\n      notificationService.off('notification', this.handleRealTimeNotification);\n      notificationService.off('request_status_changed', this.handleStatusChange);\n      notificationService.off('new_request', this.handleNewRequest);\n\n      // Cleanup (simplified)\n      notificationService.cleanup();\n\n      // Stop auto-refresh\n      this.stopAutoRefresh();\n    },\n    startAutoRefresh() {\n      if (this.refreshInterval) {\n        clearInterval(this.refreshInterval);\n      }\n      this.refreshInterval = setInterval(() => {\n        if (this.autoRefreshEnabled && !this.loading) {\n          console.log('Auto-refreshing requests data...');\n          this.refreshRequestsData();\n        }\n      }, this.refreshRate);\n      console.log(`Auto-refresh started with ${this.refreshRate / 1000}s interval`);\n    },\n    stopAutoRefresh() {\n      if (this.refreshInterval) {\n        clearInterval(this.refreshInterval);\n        this.refreshInterval = null;\n        console.log('Auto-refresh stopped');\n      }\n    },\n    toggleAutoRefresh() {\n      this.autoRefreshEnabled = !this.autoRefreshEnabled;\n      if (this.autoRefreshEnabled) {\n        this.startAutoRefresh();\n      } else {\n        this.stopAutoRefresh();\n      }\n    },\n    async refreshRequestsData() {\n      try {\n        this.lastRefresh = new Date();\n\n        // Refresh requests list\n        await this.loadRequests();\n\n        // Refresh statistics\n        await this.loadDashboardStats();\n\n        // If request details modal is open, refresh it\n        if (this.showRequestDetails && this.currentRequest) {\n          await this.refreshRequestDetails();\n        }\n        console.log('Requests data refreshed successfully');\n      } catch (error) {\n        console.error('Failed to refresh requests data:', error);\n      }\n    },\n    handleRealTimeNotification(notification) {\n      console.log('Real-time notification received:', notification);\n\n      // Handle different notification types\n      switch (notification.type) {\n        case 'request_status_changed':\n          this.handleStatusChange(notification.data);\n          break;\n        case 'new_request':\n          this.handleNewRequest(notification.data);\n          break;\n        case 'request_updated':\n          this.handleRequestUpdate(notification.data);\n          break;\n        case 'unread_count_update':\n        case 'heartbeat':\n          // Polling system notifications - handled by notification service\n          break;\n        default:\n          // Only log unknown types, not system types\n          if (!['unread_count_update', 'heartbeat'].includes(notification.type)) {\n            console.log('Unhandled notification type:', notification.type);\n          }\n      }\n    },\n    handleStatusChange(data) {\n      console.log('🔄 Request status changed:', data);\n      console.log('🔍 Data properties:', {\n        request_id: data.request_id,\n        new_status: data.new_status,\n        payment_status: data.payment_status,\n        amount: data.amount\n      });\n\n      // Update the request in the list if it exists\n      const requestId = data.request_id;\n      if (!requestId) {\n        console.warn('⚠️ No request_id in status change data');\n        return;\n      }\n      const requestIndex = this.requests.findIndex(req => req.id == requestId);\n      if (requestIndex !== -1) {\n        console.log(`📝 Updating request #${data.request_id} in the list`);\n\n        // Update the specific request in the list for immediate UI update\n        const updatedRequest = {\n          ...this.requests[requestIndex]\n        };\n\n        // Map the status based on the new status\n        if (data.new_status === 'payment_confirmed') {\n          updatedRequest.status_name = 'Payment Confirmed';\n          updatedRequest.status_id = 11;\n          updatedRequest.payment_status = 'paid';\n        } else if (data.new_status === 'payment_failed') {\n          updatedRequest.status_name = 'Payment Failed';\n          updatedRequest.payment_status = 'failed';\n        }\n\n        // Update the timestamp\n        updatedRequest.updated_at = data.timestamp || new Date().toISOString();\n\n        // Replace the request in the array\n        this.$set(this.requests, requestIndex, updatedRequest);\n\n        // Also refresh data in background to ensure consistency\n        setTimeout(() => {\n          this.refreshRequestsData();\n        }, 1000);\n        console.log(`✅ Request #${data.request_id} updated in real-time`);\n      } else {\n        console.log(`📄 Request #${data.request_id} not in current view, refreshing data`);\n        // If request is not in current view, just refresh\n        this.refreshRequestsData();\n      }\n\n      // Show toast notification with payment-specific message\n      const toastRequestId = data.request_id || 'Unknown';\n      const newStatus = data.new_status || 'unknown';\n      let title = 'Status Update';\n      let message = `Request #${toastRequestId} status changed`;\n      let type = 'info';\n      if (newStatus === 'payment_confirmed') {\n        title = 'Payment Confirmed';\n        message = `Payment confirmed for request #${toastRequestId}`;\n        type = 'success';\n      } else if (newStatus === 'payment_failed') {\n        title = 'Payment Failed';\n        message = `Payment failed for request #${toastRequestId}`;\n        type = 'error';\n      }\n      console.log('🔔 Showing toast:', {\n        title,\n        message,\n        type\n      });\n      this.showToast(title, message, type);\n    },\n    handleNewRequest(data) {\n      console.log('New request received:', data);\n\n      // Refresh requests to show the new request\n      this.refreshRequestsData();\n\n      // Show toast notification\n      this.showToast('New Request', `New ${data.document_type} request received`, 'success');\n    },\n    handleRequestUpdate(data) {\n      console.log('Request updated:', data);\n\n      // If the updated request is currently being viewed, refresh details\n      if (this.currentRequest && this.currentRequest.id === data.request_id) {\n        this.refreshRequestDetails();\n      }\n\n      // Refresh the requests list\n      this.refreshRequestsData();\n    },\n    showToast(title, message, type = 'info') {\n      // Enhanced debugging\n      console.log('🔔 showToast called with:', {\n        title: title,\n        titleType: typeof title,\n        message: message,\n        messageType: typeof message,\n        type: type\n      });\n\n      // Handle undefined values\n      const safeTitle = title || 'Notification';\n      const safeMessage = message || 'No message provided';\n\n      // Log to console for debugging\n      console.log(`[${type.toUpperCase()}] ${safeTitle}: ${safeMessage}`);\n\n      // Create a simple toast notification\n      const toast = document.createElement('div');\n      toast.className = `toast-notification toast-${type}`;\n      toast.innerHTML = `\n        <div class=\"toast-header\">\n          <strong>${safeTitle}</strong>\n          <button type=\"button\" class=\"toast-close\" onclick=\"this.parentElement.parentElement.remove()\">×</button>\n        </div>\n        <div class=\"toast-body\">${safeMessage}</div>\n      `;\n\n      // Add toast styles if not already added\n      if (!document.getElementById('toast-styles')) {\n        const styles = document.createElement('style');\n        styles.id = 'toast-styles';\n        styles.textContent = `\n          .toast-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 9999;\n            animation: slideIn 0.3s ease;\n          }\n          .toast-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 16px 8px;\n            border-bottom: 1px solid #e9ecef;\n          }\n          .toast-body {\n            padding: 8px 16px 12px;\n            color: #6c757d;\n          }\n          .toast-close {\n            background: none;\n            border: none;\n            font-size: 18px;\n            cursor: pointer;\n            color: #6c757d;\n          }\n          .toast-success { border-left: 4px solid #28a745; }\n          .toast-error { border-left: 4px solid #dc3545; }\n          .toast-info { border-left: 4px solid #17a2b8; }\n          .toast-warning { border-left: 4px solid #ffc107; }\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        `;\n        document.head.appendChild(styles);\n      }\n\n      // Add toast to page\n      document.body.appendChild(toast);\n\n      // Auto-remove after 5 seconds\n      setTimeout(() => {\n        if (toast.parentElement) {\n          toast.style.animation = 'slideIn 0.3s ease reverse';\n          setTimeout(() => toast.remove(), 300);\n        }\n      }, 5000);\n    },\n    // Document handling methods\n    getDocumentTypeDisplayName(type) {\n      const displayNames = {\n        'government_id': 'Government ID',\n        'proof_of_residency': 'Proof of Residency',\n        'cedula': 'Community Tax Certificate (Cedula)',\n        'birth_certificate': 'Birth Certificate',\n        'marriage_certificate': 'Marriage Certificate',\n        'other': 'Other Document'\n      };\n      return displayNames[type] || type;\n    },\n    isImageFile(mimeType) {\n      return mimeType && (mimeType.startsWith('image/') || ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'].includes(mimeType));\n    },\n    isPdfFile(mimeType) {\n      return mimeType === 'application/pdf';\n    },\n    async loadDocumentUrls(documents) {\n      // Filter documents that need loading (images only, not already loaded/loading/failed)\n      const documentsToLoad = documents.filter(doc => this.isImageFile(doc.mime_type) && !this.documentUrls[doc.id] && !this.loadingDocuments.has(doc.id) && !this.failedDocuments.has(doc.id));\n      if (documentsToLoad.length === 0) return;\n\n      // Load documents in parallel with concurrency limit\n      const CONCURRENT_LIMIT = 3;\n      const chunks = this.chunkArray(documentsToLoad, CONCURRENT_LIMIT);\n      for (const chunk of chunks) {\n        await Promise.allSettled(chunk.map(document => this.loadSingleDocument(document)));\n      }\n    },\n    async loadSingleDocument(document, isForModal = false) {\n      const docId = document.id;\n      try {\n        // Mark as loading\n        this.loadingDocuments.add(docId);\n        if (isForModal) this.imageLoadingInModal = true;\n\n        // Use authenticated API call to get the document\n        const response = await api.get(`/documents/view/${docId}`, {\n          responseType: 'blob',\n          timeout: 15000,\n          // Increased timeout for large images\n          onDownloadProgress: progressEvent => {\n            // Optional: Could emit progress events here\n            if (progressEvent.lengthComputable) {\n              const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n              console.log(`Loading ${docId}: ${percentCompleted}%`);\n            }\n          }\n        });\n\n        // Validate response\n        if (!response.data || response.data.size === 0) {\n          throw new Error('Empty response received');\n        }\n\n        // Check file size and optimize if needed\n        const blob = response.data;\n        const optimizedBlob = await this.optimizeImageBlob(blob, document.mime_type, isForModal);\n\n        // Create blob URL using requestIdleCallback for better performance\n        await this.createBlobUrlWhenIdle(docId, optimizedBlob);\n\n        // Remove from failed set if it was there\n        this.failedDocuments.delete(docId);\n        if (isForModal) this.modalImageError = false;\n      } catch (error) {\n        console.warn(`Failed to load document ${docId}:`, error.message);\n        this.failedDocuments.add(docId);\n        if (isForModal) this.modalImageError = true;\n\n        // Optionally retry after a delay for network errors\n        if (error.code === 'NETWORK_ERROR' || error.code === 'ECONNABORTED') {\n          setTimeout(() => {\n            this.failedDocuments.delete(docId);\n          }, 30000); // Retry after 30 seconds\n        }\n      } finally {\n        // Remove from loading set\n        this.loadingDocuments.delete(docId);\n        if (isForModal) this.imageLoadingInModal = false;\n      }\n    },\n    chunkArray(array, size) {\n      const chunks = [];\n      for (let i = 0; i < array.length; i += size) {\n        chunks.push(array.slice(i, i + size));\n      }\n      return chunks;\n    },\n    async getDocumentUrl(document) {\n      // This method is now deprecated in favor of loadDocumentUrls\n      // Keeping for backward compatibility\n      if (this.documentUrls[document.id]) {\n        return this.documentUrls[document.id];\n      }\n      return null;\n    },\n    formatFileSize(bytes) {\n      if (!bytes) return '0 B';\n      const k = 1024;\n      const sizes = ['B', 'KB', 'MB', 'GB'];\n      const i = Math.floor(Math.log(bytes) / Math.log(k));\n      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    },\n    async openImageModal(document) {\n      // Prevent multiple rapid clicks\n      if (this.imageLoadingInModal) return;\n\n      // Don't open modal if document failed to load and we're not retrying\n      if (this.failedDocuments.has(document.id)) {\n        return;\n      }\n\n      // Set modal state immediately for responsiveness\n      this.selectedImage = document;\n      this.showImageModal = true;\n      this.modalImageError = false;\n\n      // Use nextTick to ensure DOM is updated before heavy operations\n      await this.$nextTick();\n\n      // If image isn't loaded yet, try to load it with modal optimization\n      if (!this.documentUrls[document.id] && !this.loadingDocuments.has(document.id)) {\n        await this.loadSingleDocument(document, true);\n      }\n    },\n    async retryLoadDocument(document) {\n      // Remove from failed set and retry loading\n      this.failedDocuments.delete(document.id);\n      this.modalImageError = false;\n      await this.loadSingleDocument(document, true);\n    },\n    onModalImageLoad() {\n      // Called when modal image finishes loading\n      this.imageLoadingInModal = false;\n    },\n    cleanupDocumentUrls() {\n      // Revoke all blob URLs to prevent memory leaks\n      Object.values(this.documentUrls).forEach(url => {\n        if (url) URL.revokeObjectURL(url);\n      });\n\n      // Clear all tracking sets and objects\n      this.documentUrls = {};\n      this.loadingDocuments.clear();\n      this.failedDocuments.clear();\n    },\n    preloadImage(document) {\n      // Preload image on hover for better UX\n      if (!this.documentUrls[document.id] && !this.loadingDocuments.has(document.id) && !this.failedDocuments.has(document.id)) {\n        this.loadSingleDocument(document, false);\n      }\n    },\n    async optimizeImageBlob(blob, mimeType, isForModal = false) {\n      // For very large images, we might want to resize them\n      const MAX_SIZE = isForModal ? 5 * 1024 * 1024 : 2 * 1024 * 1024; // 5MB for modal, 2MB for preview\n\n      if (blob.size <= MAX_SIZE) {\n        return blob; // No optimization needed\n      }\n      try {\n        // Create image element for resizing\n        const img = new Image();\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        return new Promise(resolve => {\n          img.onload = () => {\n            // Calculate new dimensions (maintain aspect ratio)\n            const maxDimension = isForModal ? 1920 : 800;\n            let {\n              width,\n              height\n            } = img;\n            if (width > height && width > maxDimension) {\n              height = height * maxDimension / width;\n              width = maxDimension;\n            } else if (height > maxDimension) {\n              width = width * maxDimension / height;\n              height = maxDimension;\n            }\n\n            // Set canvas size and draw resized image\n            canvas.width = width;\n            canvas.height = height;\n            ctx.drawImage(img, 0, 0, width, height);\n\n            // Convert to blob with compression\n            canvas.toBlob(optimizedBlob => {\n              resolve(optimizedBlob || blob); // Fallback to original if optimization fails\n            }, mimeType, 0.85 // 85% quality\n            );\n          };\n          img.onerror = () => resolve(blob); // Fallback to original\n          img.src = URL.createObjectURL(blob);\n        });\n      } catch (error) {\n        console.warn('Image optimization failed:', error);\n        return blob; // Fallback to original\n      }\n    },\n    async createBlobUrlWhenIdle(docId, blob) {\n      return new Promise(resolve => {\n        const createUrl = () => {\n          this.documentUrls[docId] = URL.createObjectURL(blob);\n          resolve();\n        };\n\n        // Use requestIdleCallback if available, otherwise use setTimeout\n        if (window.requestIdleCallback) {\n          window.requestIdleCallback(createUrl, {\n            timeout: 1000\n          });\n        } else {\n          setTimeout(createUrl, 0);\n        }\n      });\n    },\n    closeImageModal() {\n      // Prevent rapid clicking during image loading\n      if (this.imageLoadingInModal) return;\n      this.showImageModal = false;\n      this.selectedImage = null;\n      this.imageLoadingInModal = false;\n      this.modalImageError = false;\n    },\n    async downloadDocument(documentFile) {\n      try {\n        // Use authenticated API call to download the document\n        const response = await api.get(`/documents/download/${documentFile.id}`, {\n          responseType: 'blob'\n        });\n\n        // Create a download link\n        const blob = new Blob([response.data], {\n          type: documentFile.mime_type\n        });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = documentFile.document_name;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      } catch (error) {\n        console.error('Failed to download document:', error);\n        this.showToast('Error', 'Failed to download document', 'error');\n      }\n    },\n    handleImageError(event) {\n      console.error('Failed to load image:', event.target.src);\n      // You could set a placeholder image here\n      event.target.style.display = 'none';\n\n      // Show error message\n      const errorDiv = document.createElement('div');\n      errorDiv.className = 'text-center text-muted p-3';\n      errorDiv.innerHTML = '<i class=\"fas fa-exclamation-triangle\"></i><br>Failed to load image';\n      event.target.parentNode.appendChild(errorDiv);\n    },\n    // Beneficiary verification status methods\n    getBeneficiaryVerificationStatusClass(status) {\n      switch (status) {\n        case 'approved':\n          return 'bg-success';\n        case 'rejected':\n          return 'bg-danger';\n        case 'pending':\n        default:\n          return 'bg-warning';\n      }\n    },\n    getBeneficiaryVerificationStatusText(status) {\n      switch (status) {\n        case 'approved':\n          return 'Verified';\n        case 'rejected':\n          return 'Rejected';\n        case 'pending':\n        default:\n          return 'Pending';\n      }\n    },\n    // View verification image\n    async viewVerificationImage(requestId, imageType) {\n      try {\n        // Find the request to get the filename - check both requests list and currentRequest\n        let request = this.requests.find(r => r.id === requestId);\n\n        // If not found in requests list, check if it's the current request being viewed\n        if (!request && this.currentRequest && this.currentRequest.id === requestId) {\n          request = this.currentRequest;\n        }\n        if (!request) {\n          this.showToast('Error', 'Request not found', 'error');\n          return;\n        }\n        let filename = '';\n        let documentType = '';\n        switch (imageType) {\n          case 'beneficiary':\n            // Handle both list view (beneficiary_verification_image) and detail view (beneficiary.verification_image_path)\n            filename = request.beneficiary_verification_image || request.beneficiary?.verification_image_path;\n            documentType = 'beneficiary';\n            // For beneficiary documents, we need the beneficiary ID, not the request ID\n            if (request.beneficiary?.id) {\n              requestId = request.beneficiary.id;\n            }\n            break;\n          case 'pickup-id':\n            filename = request.pickup_id_image || request.authorized_pickup?.id_image_path;\n            documentType = 'pickup-id';\n            break;\n          case 'pickup-auth':\n            filename = request.pickup_authorization_letter || request.authorized_pickup?.authorization_letter_path;\n            documentType = 'pickup-auth';\n            break;\n          default:\n            this.showToast('Error', 'Invalid image type', 'error');\n            return;\n        }\n        if (!filename) {\n          this.showToast('Error', 'No image available', 'error');\n          return;\n        }\n\n        // Extract just the filename from the path (handle both forward and back slashes)\n        const filenameOnly = filename.split(/[/\\\\]/).pop();\n\n        // Construct the URL for the verification document service\n        const imageUrl = `/verification-documents/serve/${documentType}/${requestId}/${filenameOnly}`;\n\n        // Fetch the image with authentication headers and display in modal\n        await this.displayImageInModal(imageUrl, `${documentType} verification image`);\n      } catch (error) {\n        console.error('Error viewing verification image:', error);\n        this.showToast('Error', 'Failed to view image', 'error');\n      }\n    },\n    // Display image in modal with authentication\n    async displayImageInModal(imageUrl, title) {\n      try {\n        // Import the API service\n        const api = (await import('@/services/api.js')).default;\n\n        // Fetch the image with authentication headers\n        const response = await api.get(imageUrl, {\n          responseType: 'blob'\n        });\n\n        // Create object URL from blob\n        const imageObjectUrl = URL.createObjectURL(response.data);\n\n        // Create and show modal\n        const modalHtml = `\n          <div class=\"modal fade\" id=\"imageViewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n            <div class=\"modal-dialog modal-lg modal-dialog-centered\">\n              <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                  <h5 class=\"modal-title\">${title}</h5>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body text-center\">\n                  <img src=\"${imageObjectUrl}\" class=\"img-fluid\" alt=\"${title}\" style=\"max-height: 70vh;\">\n                </div>\n                <div class=\"modal-footer\">\n                  <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        `;\n\n        // Remove existing modal if any\n        const existingModal = document.getElementById('imageViewModal');\n        if (existingModal) {\n          existingModal.remove();\n        }\n\n        // Add modal to DOM\n        document.body.insertAdjacentHTML('beforeend', modalHtml);\n\n        // Show modal\n        const modal = new Modal(document.getElementById('imageViewModal'));\n        modal.show();\n\n        // Clean up object URL when modal is hidden\n        document.getElementById('imageViewModal').addEventListener('hidden.bs.modal', () => {\n          URL.revokeObjectURL(imageObjectUrl);\n          document.getElementById('imageViewModal').remove();\n        });\n      } catch (error) {\n        console.error('Error displaying image:', error);\n        this.showToast('Error', 'Failed to load image', 'error');\n      }\n    },\n    // View pickup documents in modal\n    async viewPickupDocuments(request) {\n      try {\n        // Set the selected request and show the modal\n        this.selectedRequestForPickup = request;\n\n        // Show modal\n        const modal = new Modal(document.getElementById('authorizedPickupDocumentsModal'));\n        modal.show();\n      } catch (error) {\n        console.error('Error opening pickup documents modal:', error);\n        this.showToast('Error', 'Failed to open documents modal', 'error');\n      }\n    },\n    // Verify pickup authorization\n    async verifyPickupAuthorization() {\n      if (!this.selectedRequestForPickup) return;\n      this.processingPickupAction = true;\n      try {\n        // This would call a new API endpoint for pickup authorization verification\n        // const response = await adminDocumentService.verifyPickupAuthorization(this.selectedRequestForPickup.id);\n\n        this.showToast('Success', 'Pickup authorization verified successfully', 'success');\n\n        // Close modal\n        const modal = Modal.getInstance(document.getElementById('authorizedPickupDocumentsModal'));\n        if (modal) {\n          modal.hide();\n        }\n\n        // Refresh requests list\n        await this.loadRequests();\n      } catch (error) {\n        console.error('Error verifying pickup authorization:', error);\n        this.showToast('Error', 'Failed to verify pickup authorization', 'error');\n      } finally {\n        this.processingPickupAction = false;\n      }\n    },\n    // Reject pickup authorization\n    async rejectPickupAuthorization() {\n      if (!this.selectedRequestForPickup) return;\n      this.processingPickupAction = true;\n      try {\n        // This would call a new API endpoint for pickup authorization rejection\n        // const response = await adminDocumentService.rejectPickupAuthorization(this.selectedRequestForPickup.id);\n\n        this.showToast('Success', 'Pickup authorization rejected', 'success');\n\n        // Close modal\n        const modal = Modal.getInstance(document.getElementById('authorizedPickupDocumentsModal'));\n        if (modal) {\n          modal.hide();\n        }\n\n        // Refresh requests list\n        await this.loadRequests();\n      } catch (error) {\n        console.error('Error rejecting pickup authorization:', error);\n        this.showToast('Error', 'Failed to reject pickup authorization', 'error');\n      } finally {\n        this.processingPickupAction = false;\n      }\n    },\n    // Update beneficiary verification status\n    async updateBeneficiaryVerificationStatus(beneficiaryId, status, notes = '') {\n      try {\n        const response = await this.$http.put(`/api/verification-documents/beneficiary/${beneficiaryId}/verification-status`, {\n          status,\n          notes\n        });\n        if (response.data.success) {\n          this.showToast('Success', 'Verification status updated successfully', 'success');\n          // Refresh the requests to show updated status\n          await this.loadRequests();\n        } else {\n          throw new Error(response.data.message || 'Failed to update verification status');\n        }\n      } catch (error) {\n        console.error('Error updating verification status:', error);\n        this.showToast('Error', error.response?.data?.message || 'Failed to update verification status', 'error');\n      }\n    },\n    // Open verification modal\n    openVerificationModal(request) {\n      this.currentVerification = {\n        requestId: request.id,\n        beneficiaryId: request.beneficiary_id,\n        beneficiary_name: request.beneficiary_name,\n        relationship: request.beneficiary_relationship,\n        image_url: request.beneficiary_verification_image ? `/verification-documents/serve/beneficiary/${request.id}/${request.beneficiary_verification_image.split('/').pop()}` : null,\n        current_status: request.beneficiary_verification_status\n      };\n      this.verificationForm = {\n        status: request.beneficiary_verification_status || 'pending',\n        notes: ''\n      };\n\n      // Show the modal\n      const modal = new Modal(document.getElementById('verificationModal'));\n      modal.show();\n    },\n    // Save verification status from modal\n    async saveVerificationStatus() {\n      if (!this.currentVerification) return;\n      try {\n        await this.updateBeneficiaryVerificationStatus(this.currentVerification.beneficiaryId, this.verificationForm.status, this.verificationForm.notes);\n\n        // Close the modal\n        const modal = Modal.getInstance(document.getElementById('verificationModal'));\n        modal.hide();\n\n        // Reset form\n        this.currentVerification = null;\n        this.verificationForm = {\n          status: 'pending',\n          notes: ''\n        };\n      } catch (error) {\n        // Error handling is done in updateBeneficiaryVerificationStatus\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}