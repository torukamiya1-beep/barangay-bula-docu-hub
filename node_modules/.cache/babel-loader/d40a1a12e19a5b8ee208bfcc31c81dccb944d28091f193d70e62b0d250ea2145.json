{"ast":null,"code":"/**\n * Converts indexed data into RGB/RGBA format\n * @param decodedImage - Image to decode data from.\n * @returns Uint8Array with RGB data.\n */\nexport function convertIndexedToRgb(decodedImage) {\n  const palette = decodedImage.palette;\n  const depth = decodedImage.depth;\n  if (!palette) {\n    throw new Error('Color palette is undefined.');\n  }\n  checkDataSize(decodedImage);\n  const indexSize = decodedImage.width * decodedImage.height;\n  const resSize = indexSize * palette[0].length;\n  const res = new Uint8Array(resSize);\n  let indexPos = 0;\n  let offset = 0;\n  const indexes = new Uint8Array(indexSize);\n  let bit = 0xff;\n  switch (depth) {\n    case 1:\n      bit = 0x80;\n      break;\n    case 2:\n      bit = 0xc0;\n      break;\n    case 4:\n      bit = 0xf0;\n      break;\n    case 8:\n      bit = 0xff;\n      break;\n    default:\n      throw new Error('Incorrect depth value');\n  }\n  for (const byte of decodedImage.data) {\n    let bit2 = bit;\n    let shift = 8;\n    while (bit2) {\n      shift -= depth;\n      indexes[indexPos++] = (byte & bit2) >> shift;\n      bit2 = bit2 >> depth;\n      if (indexPos % decodedImage.width === 0) {\n        break;\n      }\n    }\n  }\n  if (decodedImage.palette) {\n    for (const index of indexes) {\n      const color = decodedImage.palette.at(index);\n      if (!color) {\n        throw new Error('Incorrect index of palette color');\n      }\n      res.set(color, offset);\n      offset += color.length;\n    }\n  }\n  return res;\n}\nfunction checkDataSize(image) {\n  const expectedSize = image.depth < 8 ? Math.ceil(image.width * image.depth / 8) * image.height * image.channels : image.width * image.height * image.channels;\n  if (image.data.length !== expectedSize) {\n    throw new RangeError(`wrong data size. Found ${image.data.length}, expected ${expectedSize}`);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}