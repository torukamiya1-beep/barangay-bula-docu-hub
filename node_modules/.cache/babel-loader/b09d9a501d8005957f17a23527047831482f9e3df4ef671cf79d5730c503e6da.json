{"ast":null,"code":"import _defineProperty from \"D:/brgy_docu_hub/BOSFDR/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\nimport { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PngEncoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super();\n    _defineProperty(this, \"_png\", void 0);\n    _defineProperty(this, \"_zlibOptions\", void 0);\n    _defineProperty(this, \"_colorType\", void 0);\n    _defineProperty(this, \"_interlaceMethod\", void 0);\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = {\n      ...defaultZlibOptions,\n      ...options.zlib\n    };\n    this._png = this._checkData(data);\n    this._interlaceMethod = (options.interlace === 'Adam7' ? InterlaceMethod.ADAM7 : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n  encode() {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n    writeCrc(this, 17);\n  }\n  // https://www.w3.org/TR/PNG/#11IEND\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    writeCrc(this, 4);\n  }\n  encodePLTE() {\n    const paletteLength = this._png.palette?.length * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n  encodeTRNS() {\n    const alpha = this._png.palette.filter(color => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1));\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    writeCrc(this, data.length + 4);\n  }\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = depth <= 8 ? Math.ceil(width * depth / 8) * channels : Math.ceil(width * depth / 8 * channels / 2);\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data, data.palette);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette\n    };\n    this._colorType = colorType;\n    const expectedSize = depth < 8 ? Math.ceil(png.width * depth / 8) * png.height * channels : png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n    }\n    return png;\n  }\n}\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n  const passes = [{\n    x: 0,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 4,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 0,\n    y: 4,\n    xStep: 4,\n    yStep: 8\n  }, {\n    x: 2,\n    y: 0,\n    xStep: 4,\n    yStep: 4\n  }, {\n    x: 0,\n    y: 2,\n    xStep: 2,\n    yStep: 4\n  }, {\n    x: 1,\n    y: 0,\n    xStep: 2,\n    yStep: 2\n  }, {\n    x: 0,\n    y: 1,\n    xStep: 1,\n    yStep: 2\n  }];\n  const {\n    width,\n    height,\n    channels,\n    depth\n  } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = channels * depth / 8 / 2;\n  } else {\n    pixelSize = channels * depth / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n    const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline = depth <= 8 ? new Uint8Array(passLineBytes) : new Uint16Array(passLineBytes);\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte(value >> 8 & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}