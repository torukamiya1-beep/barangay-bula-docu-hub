{"ast":null,"code":"import _defineProperty from \"D:/brgy_docu_hub/BOSFDR/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { decode, encode } from './text';\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n  int8: globalThis.Int8Array,\n  uint8: globalThis.Uint8Array,\n  int16: globalThis.Int16Array,\n  uint16: globalThis.Uint16Array,\n  int32: globalThis.Int32Array,\n  uint32: globalThis.Uint32Array,\n  uint64: globalThis.BigUint64Array,\n  int64: globalThis.BigInt64Array,\n  float32: globalThis.Float32Array,\n  float64: globalThis.Float64Array\n};\nexport class IOBuffer {\n  /**\n   * Create a new IOBuffer.\n   * @param data - The data to construct the IOBuffer with.\n   * If data is a number, it will be the new buffer's length<br>\n   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n   * @param options - An object for the options.\n   * @returns A new IOBuffer instance.\n   */\n  constructor(data = defaultByteLength, options = {}) {\n    /**\n     * Reference to the internal ArrayBuffer object.\n     */\n    _defineProperty(this, \"buffer\", void 0);\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    _defineProperty(this, \"byteLength\", void 0);\n    /**\n     * Byte offset of the internal ArrayBuffer.\n     */\n    _defineProperty(this, \"byteOffset\", void 0);\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    _defineProperty(this, \"length\", void 0);\n    /**\n     * The current offset of the buffer's pointer.\n     */\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"lastWrittenByte\", void 0);\n    _defineProperty(this, \"littleEndian\", void 0);\n    _defineProperty(this, \"_data\", void 0);\n    _defineProperty(this, \"_mark\", void 0);\n    _defineProperty(this, \"_marks\", void 0);\n    let dataIsGiven = false;\n    if (typeof data === 'number') {\n      data = new ArrayBuffer(data);\n    } else {\n      dataIsGiven = true;\n      this.lastWrittenByte = data.byteLength;\n    }\n    const offset = options.offset ? options.offset >>> 0 : 0;\n    const byteLength = data.byteLength - offset;\n    let dvOffset = offset;\n    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n      if (data.byteLength !== data.buffer.byteLength) {\n        dvOffset = data.byteOffset + offset;\n      }\n      data = data.buffer;\n    }\n    if (dataIsGiven) {\n      this.lastWrittenByte = byteLength;\n    } else {\n      this.lastWrittenByte = 0;\n    }\n    this.buffer = data;\n    this.length = byteLength;\n    this.byteLength = byteLength;\n    this.byteOffset = dvOffset;\n    this.offset = 0;\n    this.littleEndian = true;\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\n    this._mark = 0;\n    this._marks = [];\n  }\n  /**\n   * Checks if the memory allocated to the buffer is sufficient to store more\n   * bytes after the offset.\n   * @param byteLength - The needed memory in bytes.\n   * @returns `true` if there is sufficient space and `false` otherwise.\n   */\n  available(byteLength = 1) {\n    return this.offset + byteLength <= this.length;\n  }\n  /**\n   * Check if little-endian mode is used for reading and writing multi-byte\n   * values.\n   * @returns `true` if little-endian mode is used, `false` otherwise.\n   */\n  isLittleEndian() {\n    return this.littleEndian;\n  }\n  /**\n   * Set little-endian mode for reading and writing multi-byte values.\n   * @returns This.\n   */\n  setLittleEndian() {\n    this.littleEndian = true;\n    return this;\n  }\n  /**\n   * Check if big-endian mode is used for reading and writing multi-byte values.\n   * @returns `true` if big-endian mode is used, `false` otherwise.\n   */\n  isBigEndian() {\n    return !this.littleEndian;\n  }\n  /**\n   * Switches to big-endian mode for reading and writing multi-byte values.\n   * @returns This.\n   */\n  setBigEndian() {\n    this.littleEndian = false;\n    return this;\n  }\n  /**\n   * Move the pointer n bytes forward.\n   * @param n - Number of bytes to skip.\n   * @returns This.\n   */\n  skip(n = 1) {\n    this.offset += n;\n    return this;\n  }\n  /**\n   * Move the pointer n bytes backward.\n   * @param n - Number of bytes to move back.\n   * @returns This.\n   */\n  back(n = 1) {\n    this.offset -= n;\n    return this;\n  }\n  /**\n   * Move the pointer to the given offset.\n   * @param offset - The offset to move to.\n   * @returns This.\n   */\n  seek(offset) {\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Store the current pointer offset.\n   * @see {@link IOBuffer#reset}\n   * @returns This.\n   */\n  mark() {\n    this._mark = this.offset;\n    return this;\n  }\n  /**\n   * Move the pointer back to the last pointer offset set by mark.\n   * @see {@link IOBuffer#mark}\n   * @returns This.\n   */\n  reset() {\n    this.offset = this._mark;\n    return this;\n  }\n  /**\n   * Push the current pointer offset to the mark stack.\n   * @see {@link IOBuffer#popMark}\n   * @returns This.\n   */\n  pushMark() {\n    this._marks.push(this.offset);\n    return this;\n  }\n  /**\n   * Pop the last pointer offset from the mark stack, and set the current\n   * pointer offset to the popped value.\n   * @see {@link IOBuffer#pushMark}\n   * @returns This.\n   */\n  popMark() {\n    const offset = this._marks.pop();\n    if (offset === undefined) {\n      throw new Error('Mark stack empty');\n    }\n    this.seek(offset);\n    return this;\n  }\n  /**\n   * Move the pointer offset back to 0.\n   * @returns This.\n   */\n  rewind() {\n    this.offset = 0;\n    return this;\n  }\n  /**\n   * Make sure the buffer has sufficient memory to write a given byteLength at\n   * the current pointer offset.\n   * If the buffer's memory is insufficient, this method will create a new\n   * buffer (a copy) with a length that is twice (byteLength + current offset).\n   * @param byteLength - The needed memory in bytes.\n   * @returns This.\n   */\n  ensureAvailable(byteLength = 1) {\n    if (!this.available(byteLength)) {\n      const lengthNeeded = this.offset + byteLength;\n      const newLength = lengthNeeded * 2;\n      const newArray = new Uint8Array(newLength);\n      newArray.set(new Uint8Array(this.buffer));\n      this.buffer = newArray.buffer;\n      this.length = newLength;\n      this.byteLength = newLength;\n      this._data = new DataView(this.buffer);\n    }\n    return this;\n  }\n  /**\n   * Read a byte and return false if the byte's value is 0, or true otherwise.\n   * Moves pointer forward by one byte.\n   * @returns The read boolean.\n   */\n  readBoolean() {\n    return this.readUint8() !== 0;\n  }\n  /**\n   * Read a signed 8-bit integer and move pointer forward by 1 byte.\n   * @returns The read byte.\n   */\n  readInt8() {\n    return this._data.getInt8(this.offset++);\n  }\n  /**\n   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n   * @returns The read byte.\n   */\n  readUint8() {\n    return this._data.getUint8(this.offset++);\n  }\n  /**\n   * Alias for {@link IOBuffer#readUint8}.\n   * @returns The read byte.\n   */\n  readByte() {\n    return this.readUint8();\n  }\n  /**\n   * Read `n` bytes and move pointer forward by `n` bytes.\n   * @param n - Number of bytes to read.\n   * @returns The read bytes.\n   */\n  readBytes(n = 1) {\n    return this.readArray(n, 'uint8');\n  }\n  /**\n   * Creates an array of corresponding to the type `type` and size `size`.\n   * For example type `uint8` will create a `Uint8Array`.\n   * @param size - size of the resulting array\n   * @param type - number type of elements to read\n   * @returns The read array.\n   */\n  readArray(size, type) {\n    const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n    const offset = this.byteOffset + this.offset;\n    const slice = this.buffer.slice(offset, offset + bytes);\n    if (this.littleEndian === hostBigEndian && type !== 'uint8' && type !== 'int8') {\n      const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n      slice.reverse();\n      const returnArray = new typedArrays[type](slice.buffer);\n      this.offset += bytes;\n      returnArray.reverse();\n      return returnArray;\n    }\n    const returnArray = new typedArrays[type](slice);\n    this.offset += bytes;\n    return returnArray;\n  }\n  /**\n   * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n   * @returns The read value.\n   */\n  readInt16() {\n    const value = this._data.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  /**\n   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n   * @returns The read value.\n   */\n  readUint16() {\n    const value = this._data.getUint16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  /**\n   * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n   * @returns The read value.\n   */\n  readInt32() {\n    const value = this._data.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n   * @returns The read value.\n   */\n  readUint32() {\n    const value = this._data.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 32-bit floating number and move pointer forward by 4 bytes.\n   * @returns The read value.\n   */\n  readFloat32() {\n    const value = this._data.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 64-bit floating number and move pointer forward by 8 bytes.\n   * @returns The read value.\n   */\n  readFloat64() {\n    const value = this._data.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\n   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n   * @returns The read value.\n   */\n  readBigInt64() {\n    const value = this._data.getBigInt64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\n   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n   * @returns The read value.\n   */\n  readBigUint64() {\n    const value = this._data.getBigUint64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\n   * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n   * @returns The read character.\n   */\n  readChar() {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    return String.fromCharCode(this.readInt8());\n  }\n  /**\n   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n   * @param n - Number of characters to read.\n   * @returns The read characters.\n   */\n  readChars(n = 1) {\n    let result = '';\n    for (let i = 0; i < n; i++) {\n      result += this.readChar();\n    }\n    return result;\n  }\n  /**\n   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n   * forward by `n` bytes.\n   * @param n - Number of bytes to read.\n   * @returns The decoded string.\n   */\n  readUtf8(n = 1) {\n    return decode(this.readBytes(n));\n  }\n  /**\n   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n   * forward by `n` bytes.\n   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n   * @param n - Number of bytes to read.\n   * @param encoding - The encoding to use. Default is 'utf8'.\n   * @returns The decoded string.\n   */\n  decodeText(n = 1, encoding = 'utf8') {\n    return decode(this.readBytes(n), encoding);\n  }\n  /**\n   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n   * forward by 1 byte.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeBoolean(value) {\n    this.writeUint8(value ? 0xff : 0x00);\n    return this;\n  }\n  /**\n   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeInt8(value) {\n    this.ensureAvailable(1);\n    this._data.setInt8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n   * byte.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeUint8(value) {\n    this.ensureAvailable(1);\n    this._data.setUint8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * An alias for {@link IOBuffer#writeUint8}.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeByte(value) {\n    return this.writeUint8(value);\n  }\n  /**\n   * Write all elements of `bytes` as uint8 values and move pointer forward by\n   * `bytes.length` bytes.\n   * @param bytes - The array of bytes to write.\n   * @returns This.\n   */\n  writeBytes(bytes) {\n    this.ensureAvailable(bytes.length);\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < bytes.length; i++) {\n      this._data.setUint8(this.offset++, bytes[i]);\n    }\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 16-bit signed integer and move pointer forward by 2\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeInt16(value) {\n    this.ensureAvailable(2);\n    this._data.setInt16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeUint16(value) {\n    this.ensureAvailable(2);\n    this._data.setUint16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 32-bit signed integer and move pointer forward by 4\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeInt32(value) {\n    this.ensureAvailable(4);\n    this._data.setInt32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeUint32(value) {\n    this.ensureAvailable(4);\n    this._data.setUint32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 32-bit floating number and move pointer forward by 4\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeFloat32(value) {\n    this.ensureAvailable(4);\n    this._data.setFloat32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 64-bit floating number and move pointer forward by 8\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeFloat64(value) {\n    this.ensureAvailable(8);\n    this._data.setFloat64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeBigInt64(value) {\n    this.ensureAvailable(8);\n    this._data.setBigInt64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n   * bytes.\n   * @param value - The value to write.\n   * @returns This.\n   */\n  writeBigUint64(value) {\n    this.ensureAvailable(8);\n    this._data.setBigUint64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\n   * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n   * and move pointer forward by 1 byte.\n   * @param str - The character to write.\n   * @returns This.\n   */\n  writeChar(str) {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    return this.writeUint8(str.charCodeAt(0));\n  }\n  /**\n   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n   * and move pointer forward by `str.length` bytes.\n   * @param str - The characters to write.\n   * @returns This.\n   */\n  writeChars(str) {\n    for (let i = 0; i < str.length; i++) {\n      // eslint-disable-next-line unicorn/prefer-code-point\n      this.writeUint8(str.charCodeAt(i));\n    }\n    return this;\n  }\n  /**\n   * UTF-8 encode and write `str` to the current pointer offset and move pointer\n   * forward according to the encoded length.\n   * @param str - The string to write.\n   * @returns This.\n   */\n  writeUtf8(str) {\n    return this.writeBytes(encode(str));\n  }\n  /**\n   * Export a Uint8Array view of the internal buffer.\n   * The view starts at the byte offset and its length\n   * is calculated to stop at the last written byte or the original length.\n   * @returns A new Uint8Array view.\n   */\n  toArray() {\n    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n  }\n  /**\n   *  Get the total number of bytes written so far, regardless of the current offset.\n   * @returns - Total number of bytes.\n   */\n  getWrittenByteLength() {\n    return this.lastWrittenByte - this.byteOffset;\n  }\n  /**\n   * Update the last written byte offset\n   * @private\n   */\n  _updateLastWrittenByte() {\n    if (this.offset > this.lastWrittenByte) {\n      this.lastWrittenByte = this.offset;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}