{"ast":null,"code":"const crcTable = [];\nfor (let n = 0; n < 256; n++) {\n  let c = n;\n  for (let k = 0; k < 8; k++) {\n    if (c & 1) {\n      c = 0xedb88320 ^ c >>> 1;\n    } else {\n      c = c >>> 1;\n    }\n  }\n  crcTable[n] = c;\n}\nconst initialCrc = 0xffffffff;\nfunction updateCrc(currentCrc, data, length) {\n  let c = currentCrc;\n  for (let n = 0; n < length; n++) {\n    c = crcTable[(c ^ data[n]) & 0xff] ^ c >>> 8;\n  }\n  return c;\n}\nfunction crc(data, length) {\n  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\n}\nexport function checkCrc(buffer, crcLength, chunkName) {\n  const expectedCrc = buffer.readUint32();\n  const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n  if (actualCrc !== expectedCrc) {\n    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);\n  }\n}\nexport function writeCrc(buffer, length) {\n  buffer.writeUint32(crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - length, length), length));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}