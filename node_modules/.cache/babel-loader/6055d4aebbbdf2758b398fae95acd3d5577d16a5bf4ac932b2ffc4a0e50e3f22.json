{"ast":null,"code":"import _defineProperty from \"D:/brgy_docu_hub/BOSFDR/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super(data);\n    _defineProperty(this, \"_checkCrc\", void 0);\n    _defineProperty(this, \"_inflator\", void 0);\n    _defineProperty(this, \"_png\", void 0);\n    _defineProperty(this, \"_apng\", void 0);\n    _defineProperty(this, \"_end\", void 0);\n    _defineProperty(this, \"_hasPalette\", void 0);\n    _defineProperty(this, \"_palette\", void 0);\n    _defineProperty(this, \"_hasTransparency\", void 0);\n    _defineProperty(this, \"_transparency\", void 0);\n    _defineProperty(this, \"_compressionMethod\", void 0);\n    _defineProperty(this, \"_filterMethod\", void 0);\n    _defineProperty(this, \"_interlaceMethod\", void 0);\n    _defineProperty(this, \"_colorType\", void 0);\n    _defineProperty(this, \"_isAnimated\", void 0);\n    _defineProperty(this, \"_numberOfFrames\", void 0);\n    _defineProperty(this, \"_numberOfPlays\", void 0);\n    _defineProperty(this, \"_frames\", void 0);\n    _defineProperty(this, \"_writingDataChunks\", void 0);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._apng = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      depth: 1,\n      numberOfFrames: 1,\n      numberOfPlays: 0,\n      text: {},\n      frames: []\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    this._isAnimated = false;\n    this._numberOfFrames = 1;\n    this._numberOfPlays = 0;\n    this._frames = [];\n    this._writingDataChunks = false;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n  decode() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeChunk(length, type);\n    }\n    this.decodeImage();\n    return this._png;\n  }\n  decodeApng() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeApngChunk(length, type);\n    }\n    this.decodeApngImage();\n    return this._apng;\n  }\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  decodeChunk(length, type) {\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP':\n        // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case textChunkName:\n        // 11.3.4.3 tEXt Textual data\n        decodetEXt(this._png.text, this, length);\n        break;\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  decodeApngChunk(length, type) {\n    const offset = this.offset;\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n      this.pushDataToFrame();\n    }\n    switch (type) {\n      case 'acTL':\n        this.decodeACTL();\n        break;\n      case 'fcTL':\n        this.decodeFCTL();\n        break;\n      case 'fdAT':\n        this.decodeFDAT(length);\n        break;\n      default:\n        this.decodeChunk(length, type);\n        this.offset = offset + length;\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      // Kept for exhaustiveness.\n      // eslint-disable-next-line unicorn/no-useless-switch-case\n      case ColorType.UNKNOWN:\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n    }\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n  decodeACTL() {\n    this._numberOfFrames = this.readUint32();\n    this._numberOfPlays = this.readUint32();\n    this._isAnimated = true;\n  }\n  decodeFCTL() {\n    const image = {\n      sequenceNumber: this.readUint32(),\n      width: this.readUint32(),\n      height: this.readUint32(),\n      xOffset: this.readUint32(),\n      yOffset: this.readUint32(),\n      delayNumber: this.readUint16(),\n      delayDenominator: this.readUint16(),\n      disposeOp: this.readUint8(),\n      blendOp: this.readUint8(),\n      data: new Uint8Array(0)\n    };\n    this._frames.push(image);\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  decodeIDAT(length) {\n    this._writingDataChunks = true;\n    const dataLength = length;\n    const dataOffset = this.offset + this.byteOffset;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  decodeFDAT(length) {\n    this._writingDataChunks = true;\n    let dataLength = length;\n    let dataOffset = this.offset + this.byteOffset;\n    dataOffset += 4;\n    dataLength -= 4;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  // https://www.w3.org/TR/PNG/#11tRNS\n  decodetRNS(length) {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR:\n        {\n          if (length % 2 !== 0) {\n            throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n          }\n          if (length / 2 > this._png.width * this._png.height) {\n            throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n          }\n          this._hasTransparency = true;\n          this._transparency = new Uint16Array(length / 2);\n          for (let i = 0; i < length / 2; i++) {\n            this._transparency[i] = this.readUint16();\n          }\n          break;\n        }\n      case ColorType.INDEXED_COLOUR:\n        {\n          if (length > this._palette.length) {\n            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n          }\n          let i = 0;\n          for (; i < length; i++) {\n            const alpha = this.readByte();\n            this._palette[i].push(alpha);\n          }\n          for (; i < this._palette.length; i++) {\n            this._palette[i].push(255);\n          }\n          break;\n        }\n      // Kept for exhaustiveness.\n      /* eslint-disable unicorn/no-useless-switch-case */\n      case ColorType.UNKNOWN:\n      case ColorType.GREYSCALE_ALPHA:\n      case ColorType.TRUECOLOUR_ALPHA:\n      default:\n        {\n          throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n        }\n      /* eslint-enable unicorn/no-useless-switch-case */\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11iCCP\n  decodeiCCP(length) {\n    const name = readKeyword(this);\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile)\n    };\n  }\n  // https://www.w3.org/TR/PNG/#11pHYs\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n  decodeApngImage() {\n    this._apng.width = this._png.width;\n    this._apng.height = this._png.height;\n    this._apng.channels = this._png.channels;\n    this._apng.depth = this._png.depth;\n    this._apng.numberOfFrames = this._numberOfFrames;\n    this._apng.numberOfPlays = this._numberOfPlays;\n    this._apng.text = this._png.text;\n    this._apng.resolution = this._png.resolution;\n    for (let i = 0; i < this._numberOfFrames; i++) {\n      const newFrame = {\n        sequenceNumber: this._frames[i].sequenceNumber,\n        delayNumber: this._frames[i].delayNumber,\n        delayDenominator: this._frames[i].delayDenominator,\n        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)\n      };\n      const frame = this._frames.at(i);\n      if (frame) {\n        frame.data = decodeInterlaceNull({\n          data: frame.data,\n          width: frame.width,\n          height: frame.height,\n          channels: this._apng.channels,\n          depth: this._apng.depth\n        });\n        if (this._hasPalette) {\n          this._apng.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n          this._apng.transparency = this._transparency;\n        }\n        if (i === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {\n          newFrame.data = frame.data;\n        } else {\n          const prevFrame = this._apng.frames.at(i - 1);\n          this.disposeFrame(frame, prevFrame, newFrame);\n          this.addFrameDataToCanvas(newFrame, frame);\n        }\n        this._apng.frames.push(newFrame);\n      }\n    }\n    return this._apng;\n  }\n  disposeFrame(frame, prevFrame, imageFrame) {\n    switch (frame.disposeOp) {\n      case DisposeOpType.NONE:\n        break;\n      case DisposeOpType.BACKGROUND:\n        for (let row = 0; row < this._png.height; row++) {\n          for (let col = 0; col < this._png.width; col++) {\n            const index = (row * frame.width + col) * this._png.channels;\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = 0;\n            }\n          }\n        }\n        break;\n      case DisposeOpType.PREVIOUS:\n        imageFrame.data.set(prevFrame.data);\n        break;\n      default:\n        throw new Error('Unknown disposeOp');\n    }\n  }\n  addFrameDataToCanvas(imageFrame, frame) {\n    const maxValue = 1 << this._png.depth;\n    const calculatePixelIndices = (row, col) => {\n      const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;\n      const frameIndex = (row * frame.width + col) * this._png.channels;\n      return {\n        index,\n        frameIndex\n      };\n    };\n    switch (frame.blendOp) {\n      case BlendOpType.SOURCE:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = frame.data[frameIndex + channel];\n            }\n          }\n        }\n        break;\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n      case BlendOpType.OVER:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];\n              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);\n              imageFrame.data[index + channel] += value;\n            }\n          }\n        }\n        break;\n      default:\n        throw new Error('Unknown blendOp');\n    }\n  }\n  decodeImage() {\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this._png.data = decodeInterlaceNull({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      this._png.data = decodeInterlaceAdam7({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else {\n      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n    }\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n  }\n  pushDataToFrame() {\n    const result = this._inflator.result;\n    const lastFrame = this._frames.at(-1);\n    if (lastFrame) {\n      lastFrame.data = result;\n    } else {\n      this._frames.push({\n        sequenceNumber: 0,\n        width: this._png.width,\n        height: this._png.height,\n        xOffset: 0,\n        yOffset: 0,\n        delayNumber: 0,\n        delayDenominator: 0,\n        disposeOp: DisposeOpType.NONE,\n        blendOp: BlendOpType.SOURCE,\n        data: result\n      });\n    }\n    this._inflator = new Inflator();\n    this._writingDataChunks = false;\n  }\n}\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}