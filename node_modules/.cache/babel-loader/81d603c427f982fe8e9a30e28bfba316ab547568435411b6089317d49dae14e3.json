{"ast":null,"code":"export default {\n  name: 'ImageViewer',\n  props: {\n    imageUrl: {\n      type: String,\n      required: true\n    },\n    title: {\n      type: String,\n      default: ''\n    },\n    filename: {\n      type: String,\n      default: ''\n    },\n    imageType: {\n      type: String,\n      default: ''\n    },\n    downloadUrl: {\n      type: String,\n      default: ''\n    },\n    showMeta: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data() {\n    return {\n      loading: true,\n      error: null,\n      zoomLevel: 1,\n      minZoom: 0.5,\n      maxZoom: 3,\n      zoomStep: 0.25,\n      imageLoadAttempts: 0,\n      maxLoadAttempts: 3\n    };\n  },\n  computed: {\n    shouldShowImage() {\n      return !this.loading && !this.error && this.imageUrl;\n    }\n  },\n  watch: {\n    imageUrl: {\n      handler(newUrl, oldUrl) {\n        console.log('🔄 ImageViewer: imageUrl changed:', {\n          oldUrl: oldUrl ? oldUrl.substring(0, 50) + '...' : 'none',\n          newUrl: newUrl ? newUrl.substring(0, 50) + '...' : 'none',\n          isBlobUrl: newUrl?.startsWith('blob:'),\n          isDataUrl: newUrl?.startsWith('data:')\n        });\n        if (newUrl) {\n          this.loading = true;\n          this.error = null;\n          this.imageLoadAttempts = 0;\n\n          // Preload the image manually to ensure it works\n          this.preloadImage(newUrl);\n        }\n      },\n      immediate: true\n    }\n  },\n  mounted() {\n    // Add keyboard event listeners\n    document.addEventListener('keydown', this.handleKeydown);\n\n    // Add touch event listeners for mobile gestures\n    this.addTouchListeners();\n\n    // Check if image is already loaded (for cached blob URLs)\n    this.$nextTick(() => {\n      const img = this.$el?.querySelector('.main-image');\n      if (img) {\n        console.log('🔍 ImageViewer mounted, checking image state:', {\n          src: img.src ? img.src.substring(0, 50) + '...' : 'none',\n          complete: img.complete,\n          naturalWidth: img.naturalWidth,\n          naturalHeight: img.naturalHeight\n        });\n\n        // If image is already loaded (cached), update loading state\n        if (img.complete && img.naturalWidth > 0) {\n          console.log('✅ Image was already loaded, updating state');\n          this.loading = false;\n          this.error = null;\n        } else if (this.imageUrl) {\n          // Validate blob URL\n          this.validateImageUrl(this.imageUrl);\n\n          // Set multiple timeout checks for robust loading\n          setTimeout(() => this.checkImageLoadingState(), 1000); // Quick check\n          setTimeout(() => this.checkImageLoadingState(), 3000); // Medium check\n          setTimeout(() => this.checkImageLoadingState(), 5000); // Final check\n        }\n      }\n    });\n  },\n  beforeUnmount() {\n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this.handleKeydown);\n\n    // Remove touch event listeners\n    this.removeTouchListeners();\n  },\n  methods: {\n    handleOverlayClick() {\n      this.$emit('close');\n    },\n    onImageLoadStart(event) {\n      console.log('🔄 ImageViewer: Image load started:', {\n        src: event.target.src.substring(0, 50) + '...',\n        loadingState: this.loading\n      });\n    },\n    onImageLoadEnd(event) {\n      console.log('🏁 ImageViewer: Image load ended:', {\n        src: event.target.src.substring(0, 50) + '...',\n        complete: event.target.complete,\n        naturalWidth: event.target.naturalWidth,\n        naturalHeight: event.target.naturalHeight\n      });\n    },\n    onImageLoad(event) {\n      console.log('✅ ImageViewer: Image loaded successfully:', {\n        src: event.target.src.substring(0, 50) + '...',\n        naturalWidth: event.target.naturalWidth,\n        naturalHeight: event.target.naturalHeight,\n        currentLoadingState: this.loading\n      });\n\n      // Force Vue reactivity update\n      this.$nextTick(() => {\n        this.loading = false;\n        this.error = null;\n        console.log('✅ ImageViewer: Loading state updated to false');\n      });\n    },\n    onImageError(event) {\n      console.error('❌ ImageViewer: Image failed to load:', {\n        src: event.target.src.substring(0, 50) + '...',\n        error: event.target.error,\n        currentLoadingState: this.loading\n      });\n\n      // Force Vue reactivity update\n      this.$nextTick(() => {\n        this.loading = false;\n        this.error = 'Failed to load image. The image file may be missing or corrupted.';\n        console.log('❌ ImageViewer: Error state updated');\n      });\n    },\n    retryLoad() {\n      console.log('🔄 ImageViewer: Retrying image load');\n      this.loading = true;\n      this.error = null;\n\n      // Force image reload\n      const img = this.$el.querySelector('.main-image');\n      if (img) {\n        // For blob URLs, we can't add query parameters, so force reload differently\n        if (this.imageUrl.startsWith('blob:')) {\n          console.log('🔄 Retrying blob URL load');\n          img.src = '';\n          this.$nextTick(() => {\n            img.src = this.imageUrl;\n          });\n        } else {\n          console.log('🔄 Retrying regular URL load with cache bust');\n          img.src = this.imageUrl + '?t=' + Date.now();\n        }\n      }\n    },\n    zoomIn() {\n      if (this.zoomLevel < this.maxZoom) {\n        this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + this.zoomStep);\n      }\n    },\n    zoomOut() {\n      if (this.zoomLevel > this.minZoom) {\n        this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - this.zoomStep);\n      }\n    },\n    resetZoom() {\n      this.zoomLevel = 1;\n    },\n    handleWheel(event) {\n      event.preventDefault();\n      if (event.deltaY < 0) {\n        this.zoomIn();\n      } else {\n        this.zoomOut();\n      }\n    },\n    handleKeydown(event) {\n      switch (event.key) {\n        case 'Escape':\n          this.$emit('close');\n          break;\n        case '+':\n        case '=':\n          event.preventDefault();\n          this.zoomIn();\n          break;\n        case '-':\n          event.preventDefault();\n          this.zoomOut();\n          break;\n        case '0':\n          event.preventDefault();\n          this.resetZoom();\n          break;\n      }\n    },\n    async downloadImage() {\n      if (!this.downloadUrl) return;\n      try {\n        // If downloadUrl is already a blob URL, use it directly\n        if (this.downloadUrl.startsWith('blob:')) {\n          const link = document.createElement('a');\n          link.href = this.downloadUrl;\n          link.download = this.filename || 'image.jpg';\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n        } else {\n          // For regular URLs, fetch with authentication\n          const api = (await import('@/services/api.js')).default;\n          const response = await api.get(this.downloadUrl, {\n            responseType: 'blob'\n          });\n          const blob = response.data;\n          const url = URL.createObjectURL(blob);\n          const link = document.createElement('a');\n          link.href = url;\n          link.download = this.filename || 'image.jpg';\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n          URL.revokeObjectURL(url);\n        }\n      } catch (error) {\n        console.error('Error downloading image:', error);\n        this.$emit('error', 'Failed to download image');\n      }\n    },\n    validateImageUrl(url) {\n      console.log('🔍 ImageViewer: Validating image URL:', {\n        url: url.substring(0, 50) + '...',\n        isBlobUrl: url.startsWith('blob:'),\n        isDataUrl: url.startsWith('data:'),\n        isHttpUrl: url.startsWith('http')\n      });\n\n      // For blob URLs, try to validate they're still valid\n      if (url.startsWith('blob:')) {\n        try {\n          // Create a test image to validate the blob URL\n          const testImg = new Image();\n          testImg.onload = () => {\n            console.log('✅ Blob URL validation: URL is accessible');\n          };\n          testImg.onerror = () => {\n            console.error('❌ Blob URL validation: URL is not accessible');\n          };\n          testImg.src = url;\n        } catch (error) {\n          console.error('❌ Blob URL validation error:', error);\n        }\n      }\n    },\n    debugImageState() {\n      const img = this.$refs.mainImage;\n      if (img) {\n        console.log('🔍 ImageViewer: Current image state:', {\n          src: img.src ? img.src.substring(0, 50) + '...' : 'none',\n          complete: img.complete,\n          naturalWidth: img.naturalWidth,\n          naturalHeight: img.naturalHeight,\n          readyState: img.readyState,\n          loading: this.loading,\n          error: this.error\n        });\n      } else {\n        console.log('🔍 ImageViewer: No image ref found');\n      }\n    },\n    forceImageReload() {\n      console.log('🔄 ImageViewer: Force reloading image');\n      this.imageLoadAttempts++;\n      if (this.imageLoadAttempts > this.maxLoadAttempts) {\n        console.error('❌ ImageViewer: Max load attempts reached, giving up');\n        this.loading = false;\n        this.error = 'Image failed to load after multiple attempts';\n        return;\n      }\n      const img = this.$refs.mainImage;\n      const hiddenImg = this.$refs.hiddenImage;\n      [img, hiddenImg].forEach(imgEl => {\n        if (imgEl && this.imageUrl) {\n          // Clear the src and reload\n          imgEl.src = '';\n          this.$nextTick(() => {\n            imgEl.src = this.imageUrl;\n            console.log('🔄 ImageViewer: Image src reset and reloaded');\n          });\n        }\n      });\n    },\n    checkImageLoadingState() {\n      if (!this.loading) {\n        return; // Already loaded or errored\n      }\n      const img = this.$refs.mainImage;\n      const hiddenImg = this.$refs.hiddenImage;\n\n      // Check both visible and hidden images\n      [img, hiddenImg].forEach((imgEl, index) => {\n        if (imgEl) {\n          const imgType = index === 0 ? 'main' : 'hidden';\n          console.log(`🔍 Checking ${imgType} image state:`, {\n            complete: imgEl.complete,\n            naturalWidth: imgEl.naturalWidth,\n            naturalHeight: imgEl.naturalHeight,\n            src: imgEl.src ? imgEl.src.substring(0, 30) + '...' : 'none'\n          });\n\n          // If image is actually loaded but events didn't fire\n          if (imgEl.complete && imgEl.naturalWidth > 0 && this.loading) {\n            console.log(`✅ ${imgType} image is loaded but state not updated, fixing...`);\n            this.loading = false;\n            this.error = null;\n            return;\n          }\n        }\n      });\n\n      // If still loading after checks, provide more info\n      if (this.loading) {\n        console.log('⏰ Image still loading, current state:', {\n          loading: this.loading,\n          error: this.error,\n          imageUrl: this.imageUrl ? this.imageUrl.substring(0, 50) + '...' : 'none',\n          attempts: this.imageLoadAttempts\n        });\n      }\n    },\n    preloadImage(url) {\n      console.log('🔄 ImageViewer: Preloading image manually:', url.substring(0, 50) + '...');\n\n      // Create a new image element for preloading\n      const preloadImg = new Image();\n      preloadImg.onload = () => {\n        console.log('✅ ImageViewer: Preload successful, updating component state');\n        this.loading = false;\n        this.error = null;\n\n        // Update the actual image elements\n        this.$nextTick(() => {\n          const img = this.$refs.mainImage;\n          const hiddenImg = this.$refs.hiddenImage;\n          [img, hiddenImg].forEach(imgEl => {\n            if (imgEl && imgEl.src !== url) {\n              imgEl.src = url;\n            }\n          });\n        });\n      };\n      preloadImg.onerror = error => {\n        console.error('❌ ImageViewer: Preload failed:', error);\n        this.loading = false;\n        this.error = 'Failed to load image. The image may be corrupted or unavailable.';\n      };\n\n      // Start preloading\n      preloadImg.src = url;\n\n      // Fallback timeout\n      setTimeout(() => {\n        if (this.loading) {\n          console.log('⏰ Preload timeout, checking if image actually loaded...');\n          if (preloadImg.complete && preloadImg.naturalWidth > 0) {\n            console.log('✅ Image was loaded but events may have been missed');\n            this.loading = false;\n            this.error = null;\n          }\n        }\n      }, 10000);\n    },\n    addTouchListeners() {\n      // Add touch gesture support for mobile devices\n      const imageDisplay = this.$refs.viewerContent;\n      if (imageDisplay) {\n        let initialDistance = 0;\n        let initialZoom = 1;\n        let lastTouchTime = 0;\n\n        // Handle pinch-to-zoom\n        imageDisplay.addEventListener('touchstart', e => {\n          if (e.touches.length === 2) {\n            e.preventDefault();\n            const touch1 = e.touches[0];\n            const touch2 = e.touches[1];\n            initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);\n            initialZoom = this.zoomLevel;\n          } else if (e.touches.length === 1) {\n            // Handle double-tap to reset zoom\n            const currentTime = new Date().getTime();\n            const tapLength = currentTime - lastTouchTime;\n            if (tapLength < 500 && tapLength > 0) {\n              e.preventDefault();\n              this.resetZoom();\n            }\n            lastTouchTime = currentTime;\n          }\n        }, {\n          passive: false\n        });\n        imageDisplay.addEventListener('touchmove', e => {\n          if (e.touches.length === 2) {\n            e.preventDefault();\n            const touch1 = e.touches[0];\n            const touch2 = e.touches[1];\n            const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);\n            const scale = currentDistance / initialDistance;\n            const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, initialZoom * scale));\n            this.zoomLevel = newZoom;\n          }\n        }, {\n          passive: false\n        });\n      }\n    },\n    removeTouchListeners() {\n      // Touch listeners are added with anonymous functions, so they'll be cleaned up automatically\n      // when the component is destroyed\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}