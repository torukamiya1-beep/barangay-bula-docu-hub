{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport documentRequestService from '@/services/documentRequestService';\nimport clientAuthService from '@/services/clientAuthService';\nimport ImageViewer from '@/components/common/ImageViewer.vue';\nexport default {\n  name: 'RequestDetails',\n  components: {\n    ImageViewer\n  },\n  data() {\n    return {\n      request: null,\n      loading: true,\n      error: null,\n      showImageViewer: false,\n      selectedImage: null,\n      imageObjectUrls: new Map(),\n      // Track created object URLs for cleanup\n      imageUrls: {\n        beneficiaryVerification: '',\n        pickupId: '',\n        authorizationLetter: ''\n      },\n      // Store loaded image URLs for template binding\n      progressSteps: [{\n        status: 'pending',\n        title: 'Request Submitted',\n        description: 'Your request has been submitted and is waiting for review',\n        icon: 'fas fa-paper-plane'\n      }, {\n        status: 'under_review',\n        title: 'Under Review',\n        description: 'Your request is being reviewed by our staff',\n        icon: 'fas fa-search'\n      }, {\n        status: 'approved',\n        title: 'Approved',\n        description: 'Your request has been approved and payment is required',\n        icon: 'fas fa-check'\n      }, {\n        status: 'processing',\n        title: 'Processing',\n        description: 'Your document is being prepared',\n        icon: 'fas fa-cog'\n      }, {\n        status: 'ready_for_pickup',\n        title: 'Ready for Pickup',\n        description: 'Your document is ready for pickup',\n        icon: 'fas fa-box'\n      }, {\n        status: 'completed',\n        title: 'Completed',\n        description: 'Request has been completed successfully',\n        icon: 'fas fa-check-circle'\n      }]\n    };\n  },\n  computed: {\n    clientData() {\n      return clientAuthService.getCurrentUser();\n    }\n  },\n  async mounted() {\n    await this.loadRequestDetails();\n  },\n  beforeUnmount() {\n    // Clean up object URLs to prevent memory leaks\n    this.cleanupImageUrls();\n  },\n  methods: {\n    async loadRequestDetails() {\n      try {\n        this.loading = true;\n        this.error = null;\n        const requestId = this.$route.params.id;\n        const response = await documentRequestService.getRequestDetails(requestId);\n        this.request = response.data;\n\n        // Debug: Log the received request data\n        console.log('üîç Frontend received request data:', {\n          id: this.request?.id,\n          requestor: this.request?.requestor,\n          nationality: this.request?.requestor?.nationality,\n          months_of_residency: this.request?.requestor?.months_of_residency,\n          years_of_residency: this.request?.requestor?.years_of_residency,\n          beneficiary: this.request?.beneficiary,\n          beneficiary_verification_image: this.request?.beneficiary?.verification_image_path,\n          authorized_pickup: this.request?.authorized_pickup,\n          pickup_id_image: this.request?.authorized_pickup?.id_image_path\n        });\n\n        // Debug: Log the request data to see what's available\n        console.log('üîç Request data loaded:', {\n          hasAuthorizedPickup: !!this.request.authorized_pickup,\n          authorizedPickupData: this.request.authorized_pickup,\n          pickupIdImagePath: this.request.authorized_pickup?.id_image_path,\n          authorizationLetterPath: this.request.authorized_pickup?.authorization_letter_path\n        });\n\n        // Load images after request details are loaded\n        await this.loadImages();\n      } catch (error) {\n        console.error('Error loading request details:', error);\n        this.error = error.response?.data?.message || 'Failed to load request details';\n      } finally {\n        this.loading = false;\n      }\n    },\n    async loadImages() {\n      // Check if user is authenticated\n      const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n      if (!authToken) {\n        console.warn('‚ö†Ô∏è User not authenticated, skipping image loading');\n        this.showToast('Warning', 'Please log in to view verification images', 'warning');\n        return;\n      }\n      console.log('üñºÔ∏è Starting image loading process...');\n\n      // Load beneficiary verification image\n      if (this.request?.beneficiary?.verification_image_path) {\n        try {\n          console.log('üì∏ Loading beneficiary verification image...');\n          const imageUrl = await this.getVerificationImageUrl(this.request.beneficiary.verification_image_path);\n          if (imageUrl && imageUrl !== this.getPlaceholderImageUrl()) {\n            this.imageUrls.beneficiaryVerification = imageUrl;\n            console.log('‚úÖ Beneficiary verification image loaded successfully');\n          } else {\n            this.imageUrls.beneficiaryVerification = this.getPlaceholderImageUrl();\n          }\n        } catch (error) {\n          console.error('‚ùå Failed to load beneficiary verification image:', error.message);\n          this.imageUrls.beneficiaryVerification = this.getPlaceholderImageUrl();\n          if (error.message.includes('log in')) {\n            this.showToast('Warning', 'Please log in to view images', 'warning');\n          }\n        }\n      }\n\n      // Load pickup ID image\n      if (this.request?.authorized_pickup?.id_image_path) {\n        try {\n          console.log('üì∏ Loading pickup ID image...', {\n            path: this.request.authorized_pickup.id_image_path,\n            filename: this.request.authorized_pickup.id_image_path.split(/[/\\\\]/).pop()\n          });\n          const imageUrl = await this.getPickupIdImageUrl(this.request.authorized_pickup.id_image_path);\n          if (imageUrl && imageUrl !== this.getPlaceholderImageUrl()) {\n            this.imageUrls.pickupId = imageUrl;\n            console.log('‚úÖ Pickup ID image loaded successfully');\n          } else {\n            this.imageUrls.pickupId = this.getPlaceholderImageUrl();\n            console.log('‚ö†Ô∏è Using placeholder for pickup ID image');\n          }\n        } catch (error) {\n          console.error('‚ùå Failed to load pickup ID image:', error.message);\n          this.imageUrls.pickupId = this.getPlaceholderImageUrl();\n          if (error.message.includes('log in')) {\n            this.showToast('Warning', 'Please log in to view images', 'warning');\n          }\n        }\n      } else {\n        console.log('‚ö†Ô∏è No pickup ID image path found in request data');\n      }\n\n      // Load authorization letter image\n      if (this.request?.authorized_pickup?.authorization_letter_path) {\n        try {\n          console.log('üì∏ Loading authorization letter image...');\n          const imageUrl = await this.getAuthorizationLetterUrl(this.request.authorized_pickup.authorization_letter_path);\n          if (imageUrl && imageUrl !== this.getPlaceholderImageUrl()) {\n            this.imageUrls.authorizationLetter = imageUrl;\n            console.log('‚úÖ Authorization letter image loaded successfully');\n          } else {\n            this.imageUrls.authorizationLetter = this.getPlaceholderImageUrl();\n          }\n        } catch (error) {\n          console.error('‚ùå Failed to load authorization letter image:', error.message);\n          this.imageUrls.authorizationLetter = this.getPlaceholderImageUrl();\n          if (error.message.includes('log in')) {\n            this.showToast('Warning', 'Please log in to view images', 'warning');\n          }\n        }\n      }\n      console.log('üñºÔ∏è Image loading process completed');\n    },\n    cleanupImageUrls() {\n      // Revoke all object URLs to prevent memory leaks\n      for (const [key, url] of this.imageObjectUrls) {\n        URL.revokeObjectURL(url);\n        console.log('üßπ Cleaned up object URL:', key);\n      }\n      this.imageObjectUrls.clear();\n    },\n    getDocumentIcon(type) {\n      const icons = {\n        'Barangay Clearance': 'fas fa-certificate',\n        'Cedula': 'fas fa-id-card'\n      };\n      return icons[type] || 'fas fa-file-alt';\n    },\n    getStatusClass(status) {\n      const classes = {\n        'pending': 'status-pending',\n        'under_review': 'status-review',\n        'approved': 'status-approved',\n        'processing': 'status-processing',\n        'ready_for_pickup': 'status-ready',\n        'completed': 'status-completed',\n        'rejected': 'status-rejected',\n        'cancelled': 'status-cancelled'\n      };\n      return classes[status] || 'status-unknown';\n    },\n    formatStatus(status) {\n      const statusMap = {\n        'pending': 'Pending',\n        'under_review': 'Under Review',\n        'approved': 'Approved',\n        'processing': 'Processing',\n        'ready_for_pickup': 'Ready for Pickup',\n        'completed': 'Completed',\n        'rejected': 'Rejected',\n        'cancelled': 'Cancelled'\n      };\n      return statusMap[status] || status;\n    },\n    getPaymentStatusClass(status) {\n      const classes = {\n        'pending': 'payment-pending',\n        'paid': 'payment-paid',\n        'failed': 'payment-failed',\n        'refunded': 'payment-refunded'\n      };\n      return classes[status] || 'payment-unknown';\n    },\n    formatPaymentStatus(status) {\n      const statusMap = {\n        'pending': 'Pending Payment',\n        'paid': 'Paid',\n        'failed': 'Payment Failed',\n        'refunded': 'Refunded'\n      };\n      return statusMap[status] || 'Not Required';\n    },\n    getMainTimelineSteps() {\n      // Create a copy of progress steps to modify for cash payments\n      const steps = [...this.progressSteps];\n\n      // Check if this is a cash payment\n      const isCashPayment = this.request && (this.request.payment_method === 'Cash Payment' || this.request.payment_method === 'Cash' || this.request.payment_method_code === 'CASH' || this.request.payment_method_id === 1 || this.request.is_online_payment === false || this.request.is_online_payment === 0 || this.request.is_online === false || this.request.is_online === 0);\n\n      // Modify the \"approved\" step description for cash payments\n      if (isCashPayment) {\n        const approvedStepIndex = steps.findIndex(step => step.status === 'approved');\n        if (approvedStepIndex !== -1) {\n          steps[approvedStepIndex] = {\n            ...steps[approvedStepIndex],\n            description: 'Your request has been approved. Payment will be collected during pickup.'\n          };\n        }\n      }\n      return steps;\n    },\n    isStepCompleted(stepStatus, currentStatus) {\n      // Don't mark any steps as completed if the request is rejected\n      if (currentStatus === 'rejected') {\n        // Only mark steps before \"under_review\" as completed for rejected requests\n        const completedBeforeRejection = ['pending'];\n        return completedBeforeRejection.includes(stepStatus);\n      }\n      const statusOrder = ['pending', 'under_review', 'approved', 'processing', 'ready_for_pickup', 'completed'];\n      const stepIndex = statusOrder.indexOf(stepStatus);\n      const currentIndex = statusOrder.indexOf(currentStatus);\n      return stepIndex < currentIndex;\n    },\n    getFullName() {\n      const client = this.request?.client || this.clientData?.profile;\n      if (!client) return 'N/A';\n      return `${client.first_name || ''} ${client.middle_name || ''} ${client.last_name || ''}`.trim();\n    },\n    getClientEmail() {\n      const email = this.request?.email || this.request?.client?.email || this.clientData?.profile?.email;\n      return email && email.trim() ? email : null;\n    },\n    getClientPhone() {\n      const phone = this.request?.phone_number || this.request?.client?.phone_number || this.clientData?.profile?.phone_number;\n      return phone && phone.trim() ? phone : 'Contact information not available';\n    },\n    getEmergencyContact() {\n      const contact = this.request?.emergency_contact_name;\n      return contact && contact.trim() ? contact : null;\n    },\n    getEmergencyPhone() {\n      const phone = this.request?.emergency_contact_phone;\n      return phone && phone.trim() ? phone : null;\n    },\n    getFullAddress() {\n      // Try multiple sources for address data\n      const client = this.request?.client || this.clientData || this.request;\n      if (!client) return 'Address not available';\n      const parts = [client.house_number || client.requestor_house_number, client.street || client.requestor_street, client.subdivision, client.barangay || client.requestor_barangay, client.city_municipality || client.requestor_city_municipality || client.city, client.province || client.requestor_province].filter(part => part && part.trim());\n      return parts.length > 0 ? parts.join(', ') : 'Address not available';\n    },\n    // New helper methods for complete client information\n    getClientUsername() {\n      return this.request?.client_username || this.request?.client?.username || this.clientData?.username;\n    },\n    getClientEmailVerified() {\n      return this.request?.email_verified || this.request?.client?.email_verified || this.clientData?.email_verified || false;\n    },\n    getClientPhoneVerified() {\n      return this.request?.phone_verified || this.request?.client?.phone_verified || this.clientData?.phone_verified || false;\n    },\n    getClientProfileVerified() {\n      return this.request?.is_verified || this.request?.client?.is_verified || this.clientData?.is_verified || false;\n    },\n    getClientResidencyVerified() {\n      return this.request?.residency_verified || this.request?.client?.residency_verified || this.clientData?.residency_verified || false;\n    },\n    getClientAccountStatus() {\n      return this.request?.status || this.request?.client?.status || this.clientData?.status || 'unknown';\n    },\n    getClientLastLogin() {\n      return this.request?.last_login || this.request?.client?.last_login || this.clientData?.last_login;\n    },\n    getClientCreatedAt() {\n      return this.request?.created_at || this.request?.client?.created_at || this.clientData?.created_at;\n    },\n    getClientBirthDate() {\n      return this.request?.birth_date || this.request?.requestor_birth_date || this.request?.client?.birth_date || this.clientData?.birth_date;\n    },\n    getClientGender() {\n      return this.request?.gender || this.request?.requestor_gender || this.request?.client?.gender || this.clientData?.gender;\n    },\n    getClientCivilStatus() {\n      return this.request?.civil_status_id || this.request?.requestor_civil_status_id || this.request?.client?.civil_status_id || this.clientData?.civil_status_id;\n    },\n    getClientNationality() {\n      return this.request?.requestor?.nationality || this.request?.nationality || this.request?.requestor_nationality || this.request?.client?.nationality || this.clientData?.nationality;\n    },\n    getClientAccountStatusClass() {\n      const status = this.getClientAccountStatus();\n      const classes = {\n        'active': 'bg-success',\n        'inactive': 'bg-secondary',\n        'suspended': 'bg-danger',\n        'pending_verification': 'bg-warning',\n        'pending_residency_verification': 'bg-info'\n      };\n      return classes[status] || 'bg-secondary';\n    },\n    formatAccountStatus(status) {\n      const statusMap = {\n        'active': 'Active',\n        'inactive': 'Inactive',\n        'suspended': 'Suspended',\n        'pending_verification': 'Pending Verification',\n        'pending_residency_verification': 'Pending Residency Verification'\n      };\n      return statusMap[status] || status;\n    },\n    formatGender(gender) {\n      if (!gender) return 'Not provided';\n      return gender.charAt(0).toUpperCase() + gender.slice(1);\n    },\n    getCivilStatusName(statusId) {\n      const statuses = {\n        1: 'Single',\n        2: 'Married',\n        3: 'Divorced',\n        4: 'Widowed',\n        5: 'Separated'\n      };\n      return statuses[statusId] || 'Not provided';\n    },\n    getResidencyDisplay() {\n      if (!this.request || !this.request.requestor) {\n        return 'Not provided';\n      }\n      const years = this.request.requestor.years_of_residency || 0;\n      const months = this.request.requestor.months_of_residency || 0;\n\n      // If both are 0, return \"Not provided\"\n      if (years === 0 && months === 0) {\n        return 'Not provided';\n      }\n      const parts = [];\n      if (years > 0) parts.push(`${years} year${years > 1 ? 's' : ''}`);\n      if (months > 0) parts.push(`${months} month${months > 1 ? 's' : ''}`);\n      return parts.length > 0 ? parts.join(' and ') : 'Less than a month';\n    },\n    formatDate(dateString) {\n      if (!dateString) return 'N/A';\n      return new Date(dateString).toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n    },\n    formatCurrency(amount) {\n      return parseFloat(amount || 0).toFixed(2);\n    },\n    canCancelRequest(status) {\n      // Enhanced cancellation rules - allow cancellation until payment is confirmed\n      const cancellableStatuses = ['pending', 'under_review', 'additional_info_required', 'approved', 'payment_pending', 'payment_failed'];\n      return cancellableStatuses.includes(status);\n    },\n    needsPayment(request) {\n      // Check if request needs payment based on enhanced workflow\n      const paymentRequiredStatuses = ['approved', 'payment_pending', 'payment_failed'];\n      const unpaidStatuses = ['pending', 'failed', null, undefined, ''];\n      return paymentRequiredStatuses.includes(request.status) && unpaidStatuses.includes(request.payment_status) && request.payment_method_id &&\n      // Must have a payment method selected\n      request.is_online_payment; // Only show for online payment methods\n    },\n    canDownload(status) {\n      return status === 'completed';\n    },\n    async cancelRequest() {\n      // Enhanced cancellation with reason input\n      const reason = prompt('Please provide a reason for cancelling this request (optional):', '');\n\n      // If user clicked cancel on the prompt, don't proceed\n      if (reason === null) return;\n\n      // Confirm cancellation\n      if (!confirm('Are you sure you want to cancel this request?')) return;\n      try {\n        console.log('üö´ Cancelling request:', this.request.id, 'Reason:', reason);\n        const cancellationReason = reason.trim() || 'Cancelled by user';\n        await documentRequestService.cancelRequest(this.request.id, cancellationReason);\n        this.$toast?.success('Request cancelled successfully. Administrators have been notified.');\n        this.request.status = 'cancelled';\n\n        // Refresh request details to show updated status\n        await this.loadRequestDetails();\n        console.log('‚úÖ Request cancelled successfully');\n      } catch (error) {\n        console.error('‚ùå Error cancelling request:', error);\n\n        // Show more specific error messages\n        if (error.response?.data?.message) {\n          this.$toast?.error(error.response.data.message);\n        } else if (error.message?.includes('cannot be cancelled')) {\n          this.$toast?.error('This request cannot be cancelled at its current stage');\n        } else {\n          this.$toast?.error('Failed to cancel request. Please try again.');\n        }\n      }\n    },\n    async processPayment() {\n      try {\n        // Check if request has a payment method selected\n        if (!this.request.payment_method_id) {\n          this.showToast('Error', 'No payment method selected for this request', 'error');\n          return;\n        }\n\n        // Check if it's an online payment method\n        if (!this.request.is_online_payment) {\n          this.showToast('Info', 'This request uses in-person payment. Please pay at the barangay office.', 'info');\n          return;\n        }\n\n        // Show loading state\n        this.showToast('Info', 'Initiating payment...', 'info');\n\n        // Get current user data from clientAuthService\n        const currentUser = this.$clientAuth.getCurrentUser();\n\n        // Prepare payment data\n        const paymentData = {\n          request_id: this.request.id,\n          payment_method_id: this.request.payment_method_id,\n          customer_email: currentUser?.email || this.request.email\n        };\n\n        // Import paymentService dynamically if not already imported\n        const {\n          default: paymentService\n        } = await import('@/services/paymentService');\n\n        // Initiate payment through PayMongo\n        const response = await paymentService.initiatePayment(paymentData);\n        if (response.success && response.data.checkout_url) {\n          // Redirect to PayMongo checkout page\n          this.showToast('Success', 'Redirecting to payment page...', 'success');\n          paymentService.redirectToPayMongo(response.data.checkout_url);\n        } else {\n          throw new Error(response.message || 'Failed to initiate payment');\n        }\n      } catch (error) {\n        console.error('Payment initiation error:', error);\n        const errorMessage = error.response?.data?.message || error.message || 'Failed to initiate payment';\n        this.showToast('Error', errorMessage, 'error');\n      }\n    },\n    downloadDocument() {\n      // TODO: Implement document download\n      console.log('Download document for request:', this.request.id);\n    },\n    printDetails() {\n      window.print();\n    },\n    goBack() {\n      this.$router.push({\n        name: 'MyRequests'\n      });\n    },\n    // Beneficiary helper methods\n    getBeneficiaryFullName() {\n      if (!this.request?.beneficiary) return 'Not provided';\n      const b = this.request.beneficiary;\n      return `${b.first_name || ''} ${b.middle_name || ''} ${b.last_name || ''}`.trim();\n    },\n    getBeneficiaryAddress() {\n      if (!this.request?.beneficiary) return 'Not provided';\n      const b = this.request.beneficiary;\n      const parts = [b.house_number, b.street, b.subdivision, b.barangay, b.city_municipality, b.province].filter(part => part && part.trim());\n      return parts.length > 0 ? parts.join(', ') : 'Not provided';\n    },\n    async getVerificationImageUrl(imagePath) {\n      if (!imagePath) return this.getPlaceholderImageUrl();\n\n      // Extract filename from path\n      const filename = imagePath.split(/[/\\\\]/).pop();\n      const cacheKey = `beneficiary-${filename}`;\n\n      // Return cached URL if available\n      if (this.imageObjectUrls.has(cacheKey)) {\n        return this.imageObjectUrls.get(cacheKey);\n      }\n      try {\n        // Debug logging for path consistency\n        console.log('üîç Debug beneficiary verification image loading:', {\n          originalPath: imagePath,\n          extractedFilename: filename,\n          requestId: this.request.id,\n          finalApiUrl: `/client/document-requests/${this.request.id}/verification-image/beneficiary/${filename}`\n        });\n\n        // Fetch image as blob with authentication\n        const objectUrl = await documentRequestService.getVerificationImageObjectUrl(this.request.id, 'beneficiary', filename);\n\n        // Cache the object URL\n        this.imageObjectUrls.set(cacheKey, objectUrl);\n        console.log('‚úÖ Created object URL for beneficiary verification image:', filename);\n        return objectUrl;\n      } catch (error) {\n        console.error('‚ùå Failed to load beneficiary verification image:', {\n          filename,\n          imagePath,\n          requestId: this.request.id,\n          error: error.message,\n          status: error.response?.status\n        });\n\n        // Show user-friendly error messages\n        if (error.message.includes('not found')) {\n          this.showToast('Warning', 'Verification image not found on server', 'warning');\n        } else if (error.message.includes('contact support')) {\n          this.showToast('Error', 'Server error - please contact support', 'error');\n        } else {\n          this.showToast('Warning', `Failed to load verification image: ${error.message}`, 'warning');\n        }\n        return this.getPlaceholderImageUrl();\n      }\n    },\n    getVerificationStatusClass(status) {\n      const classes = {\n        'pending': 'bg-warning',\n        'approved': 'bg-success',\n        'rejected': 'bg-danger'\n      };\n      return classes[status] || 'bg-secondary';\n    },\n    formatVerificationStatus(status) {\n      const statusMap = {\n        'pending': 'Pending Verification',\n        'approved': 'Verified',\n        'rejected': 'Rejected'\n      };\n      return statusMap[status] || 'Unknown';\n    },\n    // Authorized pickup person helper methods\n    getAuthorizedPickupFullName() {\n      if (!this.request?.authorized_pickup) return 'Not provided';\n      const p = this.request.authorized_pickup;\n      return `${p.first_name || ''} ${p.middle_name || ''} ${p.last_name || ''}`.trim();\n    },\n    async getPickupIdImageUrl(imagePath) {\n      if (!imagePath) return this.getPlaceholderImageUrl();\n\n      // Extract filename from path\n      const filename = imagePath.split(/[/\\\\]/).pop();\n      const cacheKey = `pickup-id-${filename}`;\n\n      // Return cached URL if available\n      if (this.imageObjectUrls.has(cacheKey)) {\n        return this.imageObjectUrls.get(cacheKey);\n      }\n      try {\n        // Debug logging for path consistency\n        console.log('üîç Debug pickup ID image loading:', {\n          originalPath: imagePath,\n          extractedFilename: filename,\n          requestId: this.request.id,\n          finalApiUrl: `/client/document-requests/${this.request.id}/verification-image/pickup-id/${filename}`\n        });\n\n        // Fetch image as blob with authentication\n        const objectUrl = await documentRequestService.getVerificationImageObjectUrl(this.request.id, 'pickup-id', filename);\n\n        // Cache the object URL\n        this.imageObjectUrls.set(cacheKey, objectUrl);\n        console.log('‚úÖ Created object URL for pickup ID image:', filename);\n        return objectUrl;\n      } catch (error) {\n        console.error('‚ùå Failed to load pickup ID image:', {\n          filename,\n          imagePath,\n          requestId: this.request.id,\n          error: error.message,\n          status: error.response?.status\n        });\n\n        // Show user-friendly error messages\n        if (error.message.includes('not found')) {\n          this.showToast('Warning', 'ID image not found on server', 'warning');\n        } else if (error.message.includes('contact support')) {\n          this.showToast('Error', 'Server error - please contact support', 'error');\n        } else {\n          this.showToast('Warning', `Failed to load ID image: ${error.message}`, 'warning');\n        }\n        return this.getPlaceholderImageUrl();\n      }\n    },\n    async getAuthorizationLetterUrl(imagePath) {\n      if (!imagePath) return this.getPlaceholderImageUrl();\n\n      // Extract filename from path\n      const filename = imagePath.split(/[/\\\\]/).pop();\n      const cacheKey = `pickup-auth-${filename}`;\n\n      // Return cached URL if available\n      if (this.imageObjectUrls.has(cacheKey)) {\n        return this.imageObjectUrls.get(cacheKey);\n      }\n      try {\n        // Debug logging for path consistency\n        console.log('üîç Debug authorization letter loading:', {\n          originalPath: imagePath,\n          extractedFilename: filename,\n          requestId: this.request.id,\n          finalApiUrl: `/client/document-requests/${this.request.id}/verification-image/pickup-auth/${filename}`\n        });\n\n        // Fetch image as blob with authentication\n        const objectUrl = await documentRequestService.getVerificationImageObjectUrl(this.request.id, 'pickup-auth', filename);\n\n        // Cache the object URL\n        this.imageObjectUrls.set(cacheKey, objectUrl);\n        console.log('‚úÖ Created object URL for authorization letter:', filename);\n        return objectUrl;\n      } catch (error) {\n        console.error('‚ùå Failed to load authorization letter:', {\n          filename,\n          imagePath,\n          requestId: this.request.id,\n          error: error.message,\n          status: error.response?.status\n        });\n\n        // Show user-friendly error messages\n        if (error.message.includes('not found')) {\n          this.showToast('Warning', 'Authorization letter not found on server', 'warning');\n        } else if (error.message.includes('contact support')) {\n          this.showToast('Error', 'Server error - please contact support', 'error');\n        } else {\n          this.showToast('Warning', `Failed to load authorization letter: ${error.message}`, 'warning');\n        }\n        return this.getPlaceholderImageUrl();\n      }\n    },\n    getPlaceholderImageUrl() {\n      // Return a data URL for a simple placeholder image\n      return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjE1MCIgdmlld0JveD0iMCAwIDIwMCAxNTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyMDAiIGhlaWdodD0iMTUwIiBmaWxsPSIjRjNGNEY2Ii8+CjxwYXRoIGQ9Ik04NSA2MEw5NSA3MEwxMTUgNTBMMTM1IDcwTDE0NSA2MEwxNjUgODBMMTY1IDEyMEg0NVY4MEw2NSA2MEw4NSA2MFoiIGZpbGw9IiNEMUQ1REIiLz4KPGNpcmNsZSBjeD0iNzAiIGN5PSI0NSIgcj0iOCIgZmlsbD0iI0QxRDVEQiIvPgo8dGV4dCB4PSIxMDAiIHk9IjEwNSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjNkI3MjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5JbWFnZSBub3QgYXZhaWxhYmxlPC90ZXh0Pgo8L3N2Zz4K';\n    },\n    async openImageModal(imagePath, imageName, imageType = 'beneficiaries') {\n      try {\n        // Use the already loaded image URLs from the reactive data\n        let imageUrl;\n        switch (imageType) {\n          case 'pickup_id':\n          case 'pickup_ids':\n            imageUrl = this.imageUrls.pickupId;\n            break;\n          case 'pickup_authorization':\n            imageUrl = this.imageUrls.authorizationLetter;\n            break;\n          default:\n            imageUrl = this.imageUrls.beneficiaryVerification;\n        }\n\n        // If image URL is not loaded yet, try to load it\n        if (!imageUrl || imageUrl === this.getPlaceholderImageUrl()) {\n          console.log('üîÑ Image not loaded yet, attempting to load for modal...');\n          switch (imageType) {\n            case 'pickup_id':\n            case 'pickup_ids':\n              imageUrl = await this.getPickupIdImageUrl(imagePath);\n              this.imageUrls.pickupId = imageUrl;\n              break;\n            case 'pickup_authorization':\n              imageUrl = await this.getAuthorizationLetterUrl(imagePath);\n              this.imageUrls.authorizationLetter = imageUrl;\n              break;\n            default:\n              imageUrl = await this.getVerificationImageUrl(imagePath);\n              this.imageUrls.beneficiaryVerification = imageUrl;\n          }\n        }\n        if (!imageUrl || imageUrl === this.getPlaceholderImageUrl()) {\n          this.showToast('Error', 'Failed to load image', 'error');\n          return;\n        }\n\n        // Debug logging for modal image data\n        console.log('üñºÔ∏è Opening ImageViewer modal with:', {\n          imageType,\n          imageName,\n          imagePath,\n          imageUrl: imageUrl ? imageUrl.substring(0, 50) + '...' : 'none',\n          isBlobUrl: imageUrl?.startsWith('blob:'),\n          isDataUrl: imageUrl?.startsWith('data:'),\n          isPlaceholder: imageUrl === this.getPlaceholderImageUrl()\n        });\n\n        // Set data for ImageViewer component\n        this.selectedImage = {\n          url: imageUrl,\n          title: imageName || 'Document',\n          filename: imagePath ? imagePath.split(/[/\\\\]/).pop() : '',\n          type: imageType,\n          downloadUrl: imageUrl\n        };\n        this.showImageViewer = true;\n      } catch (error) {\n        console.error('Error opening image modal:', error);\n        this.showToast('Error', 'Failed to load image', 'error');\n      }\n    },\n    closeImageViewer() {\n      this.showImageViewer = false;\n      this.selectedImage = null;\n    },\n    handleImageError(event, imageType) {\n      console.error(`‚ùå Failed to load ${imageType} image:`, event.target.src);\n\n      // Hide the broken image\n      event.target.style.display = 'none';\n\n      // Show error message to user\n      const container = event.target.closest('.verification-image-container');\n      if (container && !container.querySelector('.image-error-message')) {\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'image-error-message';\n        errorDiv.innerHTML = `\n          <i class=\"fas fa-exclamation-triangle text-warning\"></i>\n          <span>Unable to load ${imageType} image</span>\n          <small class=\"d-block mt-1\">Authentication or network error</small>\n        `;\n        container.appendChild(errorDiv);\n      }\n    },\n    handleImageLoad(event, imageType) {\n      console.log(`‚úÖ Successfully loaded ${imageType} image:`, event.target.src);\n    },\n    showToast(title, message, type = 'info') {\n      // Log to console for debugging\n      console.log(`[${type.toUpperCase()}] ${title}: ${message}`);\n\n      // Create a simple toast notification\n      const toast = document.createElement('div');\n      toast.className = `toast-notification toast-${type}`;\n      toast.innerHTML = `\n        <div class=\"toast-header\">\n          <strong>${title}</strong>\n          <button type=\"button\" class=\"toast-close\" onclick=\"this.parentElement.parentElement.remove()\">√ó</button>\n        </div>\n        <div class=\"toast-body\">${message}</div>\n      `;\n\n      // Add toast styles if not already added\n      if (!document.getElementById('toast-styles')) {\n        const styles = document.createElement('style');\n        styles.id = 'toast-styles';\n        styles.textContent = `\n          .toast-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 9999;\n            animation: slideIn 0.3s ease;\n          }\n          .toast-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 16px 8px;\n            border-bottom: 1px solid #e9ecef;\n          }\n          .toast-body {\n            padding: 8px 16px 12px;\n            color: #6c757d;\n          }\n          .toast-close {\n            background: none;\n            border: none;\n            font-size: 18px;\n            cursor: pointer;\n            color: #6c757d;\n          }\n          .toast-success { border-left: 4px solid #28a745; }\n          .toast-error { border-left: 4px solid #dc3545; }\n          .toast-info { border-left: 4px solid #17a2b8; }\n          .toast-warning { border-left: 4px solid #ffc107; }\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        `;\n        document.head.appendChild(styles);\n      }\n\n      // Add toast to page\n      document.body.appendChild(toast);\n\n      // Auto-remove after 5 seconds\n      setTimeout(() => {\n        if (toast.parentElement) {\n          toast.style.animation = 'slideIn 0.3s ease reverse';\n          setTimeout(() => toast.remove(), 300);\n        }\n      }, 5000);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}