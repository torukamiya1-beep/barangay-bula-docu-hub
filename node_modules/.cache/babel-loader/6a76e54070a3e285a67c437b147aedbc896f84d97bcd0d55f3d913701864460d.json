{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { getClientNotificationService } from '../../services/notificationService';\nimport notificationNavigationService from '../../services/notificationNavigationService';\nexport default {\n  name: 'ClientNotifications',\n  emits: ['new-notification', 'notification-click', 'notification-read', 'notifications-read', 'connected', 'error'],\n  data() {\n    return {\n      showPanel: false,\n      notifications: [],\n      unreadCount: 0,\n      loading: false,\n      loadingMore: false,\n      markingAllRead: false,\n      error: null,\n      currentPage: 1,\n      hasMore: true,\n      pageSize: 20,\n      notificationService: null // Store the client-specific service instance\n    };\n  },\n  async mounted() {\n    await this.initializeNotifications();\n\n    // Close panel when clicking outside\n    document.addEventListener('click', this.handleOutsideClick);\n  },\n  beforeUnmount() {\n    // Clean up event listeners\n    document.removeEventListener('click', this.handleOutsideClick);\n\n    // Remove notification service listeners\n    if (this.notificationService) {\n      this.notificationService.off('notification', this.handleNewNotification);\n      this.notificationService.off('connected', this.onConnected);\n      this.notificationService.off('error', this.onError);\n    }\n  },\n  methods: {\n    async initializeNotifications() {\n      try {\n        console.log('üöÄ ClientNotifications: Initializing client notification service');\n\n        // Get the client-specific notification service\n        this.notificationService = getClientNotificationService();\n\n        // Request notification permission\n        await this.notificationService.requestNotificationPermission();\n\n        // Initialize the client notification service\n        await this.notificationService.init();\n\n        // Set up event listeners\n        this.notificationService.on('notification', this.handleNewNotification);\n        this.notificationService.on('connected', this.onConnected);\n        this.notificationService.on('error', this.onError);\n\n        // Load initial data\n        await this.loadUnreadCount();\n        console.log('‚úÖ ClientNotifications: Client notification service initialized successfully');\n      } catch (error) {\n        console.error('‚ùå ClientNotifications: Failed to initialize client notifications:', error);\n        this.error = error.message || 'Failed to connect to notification service';\n      }\n    },\n    toggleNotificationPanel() {\n      this.showPanel = !this.showPanel;\n      if (this.showPanel && this.notifications.length === 0) {\n        this.loadNotifications(1);\n      }\n    },\n    handleOutsideClick(event) {\n      if (!event.target.closest('.client-notifications')) {\n        this.showPanel = false;\n      }\n    },\n    async loadNotifications(page = 1) {\n      try {\n        if (page === 1) {\n          this.loading = true;\n          this.error = null;\n        } else {\n          this.loadingMore = true;\n        }\n        const response = await this.notificationService.getNotifications(page, this.pageSize);\n        console.log('Notifications response:', response);\n\n        // Handle the correct response structure from backend\n        let notifications = [];\n        let pagination = {};\n        if (response.data && response.data.notifications) {\n          // Backend returns: { success: true, data: { notifications: [...], pagination: {...} } }\n          if (Array.isArray(response.data.notifications)) {\n            notifications = response.data.notifications;\n            pagination = response.data.pagination || {};\n          }\n        }\n        if (page === 1) {\n          this.notifications = notifications;\n        } else {\n          this.notifications.push(...notifications);\n        }\n        this.currentPage = page;\n        this.hasMore = pagination.page < pagination.pages;\n        console.log('Loaded notifications:', this.notifications);\n      } catch (error) {\n        console.error('Failed to load notifications:', error);\n        this.error = 'Failed to load notifications';\n      } finally {\n        this.loading = false;\n        this.loadingMore = false;\n      }\n    },\n    async loadMore() {\n      if (this.hasMore && !this.loadingMore) {\n        await this.loadNotifications(this.currentPage + 1);\n      }\n    },\n    async loadUnreadCount() {\n      try {\n        this.unreadCount = await this.notificationService.getUnreadCount();\n      } catch (error) {\n        console.error('Failed to load unread count:', error);\n      }\n    },\n    async markAllAsRead() {\n      try {\n        this.markingAllRead = true;\n        await this.notificationService.markAllAsRead();\n\n        // Update local state\n        this.notifications.forEach(notification => {\n          notification.is_read = true;\n        });\n        this.unreadCount = 0;\n        this.$emit('notifications-read');\n      } catch (error) {\n        console.error('Failed to mark all as read:', error);\n        this.$emit('error', 'Failed to mark notifications as read');\n      } finally {\n        this.markingAllRead = false;\n      }\n    },\n    async handleNotificationClick(notification) {\n      console.log('üîî Client notification clicked:', notification);\n\n      // Ensure we have a valid notification object with an ID\n      if (!notification || !notification.id) {\n        console.error('Invalid notification object:', notification);\n        return;\n      }\n\n      // Show loading state\n      this.showLoadingState(notification);\n      try {\n        // Mark as read if not already read\n        if (!notification.is_read) {\n          await this.notificationService.markAsRead(notification.id);\n          notification.is_read = true;\n          this.unreadCount = Math.max(0, this.unreadCount - 1);\n          this.$emit('notification-read', notification);\n        }\n\n        // Navigate based on notification type and data\n        await this.navigateToRelevantPage(notification);\n\n        // Close notification panel after successful navigation\n        this.showPanel = false;\n      } catch (error) {\n        console.error('‚ùå Failed to handle notification click:', error);\n        this.showErrorToast('Failed to process notification');\n      } finally {\n        this.hideLoadingState(notification);\n      }\n\n      // Emit click event for parent components to handle\n      this.$emit('notification-click', notification);\n    },\n    /**\n     * Navigate to the relevant page based on notification type and data\n     */\n    async navigateToRelevantPage(notification) {\n      console.log('üß≠ Determining navigation for notification:', notification.type, notification.data);\n      try {\n        const notificationData = typeof notification.data === 'string' ? JSON.parse(notification.data) : notification.data || {};\n        let targetRoute = null;\n        switch (notification.type) {\n          case 'status_change':\n          case 'request_update':\n            targetRoute = await this.handleRequestUpdateNavigation(notificationData);\n            break;\n          case 'payment_confirmed':\n          case 'payment_required':\n          case 'payment_update':\n            targetRoute = await this.handlePaymentNavigation(notificationData);\n            break;\n          case 'document_ready':\n          case 'ready_for_pickup':\n            targetRoute = await this.handleDocumentReadyNavigation(notificationData);\n            break;\n          case 'request_approved':\n          case 'request_rejected':\n            targetRoute = await this.handleRequestStatusNavigation(notificationData);\n            break;\n          case 'system_alert':\n          case 'maintenance_notice':\n            targetRoute = await this.handleSystemAlertNavigation(notificationData);\n            break;\n          default:\n            console.log('ü§∑ Unknown notification type, using default navigation');\n            targetRoute = await this.handleDefaultNavigation(notificationData);\n        }\n        if (targetRoute) {\n          console.log('üöÄ Navigating to:', targetRoute);\n\n          // Add timeout to prevent hanging navigation\n          const navigationPromise = this.$router.push(targetRoute);\n          const timeoutPromise = new Promise((_, reject) => {\n            setTimeout(() => reject(new Error('Navigation timeout')), 5000);\n          });\n          await Promise.race([navigationPromise, timeoutPromise]);\n        } else {\n          console.log('‚ÑπÔ∏è No navigation target determined for notification');\n        }\n      } catch (error) {\n        console.error('‚ùå Navigation error:', error);\n        throw new Error('Failed to navigate to notification target');\n      }\n    },\n    /**\n     * Handle navigation for request update notifications\n     */\n    async handleRequestUpdateNavigation(data) {\n      if (data.request_id) {\n        // Check if request still exists\n        const exists = await this.checkRequestExists(data.request_id);\n        if (exists) {\n          return {\n            name: 'RequestDetails',\n            params: {\n              id: data.request_id\n            }\n          };\n        } else {\n          this.showErrorToast('Request no longer exists');\n          return {\n            name: 'MyRequests'\n          };\n        }\n      }\n      return {\n        name: 'MyRequests'\n      };\n    },\n    /**\n     * Handle navigation for payment-related notifications\n     */\n    async handlePaymentNavigation(data) {\n      if (data.request_id) {\n        const exists = await this.checkRequestExists(data.request_id);\n        if (exists) {\n          return {\n            name: 'RequestDetails',\n            params: {\n              id: data.request_id\n            },\n            query: {\n              tab: 'payment'\n            } // Focus on payment section\n          };\n        }\n      }\n      // Fallback to requests page with payment filter\n      return {\n        name: 'MyRequests',\n        query: {\n          filter: 'payment_required'\n        }\n      };\n    },\n    /**\n     * Handle navigation for document ready notifications\n     */\n    async handleDocumentReadyNavigation(data) {\n      if (data.request_id) {\n        const exists = await this.checkRequestExists(data.request_id);\n        if (exists) {\n          return {\n            name: 'RequestDetails',\n            params: {\n              id: data.request_id\n            },\n            query: {\n              tab: 'status'\n            } // Focus on status/pickup info\n          };\n        }\n      }\n      // Fallback to requests page with ready filter\n      return {\n        name: 'MyRequests',\n        query: {\n          filter: 'ready'\n        }\n      };\n    },\n    /**\n     * Handle navigation for request status change notifications\n     */\n    async handleRequestStatusNavigation(data) {\n      if (data.request_id) {\n        const exists = await this.checkRequestExists(data.request_id);\n        if (exists) {\n          return {\n            name: 'RequestDetails',\n            params: {\n              id: data.request_id\n            }\n          };\n        }\n      }\n      return {\n        name: 'MyRequests'\n      };\n    },\n    /**\n     * Handle navigation for system alerts\n     */\n    async handleSystemAlertNavigation(data) {\n      // For system alerts, usually go to dashboard or help page\n      if (data.help_section) {\n        return {\n          name: 'HelpSupport',\n          query: {\n            section: data.help_section\n          }\n        };\n      }\n      return {\n        name: 'ClientDashboard'\n      };\n    },\n    /**\n     * Handle default navigation when type is unknown\n     */\n    async handleDefaultNavigation(data) {\n      // Priority order: request_id > dashboard\n      if (data.request_id) {\n        const exists = await this.checkRequestExists(data.request_id);\n        if (exists) {\n          return {\n            name: 'RequestDetails',\n            params: {\n              id: data.request_id\n            }\n          };\n        }\n      }\n      return {\n        name: 'ClientDashboard'\n      };\n    },\n    /**\n     * Check if a request still exists and belongs to the current user\n     */\n    async checkRequestExists(requestId) {\n      return await notificationNavigationService.checkRequestExists(requestId, 'client');\n    },\n    /**\n     * Show loading state for a notification\n     */\n    showLoadingState(notification) {\n      // Add loading class to notification item\n      const notificationElement = document.querySelector(`[data-notification-id=\"${notification.id}\"]`);\n      if (notificationElement) {\n        notificationElement.classList.add('loading');\n      }\n    },\n    /**\n     * Hide loading state for a notification\n     */\n    hideLoadingState(notification) {\n      const notificationElement = document.querySelector(`[data-notification-id=\"${notification.id}\"]`);\n      if (notificationElement) {\n        notificationElement.classList.remove('loading');\n      }\n    },\n    /**\n     * Show error toast message\n     */\n    showErrorToast(message) {\n      notificationNavigationService.showNavigationError(message, this.$emit.bind(this));\n    },\n    handleNewNotification(notification, context = null) {\n      // Validate this is a client notification\n      if (context && context.userType && context.userType !== 'client') {\n        console.log('üö´ ClientNotifications: Ignoring non-client notification:', context.userType);\n        return;\n      }\n\n      // Additional validation: check notification recipient type\n      if (notification.recipient_type && notification.recipient_type !== 'client') {\n        console.log('üö´ ClientNotifications: Ignoring notification for:', notification.recipient_type);\n        return;\n      }\n      console.log('üì¢ ClientNotifications: Processing client notification:', notification);\n\n      // Handle unread count updates from polling\n      if (notification.type === 'unread_count_update') {\n        this.unreadCount = notification.count || 0;\n        return;\n      }\n\n      // Handle notification read status updates\n      if (notification.type === 'notification_read') {\n        const notificationIndex = this.notifications.findIndex(n => n.id === notification.notification_id);\n        if (notificationIndex !== -1) {\n          this.notifications[notificationIndex].is_read = true;\n          this.unreadCount = Math.max(0, this.unreadCount - 1);\n        }\n        return;\n      }\n\n      // Handle all notifications marked as read\n      if (notification.type === 'all_notifications_read') {\n        this.notifications.forEach(n => n.is_read = true);\n        this.unreadCount = 0;\n        return;\n      }\n\n      // Add to beginning of list if panel is open\n      if (this.showPanel) {\n        this.notifications.unshift(notification);\n      }\n\n      // Update unread count for new notifications\n      if (!notification.is_read) {\n        this.unreadCount++;\n      }\n\n      // Emit event for parent components\n      this.$emit('new-notification', notification);\n    },\n    onConnected() {\n      console.log('Connected to client notification stream');\n      this.$emit('connected');\n    },\n    onError(error) {\n      console.error('Client notification stream error:', error);\n      this.$emit('error', 'Connection to notification stream failed');\n    },\n    getNotificationIcon(type) {\n      const icons = {\n        'status_change': 'fas fa-sync-alt text-info',\n        'payment_confirmed': 'fas fa-credit-card text-success',\n        'document_ready': 'fas fa-file-check text-success',\n        'request_update': 'fas fa-edit text-warning',\n        'system_alert': 'fas fa-exclamation-triangle text-danger',\n        'test': 'fas fa-vial text-secondary',\n        'connection': 'fas fa-plug text-success'\n      };\n      return icons[type] || 'fas fa-bell text-primary';\n    },\n    formatTime(timestamp) {\n      if (!timestamp) return '';\n      const date = new Date(timestamp);\n      const now = new Date();\n      const diffInMinutes = Math.floor((now - date) / (1000 * 60));\n      if (diffInMinutes < 1) return 'Just now';\n      if (diffInMinutes < 60) return `${diffInMinutes}m ago`;\n      const diffInHours = Math.floor(diffInMinutes / 60);\n      if (diffInHours < 24) return `${diffInHours}h ago`;\n      const diffInDays = Math.floor(diffInHours / 24);\n      if (diffInDays < 7) return `${diffInDays}d ago`;\n      return date.toLocaleDateString();\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}