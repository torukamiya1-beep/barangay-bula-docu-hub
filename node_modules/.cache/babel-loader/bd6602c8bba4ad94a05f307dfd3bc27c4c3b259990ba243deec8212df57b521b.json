{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport axios from 'axios';\n\n/**\n * Context-Specific Notification Service\n * Each instance is tied to a specific user type (admin or client)\n */\nclass ContextualNotificationService {\n  constructor(userType) {\n    this.userType = userType;\n    this.eventSource = null;\n    this.listeners = new Map();\n    this.userContexts = new Map(); // Initialize userContexts Map\n    this.activeContext = null;\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.maxReconnectDelay = 30000;\n    this.baseURL = process.env.VUE_APP_API_URL || 'http://localhost:7000/api';\n    this.isConnecting = false;\n    this.pollingInterval = null;\n    this.reconnectTimer = null;\n    console.log(`üîî Creating ${userType} notification service instance`);\n  }\n\n  /**\n   * Validate that this service can operate for its user type\n   */\n  validateContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      throw new Error('Authentication required');\n    }\n    try {\n      const user = JSON.parse(userData);\n      if (this.userType === 'admin') {\n        if (user.type !== 'admin') {\n          throw new Error('Admin authentication required');\n        }\n        return true;\n      }\n      if (this.userType === 'client') {\n        if (user.type !== 'client') {\n          throw new Error('Client authentication required');\n        }\n        return true;\n      }\n    } catch (error) {\n      throw new Error('Invalid user data format');\n    }\n    throw new Error(`Invalid user type: ${this.userType}`);\n  }\n\n  /**\n   * Get authentication token for this user type\n   */\n  getAuthToken() {\n    return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n  }\n\n  /**\n   * Initialize the notification service for this specific user type\n   */\n  async init() {\n    console.log(`üöÄ Initializing ${this.userType} notification service`);\n    try {\n      // Validate context before proceeding\n      this.validateContext();\n\n      // Initialize user context if not exists\n      if (!this.userContexts.has(this.userType)) {\n        this.userContexts.set(this.userType, {\n          isConnected: false,\n          listeners: new Map(),\n          eventSource: null\n        });\n      }\n\n      // Set active context\n      this.activeContext = this.userType;\n\n      // Connect to notification stream\n      await this.connect();\n      console.log(`‚úÖ ${this.userType} notification service initialized successfully`);\n      return Promise.resolve();\n    } catch (error) {\n      console.error(`‚ùå Failed to initialize ${this.userType} notification service:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect current user context based on authentication state\n   */\n  detectUserContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      console.log('üîç No authentication found');\n      return null;\n    }\n    try {\n      const user = JSON.parse(userData);\n      if (user && user.type) {\n        console.log('üîç Detected user context:', user.type);\n        return user.type;\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Invalid user data in localStorage:', error);\n    }\n    console.log('üîç No valid user context detected');\n    return null;\n  }\n\n  /**\n   * Validate user context against authentication state\n   */\n  validateUserContext(userType) {\n    if (!userType || !['admin', 'client'].includes(userType)) {\n      return false;\n    }\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      return false;\n    }\n    try {\n      const user = JSON.parse(userData);\n      return user && user.type === userType;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Switch active user context\n   */\n  switchContext(userType) {\n    if (!this.validateUserContext(userType)) {\n      console.warn('‚ö†Ô∏è Cannot switch to invalid user context:', userType);\n      return false;\n    }\n    const previousContext = this.activeContext;\n    this.activeContext = userType;\n    this.currentUserType = userType;\n    console.log('üîÑ Context switched:', {\n      from: previousContext,\n      to: userType\n    });\n\n    // Emit context change event\n    this.emit('context_changed', {\n      previousContext,\n      currentContext: userType\n    });\n    return true;\n  }\n\n  /**\n   * Get current active context\n   */\n  getCurrentContext() {\n    return this.activeContext;\n  }\n\n  /**\n   * Check if a specific user context is connected\n   */\n  isContextConnected(userType) {\n    const context = this.userContexts.get(userType);\n    return context ? context.isConnected : false;\n  }\n\n  /**\n   * Get all available contexts\n   */\n  getAvailableContexts() {\n    const contexts = [];\n    if (this.validateUserContext('admin')) {\n      contexts.push({\n        type: 'admin',\n        connected: this.isContextConnected('admin'),\n        active: this.activeContext === 'admin'\n      });\n    }\n    if (this.validateUserContext('client')) {\n      contexts.push({\n        type: 'client',\n        connected: this.isContextConnected('client'),\n        active: this.activeContext === 'client'\n      });\n    }\n    return contexts;\n  }\n\n  /**\n   * Handle authentication state changes and auto-switch context\n   */\n  handleAuthStateChange() {\n    const detectedContext = this.detectUserContext();\n    if (!detectedContext) {\n      console.log('üîí No valid authentication detected, cleaning up all contexts');\n      this.cleanup('admin');\n      this.cleanup('client');\n      this.activeContext = null;\n      this.currentUserType = null;\n      return;\n    }\n\n    // If detected context is different from active context, switch\n    if (detectedContext !== this.activeContext) {\n      console.log('üîÑ Authentication state changed, switching context:', {\n        from: this.activeContext,\n        to: detectedContext\n      });\n      this.switchContext(detectedContext);\n    }\n  }\n\n  /**\n   * Start monitoring authentication state changes\n   */\n  startAuthStateMonitoring() {\n    // Monitor localStorage changes for token updates\n    window.addEventListener('storage', event => {\n      if (event.key === 'adminToken' || event.key === 'clientToken' || event.key === 'adminData' || event.key === 'clientData') {\n        console.log('üîç Authentication storage changed:', event.key);\n        setTimeout(() => this.handleAuthStateChange(), 100);\n      }\n    });\n\n    // Also monitor for direct localStorage changes in the same tab\n    const originalSetItem = localStorage.setItem;\n    localStorage.setItem = function (key, value) {\n      originalSetItem.call(this, key, value);\n      if (key === 'adminToken' || key === 'clientToken' || key === 'adminData' || key === 'clientData') {\n        setTimeout(() => {\n          if (window.__notificationServiceInstance) {\n            window.__notificationServiceInstance.handleAuthStateChange();\n          }\n        }, 100);\n      }\n    };\n  }\n\n  /**\n   * Cleanup with context awareness\n   */\n  cleanup(userType = null) {\n    if (userType) {\n      // Clean up specific context\n      const context = this.userContexts.get(userType);\n      if (context) {\n        console.log('üßπ Cleaning up context:', userType);\n\n        // Clean up event source\n        if (context.eventSource) {\n          context.eventSource.close();\n          context.eventSource = null;\n        }\n\n        // Clear context data\n        context.isConnected = false;\n        context.listeners.clear();\n\n        // Remove global reference\n        if (window[`__sseConnection_${userType}`]) {\n          delete window[`__sseConnection_${userType}`];\n        }\n      }\n    } else {\n      console.log('üßπ General notification service cleanup');\n      // Don't disconnect - let connections persist for context switching\n    }\n  }\n\n  /**\n   * Connect to SSE stream for this specific user type\n   */\n  connect() {\n    // Prevent multiple connections\n    if (this.isConnected || this.isConnecting || this.eventSource) {\n      console.log(`üîó ${this.userType} notification service already connected`);\n      return Promise.resolve();\n    }\n    this.isConnecting = true;\n    console.log(`üîó Establishing SSE connection for ${this.userType}`);\n    return new Promise((resolve, reject) => {\n      try {\n        // Validate context and get token\n        this.validateContext();\n        const token = this.getAuthToken();\n        if (!token) {\n          this.isConnecting = false;\n          reject(new Error(`No authentication token for ${this.userType}`));\n          return;\n        }\n\n        // Create EventSource with proper URL\n        const url = `${this.baseURL}/notifications/stream?token=${encodeURIComponent(token)}`;\n        console.log(`üîó SSE URL for ${this.userType}:`, url.replace(/token=[^&]+/, 'token=***'));\n        this.eventSource = new EventSource(url);\n\n        // Store reference with user-specific key to prevent conflicts\n        window[`__sseConnection_${this.userType}`] = this.eventSource;\n\n        // Event handlers for this specific user type\n        this.eventSource.onopen = () => {\n          console.log(`‚úÖ SSE Connection established for ${this.userType}`);\n          this.isConnected = true;\n          this.isConnecting = false;\n          this.reconnectAttempts = 0;\n          this.emit('connected');\n          resolve();\n        };\n        this.eventSource.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            console.log(`üì® SSE Message for ${this.userType}:`, data);\n\n            // CRITICAL: Only process notifications intended for this user type\n            if (data.recipient_type && data.recipient_type !== this.userType) {\n              console.log(`üö´ ${this.userType} service ignoring ${data.recipient_type} notification:`, data.id);\n              return;\n            }\n            this.handleNotification(data);\n          } catch (error) {\n            console.error(`‚ùå ${this.userType} SSE message parse error:`, error);\n          }\n        };\n\n        // Handle specific event types\n        this.eventSource.addEventListener('connected', () => {\n          console.log(`üéØ Connected event received for ${this.userType}`);\n        });\n        this.eventSource.addEventListener('heartbeat', () => {\n          console.log(`üíì Heartbeat received for ${this.userType}`);\n        });\n        this.eventSource.onerror = event => {\n          console.error(`‚ùå SSE Error for ${this.userType}:`, event);\n          this.isConnected = false;\n          this.isConnecting = false;\n\n          // Handle different error states\n          if (this.eventSource.readyState === EventSource.CLOSED) {\n            console.log(`üîå SSE Connection closed by server for ${this.userType}`);\n            this.emit('disconnected');\n          } else if (this.eventSource.readyState === EventSource.CONNECTING) {\n            console.log(`üîÑ SSE Reconnecting for ${this.userType}`);\n          }\n\n          // Auto-reconnect with exponential backoff\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          } else {\n            console.error(`üö´ Max reconnection attempts reached for ${this.userType}`);\n            this.emit('max_reconnect_attempts');\n            reject(new Error(`Max reconnection attempts reached for ${this.userType}`));\n          }\n        };\n      } catch (error) {\n        console.error('Failed to create SSE connection:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Poll for new notifications and updates\n   */\n  async pollNotifications(userType = 'admin') {\n    try {\n      const token = userType === 'admin' ? localStorage.getItem('adminToken') : localStorage.getItem('clientToken');\n      if (!token) return;\n\n      // Get unread count\n      const response = await fetch(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const count = data.data?.count || data.count || 0;\n\n        // Only emit if count changed or every 10th poll\n        if (!this.lastCount || this.lastCount !== count || this.pollCount % 10 === 0) {\n          this.emit('notification', {\n            type: 'unread_count_update',\n            count: count,\n            timestamp: new Date().toISOString()\n          });\n          this.lastCount = count;\n        }\n        this.pollCount = (this.pollCount || 0) + 1;\n      }\n    } catch (error) {\n      console.error('Failed to poll notifications:', error);\n    }\n  }\n\n  /**\n   * Disconnect from SSE (Google/Mozilla standard)\n   */\n  disconnect() {\n    console.log('üîå Disconnecting SSE connection');\n    this.isConnected = false;\n    this.isConnecting = false;\n\n    // Clear any reconnection timers\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    // Close EventSource properly\n    if (this.eventSource) {\n      console.log('üîå Closing EventSource');\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n\n    // Clear global references\n    if (window.__sseConnection) {\n      delete window.__sseConnection;\n    }\n    if (window.__notificationEventSource) {\n      delete window.__notificationEventSource;\n    }\n\n    // Clean up any polling fallback\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = null;\n    }\n    console.log('‚úÖ SSE Disconnected cleanly');\n    this.emit('disconnected');\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff and user context awareness\n   */\n  scheduleReconnect(userType = null) {\n    const contextType = userType || this.currentUserType || this.detectUserContext();\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('üö´ Max reconnection attempts reached for:', contextType);\n      this.emit('max_reconnect_attempts', {\n        userType: contextType\n      });\n      return;\n    }\n    this.reconnectAttempts++;\n\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s\n    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);\n    console.log(`üîÑ Scheduling reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType} in ${delay}ms`);\n    this.reconnectTimer = setTimeout(() => {\n      const context = this.userContexts.get(contextType);\n      if (context && !context.isConnected && !this.isConnecting) {\n        console.log(`üîÑ Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType}`);\n        this.connect(contextType).catch(error => {\n          console.error('Reconnection failed for', contextType, ':', error);\n        });\n      }\n    }, delay);\n  }\n\n  /**\n   * Handle incoming notification for this specific user type\n   */\n  handleNotification(notification) {\n    console.log(`üì¢ ${this.userType} service processing notification:`, notification);\n\n    // Double-check recipient type (should already be filtered in onmessage)\n    if (notification.recipient_type && notification.recipient_type !== this.userType) {\n      console.warn(`üö´ ${this.userType} service received wrong notification type:`, notification.recipient_type);\n      return;\n    }\n\n    // Emit to specific type listeners\n    this.emit(notification.type, notification);\n\n    // Emit to general notification listeners\n    this.emit('notification', notification);\n\n    // Show browser notification if permission granted\n    this.showBrowserNotification(notification);\n  }\n\n  /**\n   * Show browser notification\n   */\n  showBrowserNotification(notification) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const options = {\n        body: notification.message,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: `notification-${notification.id}`,\n        requireInteraction: notification.priority === 'high' || notification.priority === 'urgent'\n      };\n      const browserNotification = new Notification(notification.title, options);\n      browserNotification.onclick = () => {\n        window.focus();\n        this.emit('notification_click', notification);\n        browserNotification.close();\n      };\n\n      // Auto close after 5 seconds for normal priority\n      if (notification.priority !== 'high' && notification.priority !== 'urgent') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n    }\n  }\n\n  /**\n   * Request browser notification permission\n   */\n  async requestNotificationPermission() {\n    if ('Notification' in window) {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  /**\n   * Subscribe to notification events (context-aware)\n   */\n  on(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Use global listeners for backward compatibility\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n\n    // Also store in context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (!context.listeners.has(event)) {\n        context.listeners.set(event, new Set());\n      }\n      context.listeners.get(event).add(callback);\n      console.log('üìù Event listener registered for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Unsubscribe from notification events (context-aware)\n   */\n  off(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Remove from global listeners\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n\n    // Remove from context-specific listeners\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (context.listeners.has(event)) {\n        context.listeners.get(event).delete(callback);\n      }\n      console.log('üóëÔ∏è Event listener removed for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Emit event to listeners (context-aware)\n   */\n  emit(event, data = null, context = null) {\n    const contextType = context?.userType || this.activeContext;\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Always emit to global listeners for backward compatibility\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data, context);\n        } catch (error) {\n          console.error(`Error in global notification listener for ${event}:`, error);\n        }\n      });\n    }\n\n    // Also emit to context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const userContext = this.userContexts.get(contextType);\n      if (userContext.listeners.has(event)) {\n        userContext.listeners.get(event).forEach(callback => {\n          try {\n            callback(data, context);\n          } catch (error) {\n            console.error(`Error in ${contextType} notification listener for ${event}:`, error);\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Get notifications for this specific user type\n   */\n  async getNotifications(page = 1, limit = 20, unreadOnly = false) {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      console.log(`üîç Getting notifications for ${this.userType}:`, {\n        page,\n        limit,\n        unread_only: unreadOnly\n      });\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      const response = await axios.get(`${this.baseURL}/notifications`, {\n        params: {\n          page,\n          limit,\n          unread_only: unreadOnly\n        },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      console.log(`‚úÖ ${this.userType} notifications retrieved:`, response.data);\n      return response.data;\n    } catch (error) {\n      console.error(`‚ùå Failed to get ${this.userType} notifications:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get unread notification count for this specific user type\n   */\n  async getUnreadCount() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      console.log(`üîç Getting unread count for ${this.userType}`);\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      const response = await axios.get(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      console.log(`‚úÖ ${this.userType} unread count response:`, response.data);\n\n      // Handle different response formats\n      let count = 0;\n      if (response.data && response.data.data && typeof response.data.data.count !== 'undefined') {\n        count = response.data.data.count;\n        console.log('üìä NotificationService: Found count in data.data.count:', count);\n      } else if (response.data && typeof response.data.count !== 'undefined') {\n        count = response.data.count;\n        console.log('üìä NotificationService: Found count in data.count:', count);\n      } else {\n        count = 0;\n        console.log('‚ö†Ô∏è NotificationService: No count found, defaulting to 0');\n      }\n      return count;\n    } catch (error) {\n      console.error('‚ùå NotificationService: Failed to get unread count:', error);\n      if (error.response) {\n        console.error('üìä NotificationService: Error response status:', error.response.status);\n        console.error('üìä NotificationService: Error response data:', error.response.data);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Mark notification as read for this specific user type\n   */\n  async markAsRead(notificationId) {\n    try {\n      if (!notificationId || notificationId === 'undefined') {\n        throw new Error('Invalid notification ID provided');\n      }\n      this.validateContext();\n      const token = this.getAuthToken();\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      console.log(`Marking notification as read for ${this.userType}:`, notificationId);\n      const response = await axios.put(`${this.baseURL}/notifications/${notificationId}/read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark ${this.userType} notification as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark all notifications as read for this specific user type\n   */\n  async markAllAsRead() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      console.log(`Marking all notifications as read for ${this.userType}`);\n      const response = await axios.put(`${this.baseURL}/notifications/mark-all-read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark all ${this.userType} notifications as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send test notification (admin only)\n   */\n  async sendTestNotification(data) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.post(`${this.baseURL}/notifications/test`, data, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to send test notification:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification statistics (admin only)\n   */\n  async getStatistics() {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.get(`${this.baseURL}/notifications/statistics`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get notification statistics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test SSE connection (for debugging)\n   */\n  async testConnection() {\n    console.log('üß™ Testing SSE connection...');\n    try {\n      // Clear any existing connection\n      if (this.eventSource) {\n        console.log('üß™ Clearing existing connection');\n        this.eventSource.close();\n        this.eventSource = null;\n        this.isConnected = false;\n        this.isConnecting = false;\n      }\n\n      // Reset state\n      this.connectionRefs = 1;\n\n      // Test connection\n      await this.connect('admin');\n      console.log('üß™ Test connection established');\n\n      // Keep connection alive for 10 seconds\n      setTimeout(() => {\n        console.log('üß™ Test completed, keeping connection');\n      }, 10000);\n    } catch (error) {\n      console.error('üß™ Test connection failed:', error);\n    }\n  }\n\n  /**\n   * Clean up old notifications (admin only)\n   */\n  async cleanupOldNotifications(days = 90) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.delete(`${this.baseURL}/notifications/cleanup`, {\n        params: {\n          days\n        },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to cleanup old notifications:', error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Factory function to create context-specific notification services\n */\nfunction createNotificationService(userType) {\n  if (!userType || !['admin', 'client'].includes(userType)) {\n    throw new Error(`Invalid user type: ${userType}. Must be 'admin' or 'client'`);\n  }\n  return new ContextualNotificationService(userType);\n}\n\n/**\n * Global service instances (created on demand)\n */\nlet adminNotificationService = null;\nlet clientNotificationService = null;\n\n/**\n * Get or create admin notification service\n */\nfunction getAdminNotificationService() {\n  if (!adminNotificationService) {\n    adminNotificationService = createNotificationService('admin');\n    window.__adminNotificationService = adminNotificationService;\n  }\n  return adminNotificationService;\n}\n\n/**\n * Get or create client notification service\n */\nfunction getClientNotificationService() {\n  if (!clientNotificationService) {\n    clientNotificationService = createNotificationService('client');\n    window.__clientNotificationService = clientNotificationService;\n  }\n  return clientNotificationService;\n}\n\n/**\n * Legacy compatibility - returns service based on current auth state\n */\nfunction getLegacyNotificationService() {\n  const adminToken = localStorage.getItem('adminToken');\n  const clientToken = localStorage.getItem('clientToken');\n\n  // Prioritize admin if both are present\n  if (adminToken) {\n    return getAdminNotificationService();\n  }\n  if (clientToken) {\n    return getClientNotificationService();\n  }\n\n  // Default to admin for backward compatibility\n  return getAdminNotificationService();\n}\n\n// Export the factory and getters\nexport { createNotificationService, getAdminNotificationService, getClientNotificationService, ContextualNotificationService };\n\n// Default export for backward compatibility\nexport default getLegacyNotificationService();\n\n// Make services available globally for debugging\nwindow.__createNotificationService = createNotificationService;\nwindow.__getAdminNotificationService = getAdminNotificationService;\nwindow.__getClientNotificationService = getClientNotificationService;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}