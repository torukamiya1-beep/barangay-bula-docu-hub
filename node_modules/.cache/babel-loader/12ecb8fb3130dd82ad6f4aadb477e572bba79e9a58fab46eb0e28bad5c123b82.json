{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport AdminHeader from './AdminHeader.vue';\nimport AdminSidebar from './AdminSidebar.vue';\nimport AuthorizedPickupDocumentsModal from './AuthorizedPickupDocumentsModal.vue';\nimport unifiedAuthService from '@/services/unifiedAuthService';\nimport adminDocumentService from '@/services/adminDocumentService';\nimport api from '@/services/api';\nimport { Modal } from 'bootstrap';\nimport notificationService from '@/services/notificationService';\nimport * as XLSX from 'xlsx';\nimport jsPDF from 'jspdf';\nimport 'jspdf-autotable';\nexport default {\n  name: 'AdminRequests',\n  components: {\n    AdminHeader,\n    AdminSidebar,\n    AuthorizedPickupDocumentsModal\n  },\n  data() {\n    return {\n      // UI State\n      loading: true,\n      sidebarCollapsed: false,\n      showUserDropdown: false,\n      isMobile: false,\n      adminData: null,\n      errorMessage: '',\n      viewMode: 'table',\n      // 'card' or 'table' - default to table view\n\n      // Request Management Data\n      requests: [],\n      selectedRequests: [],\n      currentRequest: null,\n      statusOptions: [],\n      // All status options (for transitions)\n      filterStatusOptions: [],\n      // Filtered status options (for filter dropdown)\n      selectedRequestForPickup: null,\n      processingPickupAction: false,\n      // Pagination\n      pagination: {\n        currentPage: 1,\n        totalPages: 1,\n        totalItems: 0,\n        itemsPerPage: 10\n      },\n      // Filters\n      filters: {\n        status: '',\n        document_type: '',\n        priority: '',\n        search: '',\n        date_from: '',\n        date_to: ''\n      },\n      // Statistics\n      requestStats: {\n        total: 0,\n        pending: 0,\n        approved: 0,\n        completed: 0,\n        thisMonth: 0\n      },\n      // Document Types and Status Options\n      documentTypes: [],\n      searchTimeout: null,\n      // UI State\n      showFilters: false,\n      showBulkActions: false,\n      showRequestDetails: false,\n      showRejectForm: false,\n      showQuickReject: false,\n      showQuickApprove: false,\n      // Verification Modal\n      currentVerification: null,\n      verificationForm: {\n        status: 'pending',\n        notes: ''\n      },\n      showImageModal: false,\n      selectedImage: null,\n      bulkAction: '',\n      documentUrls: {},\n      // Store blob URLs for documents\n      loadingDocuments: new Set(),\n      // Track which documents are currently loading\n      failedDocuments: new Set(),\n      // Track which documents failed to load\n      imageLoadingInModal: false,\n      // Track if modal image is loading\n      modalImageError: false,\n      // Track if modal image failed\n\n      // Status Update Forms\n      statusUpdateForm: {\n        status_id: ''\n      },\n      rejectForm: {\n        reason: ''\n      },\n      quickRejectForm: {\n        loading: false,\n        error: ''\n      },\n      selectedRequestForReject: null,\n      quickApproveForm: {\n        loading: false,\n        error: ''\n      },\n      selectedRequestForApprove: null,\n      // Payment verification form\n      paymentVerificationForm: {\n        amount_received: '',\n        receipt_number: '',\n        loading: false,\n        error: ''\n      },\n      // Pickup scheduling form\n      pickupScheduleForm: {\n        scheduled_date: '',\n        scheduled_time_start: '',\n        scheduled_time_end: '',\n        loading: false,\n        error: ''\n      },\n      // Real-time features\n      refreshInterval: null,\n      autoRefreshEnabled: true,\n      refreshRate: 30000,\n      // 30 seconds\n      lastRefresh: null\n    };\n  },\n  async mounted() {\n    // Check authentication\n    if (!unifiedAuthService.isLoggedIn() || unifiedAuthService.getUserType() !== 'admin') {\n      this.$router.push('/login');\n      return;\n    }\n\n    // Initialize UI state\n    this.initializeUI();\n\n    // Load component data\n    await this.loadComponentData();\n\n    // Initialize real-time features\n    this.initializeRealTimeFeatures();\n  },\n  beforeUnmount() {\n    if (this.handleResize) {\n      window.removeEventListener('resize', this.handleResize);\n    }\n\n    // Clean up real-time features\n    this.cleanupRealTimeFeatures();\n\n    // Clean up blob URLs to prevent memory leaks\n    this.cleanupDocumentUrls();\n  },\n  computed: {\n    activeMenu() {\n      const path = this.$route.path;\n      if (path.includes('/admin/users')) return 'users';\n      if (path.includes('/admin/requests')) return 'requests';\n      if (path.includes('/admin/reports')) return 'reports';\n      if (path.includes('/admin/settings')) return 'settings';\n      if (path.includes('/admin/activity-logs')) return 'activity';\n      if (path.includes('/admin/profile')) return 'profile';\n      return 'dashboard';\n    }\n  },\n  methods: {\n    // Initialize UI state\n    initializeUI() {\n      this.isMobile = window.innerWidth <= 768;\n\n      // Load saved sidebar state (only on desktop)\n      if (!this.isMobile) {\n        const saved = localStorage.getItem('adminSidebarCollapsed');\n        this.sidebarCollapsed = saved ? JSON.parse(saved) : false;\n      } else {\n        this.sidebarCollapsed = true; // Always collapsed on mobile\n      }\n\n      // Setup resize listener\n      this.handleResize = () => {\n        const wasMobile = this.isMobile;\n        this.isMobile = window.innerWidth <= 768;\n        if (this.isMobile && !wasMobile) {\n          this.sidebarCollapsed = true; // Collapse when switching to mobile\n        } else if (!this.isMobile && wasMobile) {\n          // Restore saved state when switching to desktop\n          const saved = localStorage.getItem('adminSidebarCollapsed');\n          this.sidebarCollapsed = saved ? JSON.parse(saved) : false;\n        }\n      };\n      window.addEventListener('resize', this.handleResize);\n    },\n    // Sidebar toggle\n    handleSidebarToggle() {\n      this.sidebarCollapsed = !this.sidebarCollapsed;\n      localStorage.setItem('adminSidebarCollapsed', JSON.stringify(this.sidebarCollapsed));\n    },\n    // Menu navigation\n    handleMenuChange(menu) {\n      const routes = {\n        'dashboard': '/admin/dashboard',\n        'users': '/admin/users',\n        'requests': '/admin/requests',\n        'reports': '/admin/reports',\n        'settings': '/admin/settings',\n        'activity': '/admin/activity-logs',\n        'profile': '/admin/profile'\n      };\n\n      // Close sidebar on mobile after navigation\n      if (this.isMobile) {\n        this.sidebarCollapsed = true;\n      }\n      if (routes[menu]) {\n        this.$router.push(routes[menu]);\n      }\n    },\n    // User dropdown toggle\n    handleUserDropdownToggle() {\n      this.showUserDropdown = !this.showUserDropdown;\n    },\n    // Handle opening request modal from notifications\n    async handleOpenRequestModal(modalData) {\n      console.log('üîî AdminRequests: Opening request modal from notification:', modalData);\n      try {\n        const {\n          requestId,\n          focusTab\n        } = modalData;\n        if (!requestId) {\n          console.error('‚ùå No request ID provided for modal');\n          return;\n        }\n\n        // Use the existing viewRequestDetails method to open the modal\n        await this.viewRequestDetails(requestId);\n\n        // If a specific tab should be focused, handle that after modal opens\n        if (focusTab) {\n          // Wait a bit for the modal to fully render\n          setTimeout(() => {\n            this.focusModalTab(focusTab);\n          }, 300);\n        }\n        console.log('‚úÖ Request modal opened successfully');\n      } catch (error) {\n        console.error('‚ùå Error opening request modal:', error);\n        // Show error message to user\n        this.showErrorMessage('Failed to open request details');\n      }\n    },\n    // Focus on a specific tab in the request details modal\n    focusModalTab(tabName) {\n      try {\n        console.log('üéØ Focusing on modal tab:', tabName);\n\n        // Map tab names to actual tab elements or actions\n        const tabMappings = {\n          'payment': () => {\n            // Focus on payment section in the modal\n            const paymentSection = document.querySelector('#requestDetailsModal .payment-section');\n            if (paymentSection) {\n              paymentSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              paymentSection.classList.add('highlight-section');\n              setTimeout(() => paymentSection.classList.remove('highlight-section'), 2000);\n            }\n          },\n          'status': () => {\n            // Focus on status section\n            const statusSection = document.querySelector('#requestDetailsModal .status-section');\n            if (statusSection) {\n              statusSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              statusSection.classList.add('highlight-section');\n              setTimeout(() => statusSection.classList.remove('highlight-section'), 2000);\n            }\n          },\n          'documents': () => {\n            // Focus on documents section\n            const documentsSection = document.querySelector('#requestDetailsModal .documents-section');\n            if (documentsSection) {\n              documentsSection.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center'\n              });\n              documentsSection.classList.add('highlight-section');\n              setTimeout(() => documentsSection.classList.remove('highlight-section'), 2000);\n            }\n          }\n        };\n        const focusAction = tabMappings[tabName];\n        if (focusAction) {\n          focusAction();\n        } else {\n          console.log('‚ö†Ô∏è Unknown tab name:', tabName);\n        }\n      } catch (error) {\n        console.error('‚ùå Error focusing modal tab:', error);\n      }\n    },\n    // Menu actions\n    handleMenuAction(action) {\n      if (action === 'profile') {\n        this.$router.push('/admin/profile');\n      } else if (action === 'settings') {\n        this.$router.push('/admin/settings');\n      }\n      this.showUserDropdown = false;\n    },\n    // Close mobile sidebar\n    closeMobileSidebar() {\n      if (this.isMobile) {\n        this.sidebarCollapsed = true;\n      }\n    },\n    // Logout\n    handleLogout() {\n      unifiedAuthService.logout();\n      this.$router.push('/login');\n    },\n    // Load admin profile\n    async loadAdminProfile() {\n      try {\n        const currentUser = unifiedAuthService.getCurrentUser();\n        if (currentUser && currentUser.profile) {\n          this.adminData = currentUser.profile;\n        } else {\n          // Fallback to basic user data\n          this.adminData = {\n            first_name: currentUser?.username || 'Admin',\n            role: currentUser?.role || 'admin'\n          };\n        }\n      } catch (error) {\n        console.error('Failed to load admin profile:', error);\n        const currentUser = unifiedAuthService.getCurrentUser();\n        this.adminData = {\n          first_name: currentUser?.username || 'Admin',\n          role: currentUser?.role || 'admin'\n        };\n      }\n    },\n    // Load all component data\n    async loadComponentData() {\n      this.loading = true;\n      try {\n        await Promise.all([this.loadAdminProfile(), this.loadStatusOptions(), this.loadDocumentTypes(), this.loadRequests(), this.loadDashboardStats()]);\n      } catch (error) {\n        console.error('Failed to load component data:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load request data';\n        if (errorData.status === 401) {\n          unifiedAuthService.logout();\n          this.$router.push('/login');\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Load status options\n    async loadStatusOptions() {\n      try {\n        console.log('üîÑ Loading status options...');\n        const response = await adminDocumentService.getStatusOptions();\n        console.log('üìã Status options response:', response);\n        if (response.success) {\n          // Keep all statuses available for status transitions\n          // We'll filter them appropriately in different contexts\n          const allStatuses = response.data || [];\n          this.statusOptions = allStatuses;\n\n          // Create a separate array for filter dropdown (excluding final states)\n          this.filterStatusOptions = allStatuses.filter(status => {\n            const statusName = status.status_name.toLowerCase();\n            return statusName !== 'completed' && statusName !== 'cancelled';\n          });\n          console.log('‚úÖ All status options loaded:', this.statusOptions);\n          console.log('‚úÖ Filter status options (active only):', this.filterStatusOptions);\n        } else {\n          console.error('‚ùå Failed to load status options:', response.message);\n          this.statusOptions = [];\n        }\n      } catch (error) {\n        console.error('‚ùå Error loading status options:', error);\n        this.statusOptions = [];\n        this.showToast('Error', 'Failed to load status options', 'error');\n      }\n    },\n    // Load dashboard statistics\n    async loadDashboardStats() {\n      try {\n        console.log('üîÑ Loading dashboard stats...');\n        const response = await adminDocumentService.getDashboardStats();\n        console.log('üìä Dashboard stats response:', response);\n        if (response.success) {\n          // Map the backend response structure to frontend expectations\n          const data = response.data;\n          this.requestStats = {\n            total: data.overview?.total_requests || 0,\n            pending: data.overview?.pending_requests || 0,\n            approved: data.overview?.approved_requests || 0,\n            completed: data.overview?.completed_requests || 0,\n            thisMonth: data.time_based?.today_requests || 0\n          };\n          console.log('‚úÖ Request stats updated:', this.requestStats);\n        } else {\n          console.error('‚ùå Failed to load dashboard stats:', response.message);\n        }\n      } catch (error) {\n        console.error('‚ùå Error loading dashboard stats:', error);\n        // Set default values on error\n        this.requestStats = {\n          total: 0,\n          pending: 0,\n          approved: 0,\n          completed: 0,\n          thisMonth: 0\n        };\n      }\n    },\n    // Load document types\n    async loadDocumentTypes() {\n      try {\n        console.log('üîÑ Loading document types...');\n        const response = await adminDocumentService.getDocumentTypes();\n        console.log('üìã Document types response:', response);\n        if (response.success) {\n          this.documentTypes = response.data || [];\n          console.log('‚úÖ Document types loaded:', this.documentTypes);\n        } else {\n          console.error('‚ùå Failed to load document types:', response.message);\n          this.documentTypes = [];\n        }\n      } catch (error) {\n        console.error('‚ùå Error loading document types:', error);\n        this.documentTypes = [];\n        this.showToast('Error', 'Failed to load document types', 'error');\n      }\n    },\n    // Load requests with current filters and pagination\n    // NOTE: AdminRequests.vue shows ACTIVE requests only (excludes completed and cancelled)\n    // For historical view including cancelled requests, see RequestHistory.vue\n    async loadRequests() {\n      try {\n        const params = {\n          page: this.pagination.currentPage,\n          limit: this.pagination.itemsPerPage,\n          ...this.filters\n        };\n        const response = await adminDocumentService.getAllRequests(params);\n        if (response.success) {\n          // Filter out completed and cancelled requests from the response\n          // AdminRequests is for active document management only\n          const filteredRequests = (response.data.requests || []).filter(request => {\n            const statusName = request.status_name.toLowerCase();\n            return statusName !== 'completed' && statusName !== 'cancelled';\n          });\n          this.requests = filteredRequests;\n          this.pagination = {\n            currentPage: response.data.pagination?.current_page || 1,\n            totalPages: response.data.pagination?.total_pages || 1,\n            totalItems: filteredRequests.length,\n            // Update to reflect filtered count\n            itemsPerPage: response.data.pagination?.per_page || 10\n          };\n        }\n      } catch (error) {\n        console.error('Failed to load requests:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load requests';\n        this.requests = [];\n      }\n    },\n    // Filter and search methods\n    applyFilters() {\n      this.pagination.currentPage = 1;\n      this.loadRequests();\n    },\n    // Debounced search method\n    debouncedSearch() {\n      clearTimeout(this.searchTimeout);\n      this.searchTimeout = setTimeout(() => {\n        this.applyFilters();\n      }, 300);\n    },\n    clearFilters() {\n      this.filters = {\n        status: '',\n        document_type: '',\n        priority: '',\n        search: '',\n        date_from: '',\n        date_to: ''\n      };\n      this.applyFilters();\n    },\n    // Pagination methods\n    changePage(page) {\n      if (page >= 1 && page <= this.pagination.totalPages) {\n        this.pagination.currentPage = page;\n        this.loadRequests();\n      }\n    },\n    changeItemsPerPage(itemsPerPage) {\n      this.pagination.itemsPerPage = itemsPerPage;\n      this.pagination.currentPage = 1;\n      this.loadRequests();\n    },\n    goBack() {\n      this.$router.push('/admin/dashboard');\n    },\n    // Request selection methods\n    toggleRequestSelection(requestId) {\n      const index = this.selectedRequests.indexOf(requestId);\n      if (index > -1) {\n        this.selectedRequests.splice(index, 1);\n      } else {\n        this.selectedRequests.push(requestId);\n      }\n    },\n    selectAllRequests() {\n      if (this.selectedRequests.length === this.requests.length) {\n        this.selectedRequests = [];\n      } else {\n        this.selectedRequests = this.requests.map(r => r.id);\n      }\n    },\n    // Request details\n    async viewRequestDetails(requestId) {\n      console.log('üöÄ View details clicked for request ID:', requestId);\n      try {\n        const response = await adminDocumentService.getRequestDetails(requestId);\n        console.log('üìã API Response received:', response);\n        if (response.success) {\n          console.log('‚úÖ Response successful, data:', response.data);\n\n          // Debug client profile fields\n          const data = response.data;\n          console.log('üéØ COMPLETE RESPONSE DATA:', data);\n          console.log('üéØ ALL DATA KEYS:', Object.keys(data));\n          console.log('üéØ CLIENT PROFILE FIELDS DEBUG:');\n          console.log('   Birth Date:', data.client_birth_date);\n          console.log('   Gender:', data.client_gender);\n          console.log('   Civil Status ID:', data.client_civil_status_id);\n          console.log('   Nationality:', data.client_nationality);\n          console.log('   Years of Residency:', data.client_years_of_residency);\n          console.log('   Months of Residency:', data.client_months_of_residency);\n\n          // Check if fields exist with different names\n          console.log('üîç SEARCHING FOR SIMILAR FIELDS:');\n          Object.keys(data).forEach(key => {\n            if (key.includes('birth') || key.includes('gender') || key.includes('civil') || key.includes('nationality') || key.includes('residency')) {\n              console.log(`   Found: ${key} = ${data[key]}`);\n            }\n          });\n          this.currentRequest = response.data;\n          this.showRequestDetails = true;\n          // Reset forms\n          this.statusUpdateForm = {\n            status_id: ''\n          };\n          this.rejectForm = {\n            reason: ''\n          };\n          this.showRejectForm = false;\n          console.log('üìã Request details loaded:', response.data);\n\n          // Load document URLs for images\n          if (response.data.uploaded_documents && response.data.uploaded_documents.length > 0) {\n            this.loadDocumentUrls(response.data.uploaded_documents);\n          }\n          this.showToast('Success', `Request details loaded for ${response.data.request_number}`, 'success');\n        }\n      } catch (error) {\n        console.error('Failed to load request details:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to load request details';\n        this.showToast('Error', 'Failed to load request details', 'error');\n      }\n    },\n    // Refresh request details\n    async refreshRequestDetails() {\n      if (this.currentRequest) {\n        await this.viewRequestDetails(this.currentRequest.id);\n      }\n    },\n    // Update request status from modal\n    async updateRequestStatusFromModal() {\n      console.log('üîÑ Updating request status...');\n      console.log('üìã Status form data:', this.statusUpdateForm);\n      console.log('üìã Current request:', this.currentRequest);\n      if (!this.statusUpdateForm.status_id || !this.currentRequest) {\n        console.error('‚ùå Missing required data for status update');\n        this.showToast('Error', 'Please select a status to update', 'error');\n        return;\n      }\n\n      // Enhanced debugging for status validation\n      const currentStatus = this.currentRequest.status_name;\n      const newStatusId = this.statusUpdateForm.status_id;\n      const newStatus = this.statusOptions.find(s => s.id == newStatusId);\n      console.log('üîç Status validation debug:');\n      console.log('   Current status:', currentStatus);\n      console.log('   New status ID:', newStatusId, '(type:', typeof newStatusId, ')');\n      console.log('   New status object:', newStatus);\n      console.log('   Available transitions:', this.getAllowedStatusTransitions(currentStatus.toLowerCase()));\n      console.log('   Available status options:', this.getAvailableStatusOptions());\n      console.log('   All status options:', this.statusOptions);\n      if (!this.isValidStatusChange(currentStatus, newStatusId)) {\n        console.error('‚ùå Invalid status change attempted');\n        console.error('   From:', currentStatus, 'To:', newStatus?.status_name);\n        this.showToast('Error', 'This status change is not allowed', 'error');\n        return;\n      }\n      try {\n        const updateData = {\n          status_id: parseInt(this.statusUpdateForm.status_id)\n        };\n        console.log('üì§ Sending status update:', updateData);\n        const response = await adminDocumentService.updateRequestStatus(this.currentRequest.id, updateData);\n        console.log('üì• Status update response:', response);\n        if (response.success) {\n          // Refresh the request details\n          await this.refreshRequestDetails();\n          // Refresh the main requests list\n          await this.loadRequests();\n          // Reset form\n          this.statusUpdateForm = {\n            status_id: ''\n          };\n\n          // Show success message\n          this.errorMessage = '';\n          this.showToast('Success', 'Request status updated successfully', 'success');\n        } else {\n          console.error('‚ùå Status update failed:', response.message);\n          this.showToast('Error', response.message || 'Failed to update request status', 'error');\n        }\n      } catch (error) {\n        console.error('‚ùå Error updating request status:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to update request status';\n        this.showToast('Error', errorData.message || 'Failed to update request status', 'error');\n      }\n    },\n    // Reject request from modal\n    async rejectRequestFromModal() {\n      if (!this.currentRequest || !this.rejectForm.reason.trim()) return;\n      try {\n        const response = await adminDocumentService.rejectRequest(this.currentRequest.id, {\n          reason: this.rejectForm.reason\n        });\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n          this.rejectForm = {\n            reason: ''\n          };\n          this.showRejectForm = false;\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to reject request';\n      }\n    },\n    // Status update methods\n    async updateRequestStatus(requestId, statusId, reason = '') {\n      try {\n        const response = await adminDocumentService.updateRequestStatus(requestId, {\n          status_id: statusId,\n          reason: reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to update request status:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to update request status';\n      }\n    },\n    async approveRequest(requestId, reason = '') {\n      try {\n        const response = await adminDocumentService.approveRequest(requestId, {\n          reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to approve request';\n      }\n    },\n    async rejectRequest(requestId, reason) {\n      if (!reason || reason.trim() === '') {\n        this.errorMessage = 'Rejection reason is required';\n        return;\n      }\n      try {\n        const response = await adminDocumentService.rejectRequest(requestId, {\n          reason\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to reject request';\n      }\n    },\n    // Quick approval/rejection methods\n    canApprove(request) {\n      // Can approve if 'approved' is in allowed transitions\n      const allowedTransitions = this.getAllowedStatusTransitions(request.status_name.toLowerCase());\n      return allowedTransitions.includes('approved');\n    },\n    canReject(request) {\n      // Can reject if 'rejected' is in allowed transitions\n      const allowedTransitions = this.getAllowedStatusTransitions(request.status_name.toLowerCase());\n      return allowedTransitions.includes('rejected');\n    },\n    // Helper method to get status explanation for disabled buttons\n    getStatusExplanation(request, action) {\n      const status = request.status_name.toLowerCase();\n      const allowedTransitions = this.getAllowedStatusTransitions(status);\n      if (action === 'approve') {\n        if (allowedTransitions.includes('approved')) {\n          return 'Click to approve this request';\n        } else if (status === 'approved') {\n          return 'This request has already been approved';\n        } else if (status === 'rejected') {\n          return 'Rejected requests can be resubmitted, not directly approved';\n        } else if (status === 'completed') {\n          return 'This request has already been completed';\n        } else {\n          return `Cannot approve from ${this.formatStatus(status)} status`;\n        }\n      } else if (action === 'reject') {\n        if (allowedTransitions.includes('rejected')) {\n          return 'Click to reject this request';\n        } else if (status === 'rejected') {\n          return 'This request has already been rejected';\n        } else if (status === 'completed') {\n          return 'Cannot reject a completed request';\n        } else {\n          return `Cannot reject from ${this.formatStatus(status)} status`;\n        }\n      }\n      return `Request status: ${this.formatStatus(status)}`;\n    },\n    // Check if status change is valid\n    isValidStatusChange(currentStatus, newStatusId) {\n      if (!currentStatus || !newStatusId) return false;\n\n      // Find the new status name\n      const newStatus = this.statusOptions.find(s => s.id == newStatusId);\n      if (!newStatus) return false;\n      const currentStatusName = currentStatus.toLowerCase();\n      const newStatusName = newStatus.status_name.toLowerCase();\n\n      // Same status - no change needed\n      if (currentStatusName === newStatusName) {\n        return false;\n      }\n\n      // Check if transition is allowed based on workflow rules\n      const allowedTransitions = this.getAllowedStatusTransitions(currentStatusName);\n      return allowedTransitions.includes(newStatusName);\n    },\n    // Check if request needs payment verification\n    needsPaymentVerification(request) {\n      return request.status_name === 'payment_pending' && request.payment_method && !request.payment_method.includes('PayMongo') && request.payment_status !== 'paid';\n    },\n    // Check if pickup can be scheduled\n    canSchedulePickup(request) {\n      return request.status_name === 'ready_for_pickup';\n    },\n    // Get payment status color\n    getPaymentStatusColor(status) {\n      const colors = {\n        'pending': 'bg-warning',\n        'processing': 'bg-info',\n        'paid': 'bg-success',\n        'failed': 'bg-danger',\n        'refunded': 'bg-secondary',\n        'cancelled': 'bg-dark'\n      };\n      return colors[status] || 'bg-secondary';\n    },\n    // Format payment status\n    formatPaymentStatus(status) {\n      const statuses = {\n        'pending': 'Pending',\n        'processing': 'Processing',\n        'paid': 'Paid',\n        'failed': 'Failed',\n        'refunded': 'Refunded',\n        'cancelled': 'Cancelled'\n      };\n      return statuses[status] || 'Unknown';\n    },\n    // Get tomorrow's date for pickup scheduling\n    getTomorrowDate() {\n      const tomorrow = new Date();\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      return tomorrow.toISOString().split('T')[0];\n    },\n    // Validate pickup form\n    isPickupFormValid() {\n      return this.pickupScheduleForm.scheduled_date && this.pickupScheduleForm.scheduled_time_start && this.pickupScheduleForm.scheduled_time_end && this.pickupScheduleForm.scheduled_time_start < this.pickupScheduleForm.scheduled_time_end;\n    },\n    // Get filtered status options based on current status\n    getAvailableStatusOptions() {\n      if (!this.currentRequest || !this.statusOptions) {\n        console.log('üîç getAvailableStatusOptions: Missing currentRequest or statusOptions');\n        return [];\n      }\n      const currentStatus = this.currentRequest.status_name.toLowerCase();\n\n      // Only these states are truly final (cannot be changed)\n      const finalStates = ['completed', 'cancelled'];\n\n      // If current status is final, no changes allowed\n      if (finalStates.includes(currentStatus)) {\n        console.log('üîç getAvailableStatusOptions: Current status is final:', currentStatus);\n        return [];\n      }\n\n      // Define allowed transitions based on current status\n      const allowedTransitions = this.getAllowedStatusTransitions(currentStatus);\n\n      // Check if current request uses cash payment\n      const isCashPayment = this.currentRequest && (this.currentRequest.payment_method === 'Cash Payment' || this.currentRequest.payment_method === 'Cash' || this.currentRequest.payment_method_code === 'CASH' || this.currentRequest.payment_method_id === 1 ||\n      // Assuming cash is ID 1\n      this.currentRequest.is_online_payment === false || this.currentRequest.is_online_payment === 0 || this.currentRequest.is_online === false || this.currentRequest.is_online === 0);\n\n      // Filter out \"payment_confirmed\" status for cash payments\n      let filteredTransitions = allowedTransitions;\n      if (isCashPayment) {\n        filteredTransitions = allowedTransitions.filter(transition => transition !== 'payment_confirmed');\n        console.log('üîç Filtered out payment_confirmed for cash payment:', {\n          originalTransitions: allowedTransitions,\n          filteredTransitions: filteredTransitions\n        });\n      }\n\n      // Return only allowed status options\n      const availableOptions = this.statusOptions.filter(status => filteredTransitions.includes(status.status_name.toLowerCase()));\n      console.log('üîç getAvailableStatusOptions result:', {\n        currentStatus: currentStatus,\n        isCashPayment: isCashPayment,\n        allowedTransitions: allowedTransitions,\n        filteredTransitions: filteredTransitions,\n        availableOptions: availableOptions.map(opt => ({\n          id: opt.id,\n          name: opt.status_name\n        })),\n        totalStatusOptions: this.statusOptions.length\n      });\n      return availableOptions;\n    },\n    // Define allowed status transitions based on government workflow best practices\n    // This must match the backend validateStatusTransition logic exactly\n    getAllowedStatusTransitions(currentStatus) {\n      // Check if current request uses cash payment - enhanced detection\n      const isCashPayment = this.currentRequest && (this.currentRequest.payment_method === 'Cash Payment' || this.currentRequest.payment_method === 'Cash' || this.currentRequest.payment_method_code === 'CASH' || this.currentRequest.payment_method_id === 1 ||\n      // Assuming cash is ID 1\n      this.currentRequest.is_online_payment === false || this.currentRequest.is_online_payment === 0 || this.currentRequest.is_online === false || this.currentRequest.is_online === 0);\n      console.log('üîç Cash payment detection for status transitions:', {\n        currentStatus: currentStatus,\n        payment_method: this.currentRequest?.payment_method,\n        payment_method_code: this.currentRequest?.payment_method_code,\n        payment_method_id: this.currentRequest?.payment_method_id,\n        is_online_payment: this.currentRequest?.is_online_payment,\n        isCashPayment: isCashPayment\n      });\n      const transitions = {\n        // Simplified workflow matching actual database statuses\n        'pending': ['approved', 'cancelled', 'rejected'],\n        'under_review': ['approved', 'rejected', 'cancelled'],\n        'approved': isCashPayment ? ['payment_confirmed', 'processing', 'cancelled'] // Cash payments can go directly to processing\n        : ['payment_confirmed', 'cancelled'],\n        // Online payments go through PayMongo webhook to payment_confirmed\n        'payment_confirmed': ['processing'],\n        // Automatic transition after payment\n        'processing': ['ready_for_pickup'],\n        // Processing can only complete successfully\n        'ready_for_pickup': ['completed', 'cancelled'],\n        // Allow completion for both cash and online payments\n        'rejected': ['pending', 'under_review'],\n        // Allow resubmission after corrections\n        // Final states - no transitions allowed\n        'completed': [],\n        'cancelled': []\n      };\n      const allowedTransitions = transitions[currentStatus] || [];\n      console.log('üîç Allowed transitions for', currentStatus, ':', allowedTransitions);\n      return allowedTransitions;\n    },\n    // Get title for update button based on validation state\n    getUpdateButtonTitle() {\n      if (!this.statusUpdateForm.status_id) {\n        return 'Please select a new status';\n      }\n      if (!this.isValidStatusChange(this.currentRequest.status_name, this.statusUpdateForm.status_id)) {\n        return 'Invalid status change';\n      }\n      return 'Update request status';\n    },\n    // Get dynamic button text based on selected status\n    getActionButtonText() {\n      if (!this.statusUpdateForm.status_id) {\n        return 'Update Status';\n      }\n      const selectedStatus = this.statusOptions.find(s => s.id === parseInt(this.statusUpdateForm.status_id));\n      if (!selectedStatus) {\n        return 'Update Status';\n      }\n      const statusName = selectedStatus.status_name.toLowerCase();\n\n      // Special button text for common actions\n      switch (statusName) {\n        case 'approved':\n          return 'Approve Request';\n        case 'rejected':\n          return 'Reject Request';\n        case 'under_review':\n          return 'Move to Review';\n        case 'processing':\n          return 'Start Processing';\n        case 'ready_for_pickup':\n          return 'Mark Ready for Pickup';\n        case 'completed':\n          return 'Complete Request';\n        default:\n          return `Update to ${selectedStatus.status_name}`;\n      }\n    },\n    // Get status description for current status display\n    getStatusDescription(statusName) {\n      const descriptions = {\n        'pending': 'Waiting for admin review',\n        'under_review': 'Being reviewed by admin',\n        'approved': 'Approved, waiting for payment',\n        'payment_confirmed': 'Payment received, ready for processing',\n        'processing': 'Document is being prepared',\n        'ready_for_pickup': 'Document ready for collection',\n        'completed': 'Request completed successfully',\n        'rejected': 'Request rejected, can be resubmitted',\n        'cancelled': 'Request cancelled permanently'\n      };\n      return descriptions[statusName.toLowerCase()] || 'Status information';\n    },\n    // Get next available status actions for automatic progression\n    getNextStatusActions() {\n      if (!this.currentRequest) return [];\n      const currentStatus = this.currentRequest.status_name.toLowerCase();\n      const allowedTransitions = this.getAllowedStatusTransitions(currentStatus);\n\n      // Filter out 'cancelled' and 'rejected' from regular progression (handled separately)\n      // 'cancelled' is handled by the separate Cancel Request button\n      // 'rejected' is redundant since we have Cancel Request which serves the same purpose\n      const progressionTransitions = allowedTransitions.filter(status => status !== 'cancelled' && status !== 'rejected');\n      return progressionTransitions.map(statusName => {\n        const statusOption = this.statusOptions.find(s => s.status_name.toLowerCase() === statusName);\n        if (!statusOption) return null;\n        return {\n          status_id: statusOption.id,\n          status_name: statusName,\n          label: this.getProgressionButtonLabel(statusName),\n          icon: this.getProgressionButtonIcon(statusName),\n          buttonClass: this.getProgressionButtonClass(statusName),\n          description: this.getProgressionButtonDescription(statusName)\n        };\n      }).filter(action => action !== null);\n    },\n    // Get button label for status progression\n    getProgressionButtonLabel(statusName) {\n      const labels = {\n        'approved': 'Approve Request',\n        'rejected': 'Reject Request',\n        'payment_confirmed': 'Confirm Payment',\n        'processing': 'Start Processing',\n        'ready_for_pickup': 'Mark Ready',\n        'completed': 'Complete Request',\n        'under_review': 'Review Request',\n        'pending': 'Mark Pending'\n      };\n      return labels[statusName] || `Change to ${this.formatStatus(statusName)}`;\n    },\n    // Get button icon for status progression\n    getProgressionButtonIcon(statusName) {\n      const icons = {\n        'approved': 'fas fa-check',\n        'rejected': 'fas fa-times',\n        'payment_confirmed': 'fas fa-credit-card',\n        'processing': 'fas fa-cogs',\n        'ready_for_pickup': 'fas fa-hand-paper',\n        'completed': 'fas fa-check-circle',\n        'under_review': 'fas fa-search',\n        'pending': 'fas fa-clock'\n      };\n      return icons[statusName] || 'fas fa-arrow-right';\n    },\n    // Get button CSS class for status progression\n    getProgressionButtonClass(statusName) {\n      const classes = {\n        'approved': 'btn-success',\n        'rejected': 'btn-danger',\n        'payment_confirmed': 'btn-info',\n        'processing': 'btn-warning',\n        'ready_for_pickup': 'btn-primary',\n        'completed': 'btn-success',\n        'under_review': 'btn-secondary',\n        'pending': 'btn-outline-secondary'\n      };\n      return classes[statusName] || 'btn-outline-primary';\n    },\n    // Get button description for status progression\n    getProgressionButtonDescription(statusName) {\n      const descriptions = {\n        'approved': 'Approve this request and proceed to payment',\n        'rejected': 'Reject this request with reason',\n        'payment_confirmed': 'Confirm payment has been received',\n        'processing': 'Start processing the document',\n        'ready_for_pickup': 'Mark document as ready for collection',\n        'completed': 'Mark request as completed',\n        'under_review': 'Move request to review status',\n        'pending': 'Move request back to pending status'\n      };\n      return descriptions[statusName] || `Change status to ${this.formatStatus(statusName)}`;\n    },\n    // Check if request can be cancelled\n    canCancelRequest() {\n      if (!this.currentRequest) return false;\n      const currentStatus = this.currentRequest.status_name.toLowerCase();\n      const finalStates = ['completed', 'cancelled'];\n\n      // Can cancel if not in final states\n      return !finalStates.includes(currentStatus);\n    },\n    // Progress to next status automatically\n    async progressToNextStatus(statusId) {\n      if (!statusId || !this.currentRequest) {\n        this.showToast('Error', 'Invalid status selection', 'error');\n        return;\n      }\n      try {\n        const updateData = {\n          status_id: parseInt(statusId)\n        };\n        console.log('üì§ Progressing to next status:', updateData);\n        const response = await adminDocumentService.updateRequestStatus(this.currentRequest.id, updateData);\n        if (response.success) {\n          // Refresh the request details\n          await this.refreshRequestDetails();\n          // Refresh the main requests list\n          await this.loadRequests();\n\n          // Show success message\n          const newStatus = this.statusOptions.find(s => s.id === parseInt(statusId));\n          this.showToast('Success', `Request status updated to ${this.formatStatus(newStatus.status_name)}`, 'success');\n        } else {\n          this.showToast('Error', response.message || 'Failed to update request status', 'error');\n        }\n      } catch (error) {\n        console.error('‚ùå Error progressing status:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.showToast('Error', errorData.message || 'Failed to update request status', 'error');\n      }\n    },\n    // Cancel request permanently\n    async cancelRequest() {\n      if (!this.currentRequest) return;\n\n      // Find cancelled status\n      const cancelledStatus = this.statusOptions.find(s => s.status_name.toLowerCase() === 'cancelled');\n      if (!cancelledStatus) {\n        this.showToast('Error', 'Cancelled status not found', 'error');\n        return;\n      }\n\n      // Confirm cancellation\n      if (!confirm(`Are you sure you want to cancel request ${this.currentRequest.request_number}? This action cannot be undone.`)) {\n        return;\n      }\n      try {\n        const updateData = {\n          status_id: cancelledStatus.id\n        };\n        console.log('üì§ Cancelling request:', updateData);\n        const response = await adminDocumentService.updateRequestStatus(this.currentRequest.id, updateData);\n        if (response.success) {\n          // Refresh the request details\n          await this.refreshRequestDetails();\n          // Refresh the main requests list\n          await this.loadRequests();\n          this.showToast('Success', 'Request has been cancelled', 'success');\n        } else {\n          this.showToast('Error', response.message || 'Failed to cancel request', 'error');\n        }\n      } catch (error) {\n        console.error('‚ùå Error cancelling request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.showToast('Error', errorData.message || 'Failed to cancel request', 'error');\n      }\n    },\n    async quickApprove(request) {\n      console.log('üöÄ Quick approve clicked for request:', request);\n      try {\n        this.loading = true;\n        const response = await adminDocumentService.approveRequest(request.id, {\n          reason: 'Quick approval from admin interface'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${request.request_number} approved successfully`, 'success');\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.showToast('Error', errorData.message || 'Failed to approve request', 'error');\n      } finally {\n        this.loading = false;\n      }\n    },\n    showQuickRejectModal(request) {\n      console.log('üöÄ Quick reject clicked for request:', request);\n      this.selectedRequestForReject = request;\n      this.quickRejectForm = {\n        loading: false,\n        error: ''\n      };\n      this.showQuickReject = true;\n    },\n    closeQuickRejectModal() {\n      this.showQuickReject = false;\n      this.selectedRequestForReject = null;\n      this.quickRejectForm = {\n        loading: false,\n        error: ''\n      };\n    },\n    async confirmQuickReject() {\n      this.quickRejectForm.loading = true;\n      this.quickRejectForm.error = '';\n      try {\n        const response = await adminDocumentService.rejectRequest(this.selectedRequestForReject.id, {\n          reason: 'Request rejected by admin'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${this.selectedRequestForReject.request_number} rejected successfully`, 'success');\n          this.closeQuickRejectModal();\n        }\n      } catch (error) {\n        console.error('Failed to reject request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.quickRejectForm.error = errorData.message || 'Failed to reject request';\n      } finally {\n        this.quickRejectForm.loading = false;\n      }\n    },\n    showQuickApproveModal(request) {\n      console.log('üöÄ Quick approve clicked for request:', request);\n      this.selectedRequestForApprove = request;\n      this.quickApproveForm = {\n        loading: false,\n        error: ''\n      };\n      this.showQuickApprove = true;\n    },\n    closeQuickApproveModal() {\n      this.showQuickApprove = false;\n      this.selectedRequestForApprove = null;\n      this.quickApproveForm = {\n        loading: false,\n        error: ''\n      };\n    },\n    async confirmQuickApprove() {\n      this.quickApproveForm.loading = true;\n      this.quickApproveForm.error = '';\n      try {\n        const response = await adminDocumentService.approveRequest(this.selectedRequestForApprove.id, {\n          reason: 'Quick approval from admin interface'\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.showToast('Success', `Request ${this.selectedRequestForApprove.request_number} approved successfully`, 'success');\n          this.closeQuickApproveModal();\n        }\n      } catch (error) {\n        console.error('Failed to approve request:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.quickApproveForm.error = errorData.message || 'Failed to approve request';\n      } finally {\n        this.quickApproveForm.loading = false;\n      }\n    },\n    // Bulk operations\n    async performBulkAction() {\n      if (this.selectedRequests.length === 0) {\n        this.errorMessage = 'Please select at least one request';\n        return;\n      }\n      if (!this.bulkAction) {\n        this.errorMessage = 'Please select a bulk action';\n        return;\n      }\n      try {\n        const response = await adminDocumentService.bulkUpdateRequests({\n          request_ids: this.selectedRequests,\n          status_id: parseInt(this.bulkAction)\n        });\n        if (response.success) {\n          await this.loadRequests();\n          await this.loadDashboardStats();\n          this.selectedRequests = [];\n          this.bulkAction = '';\n          this.showBulkActions = false;\n          this.errorMessage = '';\n        }\n      } catch (error) {\n        console.error('Failed to perform bulk action:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to perform bulk action';\n      }\n    },\n    // Export functionality\n    async exportRequests() {\n      try {\n        const csvData = await adminDocumentService.exportRequests(this.filters);\n        const filename = `document_requests_${new Date().toISOString().split('T')[0]}.csv`;\n        adminDocumentService.downloadCSV(csvData, filename);\n      } catch (error) {\n        console.error('Failed to export requests:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to export requests';\n      }\n    },\n    // Comprehensive Excel export functionality\n    async exportRequestsToExcel() {\n      try {\n        this.showToast('Info', 'Preparing comprehensive Excel export...', 'info');\n\n        // Get all requests with full details (no pagination)\n        const allRequestsResponse = await adminDocumentService.getAllRequests({\n          ...this.filters,\n          page: 1,\n          limit: 10000 // Get all requests\n        });\n        if (!allRequestsResponse.success || !allRequestsResponse.data.requests) {\n          throw new Error('Failed to fetch requests data');\n        }\n        const requests = allRequestsResponse.data.requests;\n        if (requests.length === 0) {\n          this.showToast('Warning', 'No requests found to export', 'warning');\n          return;\n        }\n\n        // For each request, get detailed information\n        const detailedRequests = [];\n        for (const request of requests) {\n          try {\n            const detailResponse = await adminDocumentService.getRequestDetails(request.id);\n            if (detailResponse.success) {\n              detailedRequests.push(detailResponse.data);\n            } else {\n              // If detailed fetch fails, use basic request data\n              detailedRequests.push(request);\n            }\n          } catch (error) {\n            console.warn(`Failed to get details for request ${request.id}:`, error);\n            detailedRequests.push(request);\n          }\n        }\n\n        // Create comprehensive Excel data\n        const excelData = this.prepareExcelData(detailedRequests);\n\n        // Check if xlsx library is available\n        if (typeof XLSX === 'undefined') {\n          // Fallback to CSV if xlsx is not available\n          this.showToast('Warning', 'Excel library not available. Downloading as CSV instead.', 'warning');\n          this.downloadAsCSV(excelData.mainSheet, 'comprehensive_requests_export');\n          return;\n        }\n\n        // Create Excel workbook with multiple sheets\n        this.createExcelWorkbook(excelData);\n      } catch (error) {\n        console.error('Failed to export requests to Excel:', error);\n        this.showToast('Error', 'Failed to export requests to Excel', 'error');\n      }\n    },\n    // Prepare comprehensive Excel data with vertical key-value layout\n    prepareExcelData(requests) {\n      const mainSheet = [];\n      const cedulaSheet = [];\n      const barangaySheet = [];\n\n      // Process each request with vertical key-value format\n      requests.forEach((request, index) => {\n        // Add request separator and header\n        if (index > 0) {\n          mainSheet.push(['']); // Empty row separator\n        }\n        mainSheet.push([`REQUEST #${index + 1}: ${request.request_number || 'N/A'}`]);\n        mainSheet.push(['='.repeat(50)]);\n        mainSheet.push(['']);\n\n        // Request Information Block\n        mainSheet.push(['REQUEST INFORMATION']);\n        mainSheet.push(['Request Number:', request.request_number || '']);\n        mainSheet.push(['Document Type:', request.document_type || '']);\n        mainSheet.push(['Status:', this.formatStatus(request.status_name) || '']);\n        mainSheet.push(['Submitted Date:', this.formatDate(request.requested_at) || '']);\n        mainSheet.push(['Last Updated:', this.formatDate(request.updated_at) || '']);\n        mainSheet.push(['Purpose Category:', request.purpose_category || '']);\n        mainSheet.push(['Purpose Details:', request.purpose_details || '']);\n        mainSheet.push(['']);\n\n        // Client Information Block\n        mainSheet.push(['CLIENT INFORMATION']);\n        mainSheet.push(['Full Name:', this.getClientFullName(request) || '']);\n        mainSheet.push(['Email Address:', request.client_email || '']);\n        mainSheet.push(['Phone Number:', request.client_phone || '']);\n        mainSheet.push(['Date of Birth:', this.formatDate(request.client_birth_date) || '']);\n        mainSheet.push(['Gender:', this.formatGender(request.client_gender) || '']);\n        mainSheet.push(['Civil Status:', this.getCivilStatusName(request.client_civil_status_id) || '']);\n        mainSheet.push(['Nationality:', request.client_nationality || '']);\n        mainSheet.push(['Complete Address:', this.getClientFullAddress(request) || '']);\n        mainSheet.push(['Years of Residency:', this.getResidencyDisplay(request) || '']);\n        mainSheet.push(['']);\n\n        // Third Party Request Information (if applicable)\n        if (request.is_third_party_request) {\n          mainSheet.push(['THIRD PARTY REQUEST']);\n          mainSheet.push(['Is Third Party Request:', 'Yes']);\n          if (request.beneficiary) {\n            mainSheet.push(['']);\n            mainSheet.push(['BENEFICIARY INFORMATION']);\n            mainSheet.push(['Full Name:', request.beneficiary.full_name || '']);\n            mainSheet.push(['Email Address:', request.beneficiary.email || '']);\n            mainSheet.push(['Phone Number:', request.beneficiary.phone_number || '']);\n            mainSheet.push(['Date of Birth:', this.formatDate(request.beneficiary.birth_date) || '']);\n            mainSheet.push(['Gender:', this.formatGender(request.beneficiary.gender) || '']);\n            mainSheet.push(['Civil Status:', this.getCivilStatusName(request.beneficiary.civil_status_id) || '']);\n            mainSheet.push(['Nationality:', request.beneficiary.nationality || '']);\n            mainSheet.push(['Address:', request.beneficiary.address || '']);\n            mainSheet.push(['Relationship to Requestor:', this.formatRelationship(request.beneficiary.relationship_to_requestor) || '']);\n          }\n          mainSheet.push(['']);\n        }\n\n        // Authorized Pickup Information (if applicable)\n        if (request.authorized_pickup) {\n          mainSheet.push(['AUTHORIZED PICKUP PERSON']);\n          mainSheet.push(['Full Name:', request.authorized_pickup.full_name || '']);\n          mainSheet.push(['Phone Number:', request.authorized_pickup.phone_number || '']);\n          mainSheet.push(['Relationship:', this.formatRelationship(request.authorized_pickup.relationship_to_beneficiary) || '']);\n          mainSheet.push(['']);\n        }\n\n        // Payment Information\n        mainSheet.push(['PAYMENT INFORMATION']);\n        mainSheet.push(['Payment Method:', request.payment_method || '']);\n        mainSheet.push(['Payment Status:', this.formatPaymentStatus(request.payment_status) || '']);\n        mainSheet.push(['Total Fee:', this.formatCurrency(request.total_fee || 0)]);\n        mainSheet.push(['']);\n\n        // Admin Notes (if any)\n        if (request.admin_notes) {\n          mainSheet.push(['ADMIN NOTES']);\n          mainSheet.push(['Notes:', request.admin_notes]);\n          mainSheet.push(['']);\n        }\n\n        // Document-Specific Information for Cedula\n        if (request.document_type === 'Cedula' && request.specific_details) {\n          // Add to Cedula sheet with vertical format\n          if (cedulaSheet.length === 0) {\n            cedulaSheet.push(['CEDULA DOCUMENT DETAILS']);\n            cedulaSheet.push(['='.repeat(50)]);\n            cedulaSheet.push(['']);\n          } else {\n            cedulaSheet.push(['']); // Separator between requests\n          }\n          cedulaSheet.push([`REQUEST: ${request.request_number || 'N/A'}`]);\n          cedulaSheet.push(['Client Name:', this.getClientFullName(request) || '']);\n          cedulaSheet.push(['']);\n          cedulaSheet.push(['INCOME INFORMATION']);\n          cedulaSheet.push(['Annual Income:', this.formatCurrency(request.specific_details.annual_income || 0)]);\n          cedulaSheet.push(['Monthly Income:', this.formatCurrency(request.specific_details.monthly_income || 0)]);\n          cedulaSheet.push(['Occupation:', request.specific_details.occupation || '']);\n          cedulaSheet.push(['Employer Name:', request.specific_details.employer_name || '']);\n          cedulaSheet.push(['']);\n          if (request.specific_details.has_real_property || request.specific_details.property_assessed_value > 0) {\n            cedulaSheet.push(['REAL PROPERTY INFORMATION']);\n            cedulaSheet.push(['Has Real Property:', request.specific_details.has_real_property ? 'Yes' : 'No']);\n            cedulaSheet.push(['Property Assessed Value:', this.formatCurrency(request.specific_details.property_assessed_value || 0)]);\n            cedulaSheet.push(['Property Location:', request.specific_details.property_location || '']);\n            cedulaSheet.push(['']);\n          }\n          if (request.specific_details.has_personal_property || request.specific_details.personal_property_value > 0) {\n            cedulaSheet.push(['PERSONAL PROPERTY INFORMATION']);\n            cedulaSheet.push(['Has Personal Property:', request.specific_details.has_personal_property ? 'Yes' : 'No']);\n            cedulaSheet.push(['Personal Property Value:', this.formatCurrency(request.specific_details.personal_property_value || 0)]);\n            cedulaSheet.push(['']);\n          }\n          if (request.specific_details.business_name || request.specific_details.business_gross_receipts > 0) {\n            cedulaSheet.push(['BUSINESS INFORMATION']);\n            cedulaSheet.push(['Business Name:', request.specific_details.business_name || '']);\n            cedulaSheet.push(['Business Type:', request.specific_details.business_type || '']);\n            cedulaSheet.push(['Business Address:', request.specific_details.business_address || '']);\n            cedulaSheet.push(['Annual Gross Receipts:', this.formatCurrency(request.specific_details.business_gross_receipts || 0)]);\n            cedulaSheet.push(['']);\n          }\n          cedulaSheet.push(['TAX COMPUTATION']);\n          cedulaSheet.push(['Computed Tax:', this.formatCurrency(request.specific_details.computed_tax || 0)]);\n          cedulaSheet.push(['Total Document Fee:', this.formatCurrency(request.total_document_fee || 0)]);\n          cedulaSheet.push(['']);\n        }\n\n        // Document-Specific Information for Barangay Clearance\n        if (request.document_type === 'Barangay Clearance' && request.specific_details) {\n          // Add to Barangay sheet with vertical format\n          if (barangaySheet.length === 0) {\n            barangaySheet.push(['BARANGAY CLEARANCE DOCUMENT DETAILS']);\n            barangaySheet.push(['='.repeat(50)]);\n            barangaySheet.push(['']);\n          } else {\n            barangaySheet.push(['']); // Separator between requests\n          }\n          barangaySheet.push([`REQUEST: ${request.request_number || 'N/A'}`]);\n          barangaySheet.push(['Client Name:', this.getClientFullName(request) || '']);\n          barangaySheet.push(['']);\n          barangaySheet.push(['LEGAL STATUS INFORMATION']);\n          barangaySheet.push(['Has Pending Cases:', request.specific_details.has_pending_cases ? 'Yes' : 'No']);\n          if (request.specific_details.has_pending_cases && request.specific_details.pending_cases_details) {\n            barangaySheet.push(['Pending Cases Details:', request.specific_details.pending_cases_details]);\n          }\n          barangaySheet.push(['']);\n          if (request.specific_details.voter_registration_number || request.specific_details.precinct_number) {\n            barangaySheet.push(['VOTER INFORMATION']);\n            barangaySheet.push(['Voter Registration Number:', request.specific_details.voter_registration_number || '']);\n            barangaySheet.push(['Precinct Number:', request.specific_details.precinct_number || '']);\n            barangaySheet.push(['']);\n          }\n          if (request.specific_details.emergency_contact_name) {\n            barangaySheet.push(['EMERGENCY CONTACT INFORMATION']);\n            barangaySheet.push(['Contact Name:', request.specific_details.emergency_contact_name || '']);\n            barangaySheet.push(['Contact Phone:', request.specific_details.emergency_contact_phone || '']);\n            barangaySheet.push(['Relationship:', request.specific_details.emergency_contact_relationship || '']);\n            barangaySheet.push(['Address:', request.specific_details.emergency_contact_address || '']);\n            barangaySheet.push(['']);\n          }\n        }\n      });\n      return {\n        mainSheet,\n        cedulaSheet,\n        barangaySheet\n      };\n    },\n    // Create Excel workbook with multiple sheets\n    createExcelWorkbook(excelData) {\n      try {\n        // Create a new workbook\n        const wb = XLSX.utils.book_new();\n\n        // Add main sheet\n        const mainWs = XLSX.utils.aoa_to_sheet(excelData.mainSheet);\n        XLSX.utils.book_append_sheet(wb, mainWs, 'All Requests');\n\n        // Add Cedula-specific sheet if there's data\n        if (excelData.cedulaSheet.length > 1) {\n          const cedulaWs = XLSX.utils.aoa_to_sheet(excelData.cedulaSheet);\n          XLSX.utils.book_append_sheet(wb, cedulaWs, 'Cedula Details');\n        }\n\n        // Add Barangay Clearance-specific sheet if there's data\n        if (excelData.barangaySheet.length > 1) {\n          const barangayWs = XLSX.utils.aoa_to_sheet(excelData.barangaySheet);\n          XLSX.utils.book_append_sheet(wb, barangayWs, 'Barangay Clearance Details');\n        }\n\n        // Set column widths for better readability\n        this.setExcelColumnWidths(wb);\n\n        // Generate filename\n        const timestamp = new Date().toISOString().split('T')[0];\n        const filename = `comprehensive_requests_export_${timestamp}.xlsx`;\n\n        // Write and download the file\n        XLSX.writeFile(wb, filename);\n        this.showToast('Success', 'Excel file downloaded successfully!', 'success');\n      } catch (error) {\n        console.error('Failed to create Excel workbook:', error);\n        // Fallback to CSV\n        this.downloadAsCSV(excelData.mainSheet, 'comprehensive_requests_export');\n      }\n    },\n    // Set column widths for Excel sheets (optimized for vertical key-value format)\n    setExcelColumnWidths(workbook) {\n      try {\n        // Set column widths for all sheets with vertical key-value format\n        Object.keys(workbook.Sheets).forEach(sheetName => {\n          const sheet = workbook.Sheets[sheetName];\n          if (sheet) {\n            // For vertical key-value format, we need:\n            // Column A: Labels/Keys (wider)\n            // Column B: Values (wider for content)\n            const colWidths = [{\n              wch: 35\n            },\n            // Column A: Labels/Keys\n            {\n              wch: 50\n            } // Column B: Values/Content\n            ];\n            sheet['!cols'] = colWidths;\n          }\n        });\n      } catch (error) {\n        console.warn('Failed to set column widths:', error);\n      }\n    },\n    // CSV fallback method (optimized for vertical key-value format)\n    downloadAsCSV(sheetData, filename) {\n      try {\n        // Convert vertical key-value format to readable CSV\n        const csvContent = sheetData.map(row => {\n          if (Array.isArray(row)) {\n            return row.map(cell => {\n              // Escape commas and quotes in CSV\n              const cellValue = String(cell || '');\n              if (cellValue.includes(',') || cellValue.includes('\"') || cellValue.includes('\\n')) {\n                return `\"${cellValue.replace(/\"/g, '\"\"')}\"`;\n              }\n              return cellValue;\n            }).join(',');\n          }\n          return String(row || '');\n        }).join('\\n');\n\n        // Create and download CSV file\n        const blob = new Blob([csvContent], {\n          type: 'text/csv;charset=utf-8;'\n        });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        link.setAttribute('href', url);\n        link.setAttribute('download', `${filename}_${new Date().toISOString().split('T')[0]}.csv`);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n        this.showToast('Success', 'CSV file downloaded successfully!', 'success');\n      } catch (error) {\n        console.error('Failed to download CSV:', error);\n        this.showToast('Error', 'Failed to download CSV file', 'error');\n      }\n    },\n    // Export single request to Excel\n    async exportSingleRequestToExcel() {\n      try {\n        if (!this.currentRequest) {\n          this.showToast('Warning', 'No request selected for export', 'warning');\n          return;\n        }\n        this.showToast('Info', 'Preparing request export...', 'info');\n\n        // Prepare data for single request\n        const excelData = this.prepareExcelData([this.currentRequest]);\n\n        // Check if xlsx library is available\n        if (typeof XLSX === 'undefined') {\n          // Fallback to CSV if xlsx is not available\n          this.showToast('Warning', 'Excel library not available. Downloading as CSV instead.', 'warning');\n          this.downloadAsCSV(excelData.mainSheet, `request_${this.currentRequest.request_number}_export`);\n          return;\n        }\n\n        // Create Excel workbook\n        const wb = XLSX.utils.book_new();\n\n        // Add main sheet with single request data\n        const mainWs = XLSX.utils.aoa_to_sheet(excelData.mainSheet);\n        XLSX.utils.book_append_sheet(wb, mainWs, 'Request Details');\n\n        // Add document-specific sheet if applicable\n        if (this.currentRequest.document_type === 'Cedula' && excelData.cedulaSheet.length > 1) {\n          const cedulaWs = XLSX.utils.aoa_to_sheet(excelData.cedulaSheet);\n          XLSX.utils.book_append_sheet(wb, cedulaWs, 'Cedula Details');\n        } else if (this.currentRequest.document_type === 'Barangay Clearance' && excelData.barangaySheet.length > 1) {\n          const barangayWs = XLSX.utils.aoa_to_sheet(excelData.barangaySheet);\n          XLSX.utils.book_append_sheet(wb, barangayWs, 'Barangay Clearance Details');\n        }\n\n        // Set column widths\n        this.setExcelColumnWidths(wb);\n\n        // Generate filename with request number\n        const filename = `request_${this.currentRequest.request_number}_export_${new Date().toISOString().split('T')[0]}.xlsx`;\n\n        // Write and download the file\n        XLSX.writeFile(wb, filename);\n        this.showToast('Success', 'Request exported to Excel successfully!', 'success');\n      } catch (error) {\n        console.error('Failed to export single request to Excel:', error);\n        this.showToast('Error', 'Failed to export request to Excel', 'error');\n      }\n    },\n    // Export single request to PDF\n    async exportSingleRequestToPDF() {\n      try {\n        if (!this.currentRequest) {\n          this.showToast('Warning', 'No request selected for export', 'warning');\n          return;\n        }\n        this.showToast('Info', 'Generating PDF export...', 'info');\n\n        // Create PDF document\n        const pdf = new jsPDF();\n\n        // Generate PDF content\n        this.generateRequestPDF(pdf, this.currentRequest);\n\n        // Generate filename with request number\n        const filename = `Request_${this.currentRequest.request_number || 'Unknown'}.pdf`;\n\n        // Download PDF\n        pdf.save(filename);\n        this.showToast('Success', 'Request exported to PDF successfully!', 'success');\n      } catch (error) {\n        console.error('Failed to export single request to PDF:', error);\n        this.showToast('Error', 'Failed to export request to PDF', 'error');\n      }\n    },\n    // Generate PDF content for single request\n    generateRequestPDF(pdf, request) {\n      // Document Header\n      pdf.setFontSize(20);\n      pdf.setFont('helvetica', 'bold');\n      pdf.setTextColor(44, 62, 80);\n      pdf.text('BARANGAY DOCUMENT REQUEST DETAILS', 105, 25, {\n        align: 'center'\n      });\n\n      // Decorative line\n      pdf.setDrawColor(52, 152, 219);\n      pdf.setLineWidth(1);\n      pdf.line(20, 30, 190, 30);\n      let yPosition = 45;\n      const lineHeight = 8;\n      const sectionSpacing = 12;\n\n      // Helper function to add section header\n      const addSectionHeader = title => {\n        // Check if we need a new page before adding section header\n        checkPageBreak(lineHeight + 10); // Reserve space for header and some content\n\n        pdf.setFontSize(14);\n        pdf.setFont('helvetica', 'bold');\n        pdf.setTextColor(52, 152, 219);\n        pdf.text(title, 20, yPosition);\n        yPosition += lineHeight + 2;\n      };\n\n      // Helper function to check if we need a new page\n      const checkPageBreak = (requiredSpace = 20) => {\n        if (yPosition + requiredSpace > 270) {\n          // Leave space for footer\n          pdf.addPage();\n          yPosition = 20;\n        }\n      };\n\n      // Helper function to add field with text wrapping\n      const addField = (label, value) => {\n        // Check if we need a new page before adding content\n        checkPageBreak(lineHeight * 3); // Reserve space for at least 3 lines\n\n        pdf.setFontSize(11);\n        pdf.setFont('helvetica', 'bold');\n        pdf.setTextColor(0, 0, 0);\n        pdf.text(`${label}:`, 20, yPosition);\n        pdf.setFont('helvetica', 'normal');\n        pdf.setTextColor(60, 60, 60);\n        const displayValue = value || 'N/A';\n\n        // Calculate available width for text (page width - left margin - label width - right margin)\n        const maxWidth = 190 - 80 - 10; // 100 units available for text\n\n        // Split text into lines that fit within the available width\n        const textLines = pdf.splitTextToSize(displayValue, maxWidth);\n\n        // Check if all lines will fit on current page\n        const totalHeight = textLines.length * lineHeight;\n        if (yPosition + totalHeight > 270) {\n          pdf.addPage();\n          yPosition = 20;\n          // Re-add the label on the new page\n          pdf.setFontSize(11);\n          pdf.setFont('helvetica', 'bold');\n          pdf.setTextColor(0, 0, 0);\n          pdf.text(`${label}:`, 20, yPosition);\n        }\n\n        // Add each line\n        textLines.forEach((line, index) => {\n          pdf.text(line, 80, yPosition + index * lineHeight);\n        });\n\n        // Update yPosition based on number of lines used\n        yPosition += textLines.length * lineHeight;\n      };\n\n      // Request Information Section\n      addSectionHeader('REQUEST INFORMATION');\n      addField('Request Number', request.request_number);\n      addField('Document Type', request.document_type);\n      addField('Status', this.formatStatus(request.status_name));\n      addField('Submitted Date', this.formatDate(request.requested_at));\n      addField('Last Updated', this.formatDate(request.updated_at));\n      addField('Purpose Category', request.purpose_category);\n      addField('Purpose Details', request.purpose_details);\n      yPosition += sectionSpacing;\n\n      // Client Information Section\n      addSectionHeader('CLIENT INFORMATION');\n      addField('Full Name', this.getClientFullName(request));\n      addField('Email Address', request.client_email);\n      addField('Phone Number', request.client_phone);\n      addField('Date of Birth', this.formatDate(request.client_birth_date));\n      addField('Gender', this.formatGender(request.client_gender));\n      addField('Civil Status', this.getCivilStatusName(request.client_civil_status_id));\n      addField('Nationality', request.client_nationality);\n      addField('Complete Address', this.getClientFullAddress(request));\n      addField('Years of Residency', this.getResidencyDisplay(request));\n      yPosition += sectionSpacing;\n\n      // Third Party Request Information (if applicable)\n      if (request.is_third_party_request && request.beneficiary) {\n        addSectionHeader('THIRD PARTY REQUEST - BENEFICIARY INFORMATION');\n        addField('Full Name', request.beneficiary.full_name);\n        addField('Email Address', request.beneficiary.email);\n        addField('Phone Number', request.beneficiary.phone_number);\n        addField('Date of Birth', this.formatDate(request.beneficiary.birth_date));\n        addField('Gender', this.formatGender(request.beneficiary.gender));\n        addField('Civil Status', this.getCivilStatusName(request.beneficiary.civil_status_id));\n        addField('Nationality', request.beneficiary.nationality);\n        addField('Address', request.beneficiary.address);\n        addField('Relationship to Requestor', this.formatRelationship(request.beneficiary.relationship_to_requestor));\n        yPosition += sectionSpacing;\n      }\n\n      // Authorized Pickup Information (if applicable)\n      if (request.authorized_pickup) {\n        addSectionHeader('AUTHORIZED PICKUP PERSON');\n        addField('Full Name', request.authorized_pickup.full_name);\n        addField('Phone Number', request.authorized_pickup.phone_number);\n        addField('Relationship', this.formatRelationship(request.authorized_pickup.relationship_to_beneficiary));\n        yPosition += sectionSpacing;\n      }\n\n      // Payment Information Section\n      addSectionHeader('PAYMENT INFORMATION');\n      addField('Payment Method', request.payment_method);\n      addField('Payment Status', this.formatPaymentStatus(request.payment_status));\n      addField('Total Fee', this.formatCurrencyForPDF(request.total_fee || request.total_document_fee || 0));\n      yPosition += sectionSpacing;\n\n      // Admin Notes (if any)\n      if (request.admin_notes) {\n        addSectionHeader('ADMIN NOTES');\n        addField('Notes', request.admin_notes);\n        yPosition += sectionSpacing;\n      }\n\n      // Document-Specific Information for Cedula\n      if (request.document_type === 'Cedula' && request.specific_details) {\n        addSectionHeader('CEDULA DOCUMENT DETAILS');\n        addField('Annual Income', this.formatCurrencyForPDF(request.specific_details.annual_income || 0));\n        addField('Occupation', request.specific_details.occupation);\n        addField('Employer/Business', request.specific_details.employer_business);\n        addField('TIN Number', request.specific_details.tin_number);\n        addField('Height (cm)', request.specific_details.height_cm);\n        addField('Weight (kg)', request.specific_details.weight_kg);\n        addField('ICR Number', request.specific_details.icr_number);\n        yPosition += sectionSpacing;\n      }\n\n      // Document-Specific Information for Barangay Clearance\n      if (request.document_type === 'Barangay Clearance' && request.specific_details) {\n        addSectionHeader('BARANGAY CLEARANCE DETAILS');\n        addField('Clearance Type', request.specific_details.clearance_type);\n        addField('Business Name', request.specific_details.business_name);\n        addField('Business Address', request.specific_details.business_address);\n        addField('Business Type', request.specific_details.business_type);\n        yPosition += sectionSpacing;\n      }\n\n      // Add footer\n      this.addPDFFooter(pdf);\n    },\n    // Add professional footer to PDF\n    addPDFFooter(pdf) {\n      const pageCount = pdf.internal.getNumberOfPages();\n      for (let i = 1; i <= pageCount; i++) {\n        pdf.setPage(i);\n\n        // Footer line\n        pdf.setDrawColor(200, 200, 200);\n        pdf.setLineWidth(0.5);\n        pdf.line(20, 280, 190, 280);\n\n        // Footer text\n        pdf.setFontSize(9);\n        pdf.setFont('helvetica', 'normal');\n        pdf.setTextColor(100, 100, 100);\n\n        // Left side - Generated info\n        const generatedDate = new Date().toLocaleDateString('en-US', {\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n          hour: '2-digit',\n          minute: '2-digit'\n        });\n        pdf.text(`Generated on: ${generatedDate}`, 20, 285);\n\n        // Center - Barangay info\n        pdf.text('Barangay Bula Document Management System', 105, 285, {\n          align: 'center'\n        });\n\n        // Right side - Page number\n        pdf.text(`Page ${i} of ${pageCount}`, 190, 285, {\n          align: 'right'\n        });\n      }\n    },\n    // Verify in-person payment\n    async verifyInPersonPayment() {\n      if (!this.paymentVerificationForm.amount_received || !this.currentRequest) {\n        this.showToast('Error', 'Please enter the amount received', 'error');\n        return;\n      }\n      const totalFee = parseFloat(this.currentRequest.total_document_fee || this.currentRequest.total_fee);\n      const amountReceived = parseFloat(this.paymentVerificationForm.amount_received);\n      if (amountReceived < totalFee) {\n        this.showToast('Error', `Insufficient payment. Required: ${this.formatCurrency(totalFee)}`, 'error');\n        return;\n      }\n      this.paymentVerificationForm.loading = true;\n      this.paymentVerificationForm.error = '';\n      try {\n        const paymentData = {\n          amount_received: amountReceived,\n          payment_method_id: this.currentRequest.payment_method_id || 1,\n          // Default to cash\n          receipt_number: this.paymentVerificationForm.receipt_number\n        };\n        const response = await adminDocumentService.verifyInPersonPayment(this.currentRequest.id, paymentData);\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n\n          // Reset form\n          this.paymentVerificationForm = {\n            amount_received: '',\n            receipt_number: '',\n            loading: false,\n            error: ''\n          };\n          this.showToast('Success', 'Payment verified successfully', 'success');\n        }\n      } catch (error) {\n        console.error('Failed to verify payment:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.paymentVerificationForm.error = errorData.message || 'Failed to verify payment';\n        this.showToast('Error', errorData.message || 'Failed to verify payment', 'error');\n      } finally {\n        this.paymentVerificationForm.loading = false;\n      }\n    },\n    // Schedule pickup appointment\n    async schedulePickup() {\n      if (!this.isPickupFormValid() || !this.currentRequest) {\n        this.showToast('Error', 'Please fill in all required fields', 'error');\n        return;\n      }\n      this.pickupScheduleForm.loading = true;\n      this.pickupScheduleForm.error = '';\n      try {\n        const scheduleData = {\n          scheduled_date: this.pickupScheduleForm.scheduled_date,\n          scheduled_time_start: this.pickupScheduleForm.scheduled_time_start,\n          scheduled_time_end: this.pickupScheduleForm.scheduled_time_end\n        };\n        const response = await adminDocumentService.schedulePickup(this.currentRequest.id, scheduleData);\n        if (response.success) {\n          await this.refreshRequestDetails();\n          await this.loadRequests();\n\n          // Reset form\n          this.pickupScheduleForm = {\n            scheduled_date: '',\n            scheduled_time_start: '',\n            scheduled_time_end: '',\n            loading: false,\n            error: ''\n          };\n          this.showToast('Success', 'Pickup scheduled successfully', 'success');\n        }\n      } catch (error) {\n        console.error('Failed to schedule pickup:', error);\n        const errorData = adminDocumentService.parseError(error);\n        this.pickupScheduleForm.error = errorData.message || 'Failed to schedule pickup';\n        this.showToast('Error', errorData.message || 'Failed to schedule pickup', 'error');\n      } finally {\n        this.pickupScheduleForm.loading = false;\n      }\n    },\n    // Utility methods\n    formatStatus(status) {\n      return adminDocumentService.formatStatus(status);\n    },\n    getStatusColor(status) {\n      return adminDocumentService.getStatusColor(status);\n    },\n    // Enhanced fee display method with debugging\n    getDisplayFee(request) {\n      const totalDocumentFee = parseFloat(request.total_document_fee);\n      const totalFee = parseFloat(request.total_fee);\n\n      // Debug logging for Cedula requests\n      if (request.document_type === 'Cedula') {\n        console.log(`üîç Cedula Fee Debug - Request ${request.request_number}:`, {\n          total_document_fee: request.total_document_fee,\n          total_fee: request.total_fee,\n          parsed_total_document_fee: totalDocumentFee,\n          parsed_total_fee: totalFee,\n          will_display: totalDocumentFee || totalFee || 0\n        });\n      }\n\n      // Prioritize total_document_fee, fallback to total_fee\n      return totalDocumentFee || totalFee || 0;\n    },\n    // Check if request has convenience fee\n    hasConvenienceFee(request) {\n      const baseFee = this.getBaseFee(request);\n      const totalFee = this.getDisplayFee(request);\n      return totalFee > baseFee && baseFee > 0;\n    },\n    // Get base document fee (without convenience fee)\n    getBaseFee(request) {\n      const documentType = request.document_type;\n      const totalFee = this.getDisplayFee(request);\n\n      // For Cedula requests, calculate the actual document fee\n      if (documentType === 'Cedula') {\n        // If total is ‚Ç±100.00, the base fee is likely ‚Ç±30.00 (with ‚Ç±70.00 convenience fee)\n        if (totalFee === 100.00) {\n          return 30.00; // Standard Cedula fee for ‚Ç±20K income\n        }\n        // For other amounts, assume no convenience fee for now\n        return totalFee;\n      }\n\n      // For other document types, check if convenience fee was applied\n      const PAYMONGO_MINIMUM = 100.00;\n      if (totalFee === PAYMONGO_MINIMUM && documentType !== 'Barangay Clearance') {\n        // Likely has convenience fee - estimate base fee\n        return totalFee - (PAYMONGO_MINIMUM - totalFee);\n      }\n      return totalFee;\n    },\n    // Get convenience fee amount\n    getConvenienceFee(request) {\n      const baseFee = this.getBaseFee(request);\n      const totalFee = this.getDisplayFee(request);\n      return Math.max(0, totalFee - baseFee);\n    },\n    // Get convenience fee explanation\n    getConvenienceFeeExplanation(request) {\n      const convenienceFee = this.getConvenienceFee(request);\n      if (convenienceFee > 0) {\n        return `PayMongo requires a minimum payment of ‚Ç±100.00. A convenience fee of ‚Ç±${convenienceFee.toFixed(2)} was added to meet this requirement.`;\n      }\n      return '';\n    },\n    formatDate(dateString) {\n      console.log('üóìÔ∏è formatDate called with:', dateString);\n      if (!dateString) {\n        console.log('üóìÔ∏è formatDate: No date provided, returning null');\n        return null;\n      }\n      const date = new Date(dateString);\n      const formatted = date.toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n      console.log('üóìÔ∏è formatDate result:', formatted);\n      return formatted;\n    },\n    formatCurrency(amount) {\n      return new Intl.NumberFormat('en-PH', {\n        style: 'currency',\n        currency: 'PHP'\n      }).format(amount || 0);\n    },\n    // PDF-specific currency formatting (avoids special character issues in jsPDF)\n    formatCurrencyForPDF(amount) {\n      const numAmount = parseFloat(amount) || 0;\n      return `PHP ${numAmount.toLocaleString('en-US', {\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n      })}`;\n    },\n    formatDateTime(dateString) {\n      if (!dateString) return 'N/A';\n      return new Date(dateString).toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n    },\n    // Get formatted changed by name for status history\n    getChangedByName(history) {\n      // If the reason starts with \"SYSTEM:\", show \"System\" regardless of changed_by_name\n      if (history.change_reason && history.change_reason.startsWith('SYSTEM:')) {\n        return 'System';\n      }\n      return history.changed_by_name || 'System';\n    },\n    // Get formatted reason for status history\n    getFormattedReason(reason) {\n      if (!reason) return '';\n      // Remove \"SYSTEM:\" prefix if present\n      if (reason.startsWith('SYSTEM:')) {\n        return reason.substring(7).trim(); // Remove \"SYSTEM:\" and trim whitespace\n      }\n      return reason;\n    },\n    // New helper methods for complete client information\n    getClientFullName(request) {\n      if (!request) return 'Not provided';\n      const parts = [request.client_first_name, request.client_middle_name, request.client_last_name, request.client_suffix].filter(Boolean);\n      return parts.length > 0 ? parts.join(' ') : request.client_name || 'Not provided';\n    },\n    getClientFullAddress(request) {\n      if (!request) return null;\n      const parts = [request.client_house_number, request.client_street, request.client_subdivision, request.client_barangay, request.client_city_municipality || request.client_city, request.client_province].filter(Boolean);\n      return parts.length > 0 ? parts.join(', ') : request.client_address || null;\n    },\n    formatGender(gender) {\n      if (!gender) {\n        return null;\n      }\n      return gender.charAt(0).toUpperCase() + gender.slice(1);\n    },\n    getCivilStatusName(statusId) {\n      const statuses = {\n        1: 'Single',\n        2: 'Married',\n        3: 'Divorced',\n        4: 'Widowed',\n        5: 'Separated'\n      };\n      return statuses[statusId] || null;\n    },\n    // New helper methods for third-party requests\n    formatRelationship(relationship) {\n      if (!relationship) return 'Not specified';\n      const relationships = {\n        'spouse': 'Spouse',\n        'child': 'Child',\n        'parent': 'Parent',\n        'sibling': 'Sibling',\n        'relative': 'Other Relative',\n        'friend': 'Friend',\n        'colleague': 'Colleague',\n        // 'other': 'Other',\n        'self': 'Self'\n      };\n      return relationships[relationship] || relationship.charAt(0).toUpperCase() + relationship.slice(1);\n    },\n    formatAuthorizationStatus(status) {\n      if (!status) return 'Pending';\n      const statuses = {\n        'pending': 'Pending Verification',\n        'verified': 'Verified',\n        'rejected': 'Rejected'\n      };\n      return statuses[status] || status.charAt(0).toUpperCase() + status.slice(1);\n    },\n    getAuthorizationStatusClass(status) {\n      const classes = {\n        'pending': 'bg-warning text-dark',\n        'verified': 'bg-success',\n        'rejected': 'bg-danger'\n      };\n      return classes[status] || 'bg-secondary';\n    },\n    getAuthorizationStatusIcon(status) {\n      const icons = {\n        'pending': 'fa-clock',\n        'verified': 'fa-check-circle',\n        'rejected': 'fa-times-circle'\n      };\n      return icons[status] || 'fa-question-circle';\n    },\n    // Authorization verification methods\n    async verifyAuthorization(requestId, isApproved) {\n      try {\n        // This would call a new API endpoint for authorization verification\n        // const response = await adminDocumentService.verifyAuthorization(requestId, {\n        //   isApproved,\n        //   notes: isApproved ? 'Authorization verified and approved' : 'Authorization rejected'\n        // });\n\n        // For now, show a placeholder message\n        this.showToast('Authorization ' + (isApproved ? 'Approved' : 'Rejected'), `Pickup authorization has been ${isApproved ? 'approved' : 'rejected'}`, isApproved ? 'success' : 'warning');\n\n        // Refresh the request details\n        await this.refreshRequestDetails();\n      } catch (error) {\n        console.error('Failed to verify authorization:', error);\n        this.errorMessage = 'Failed to verify authorization. Please try again.';\n      }\n    },\n    getResidencyDisplay(request) {\n      if (!request) return null;\n      const years = request.client_years_of_residency;\n      const months = request.client_months_of_residency;\n      if (!years && !months) return null; // Return null so the template can handle \"Not provided\"\n\n      const parts = [];\n      if (years) parts.push(`${years} year${years > 1 ? 's' : ''}`);\n      if (months) parts.push(`${months} month${months > 1 ? 's' : ''}`);\n      return parts.join(' and ');\n    },\n    formatTime(dateString) {\n      if (!dateString) return '';\n      const date = new Date(dateString);\n      return date.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: true\n      });\n    },\n    // Real-time features\n    async initializeRealTimeFeatures() {\n      console.log('Initializing real-time features for AdminRequests');\n      try {\n        // Initialize notification service\n        await notificationService.init('admin');\n\n        // Listen for request-related notifications\n        notificationService.on('notification', this.handleRealTimeNotification);\n        notificationService.on('request_status_changed', this.handleStatusChange);\n        notificationService.on('new_request', this.handleNewRequest);\n\n        // Start auto-refresh if enabled\n        if (this.autoRefreshEnabled) {\n          this.startAutoRefresh();\n        }\n      } catch (error) {\n        console.error('Failed to initialize real-time features:', error);\n      }\n    },\n    cleanupRealTimeFeatures() {\n      console.log('Cleaning up real-time features for AdminRequests');\n\n      // Remove notification listeners\n      notificationService.off('notification', this.handleRealTimeNotification);\n      notificationService.off('request_status_changed', this.handleStatusChange);\n      notificationService.off('new_request', this.handleNewRequest);\n\n      // Cleanup (simplified)\n      notificationService.cleanup();\n\n      // Stop auto-refresh\n      this.stopAutoRefresh();\n    },\n    startAutoRefresh() {\n      if (this.refreshInterval) {\n        clearInterval(this.refreshInterval);\n      }\n      this.refreshInterval = setInterval(() => {\n        if (this.autoRefreshEnabled && !this.loading) {\n          console.log('Auto-refreshing requests data...');\n          this.refreshRequestsData();\n        }\n      }, this.refreshRate);\n      console.log(`Auto-refresh started with ${this.refreshRate / 1000}s interval`);\n    },\n    stopAutoRefresh() {\n      if (this.refreshInterval) {\n        clearInterval(this.refreshInterval);\n        this.refreshInterval = null;\n        console.log('Auto-refresh stopped');\n      }\n    },\n    toggleAutoRefresh() {\n      this.autoRefreshEnabled = !this.autoRefreshEnabled;\n      if (this.autoRefreshEnabled) {\n        this.startAutoRefresh();\n      } else {\n        this.stopAutoRefresh();\n      }\n    },\n    async refreshRequestsData() {\n      try {\n        this.lastRefresh = new Date();\n\n        // Refresh requests list\n        await this.loadRequests();\n\n        // Refresh statistics\n        await this.loadDashboardStats();\n\n        // If request details modal is open, refresh it\n        if (this.showRequestDetails && this.currentRequest) {\n          await this.refreshRequestDetails();\n        }\n        console.log('Requests data refreshed successfully');\n      } catch (error) {\n        console.error('Failed to refresh requests data:', error);\n      }\n    },\n    handleRealTimeNotification(notification) {\n      console.log('Real-time notification received:', notification);\n\n      // Handle different notification types\n      switch (notification.type) {\n        case 'request_status_changed':\n          this.handleStatusChange(notification.data);\n          break;\n        case 'new_request':\n          this.handleNewRequest(notification.data);\n          break;\n        case 'request_updated':\n          this.handleRequestUpdate(notification.data);\n          break;\n        case 'unread_count_update':\n        case 'heartbeat':\n          // Polling system notifications - handled by notification service\n          break;\n        default:\n          // Only log unknown types, not system types\n          if (!['unread_count_update', 'heartbeat'].includes(notification.type)) {\n            console.log('Unhandled notification type:', notification.type);\n          }\n      }\n    },\n    handleStatusChange(data) {\n      console.log('üîÑ Request status changed:', data);\n      console.log('üîç Data properties:', {\n        request_id: data.request_id,\n        new_status: data.new_status,\n        payment_status: data.payment_status,\n        amount: data.amount\n      });\n\n      // Update the request in the list if it exists\n      const requestId = data.request_id;\n      if (!requestId) {\n        console.warn('‚ö†Ô∏è No request_id in status change data');\n        return;\n      }\n      const requestIndex = this.requests.findIndex(req => req.id == requestId);\n      if (requestIndex !== -1) {\n        console.log(`üìù Updating request #${data.request_id} in the list`);\n\n        // Update the specific request in the list for immediate UI update\n        const updatedRequest = {\n          ...this.requests[requestIndex]\n        };\n\n        // Map the status based on the new status\n        if (data.new_status === 'payment_confirmed') {\n          updatedRequest.status_name = 'Payment Confirmed';\n          updatedRequest.status_id = 11;\n          updatedRequest.payment_status = 'paid';\n        } else if (data.new_status === 'payment_failed') {\n          updatedRequest.status_name = 'Payment Failed';\n          updatedRequest.payment_status = 'failed';\n        }\n\n        // Update the timestamp\n        updatedRequest.updated_at = data.timestamp || new Date().toISOString();\n\n        // Replace the request in the array\n        this.$set(this.requests, requestIndex, updatedRequest);\n\n        // Also refresh data in background to ensure consistency\n        setTimeout(() => {\n          this.refreshRequestsData();\n        }, 1000);\n        console.log(`‚úÖ Request #${data.request_id} updated in real-time`);\n      } else {\n        console.log(`üìÑ Request #${data.request_id} not in current view, refreshing data`);\n        // If request is not in current view, just refresh\n        this.refreshRequestsData();\n      }\n\n      // Show toast notification with payment-specific message\n      const toastRequestId = data.request_id || 'Unknown';\n      const newStatus = data.new_status || 'unknown';\n      let title = 'Status Update';\n      let message = `Request #${toastRequestId} status changed`;\n      let type = 'info';\n      if (newStatus === 'payment_confirmed') {\n        title = 'Payment Confirmed';\n        message = `Payment confirmed for request #${toastRequestId}`;\n        type = 'success';\n      } else if (newStatus === 'payment_failed') {\n        title = 'Payment Failed';\n        message = `Payment failed for request #${toastRequestId}`;\n        type = 'error';\n      }\n      console.log('üîî Showing toast:', {\n        title,\n        message,\n        type\n      });\n      this.showToast(title, message, type);\n    },\n    handleNewRequest(data) {\n      console.log('New request received:', data);\n\n      // Refresh requests to show the new request\n      this.refreshRequestsData();\n\n      // Show toast notification\n      this.showToast('New Request', `New ${data.document_type} request received`, 'success');\n    },\n    handleRequestUpdate(data) {\n      console.log('Request updated:', data);\n\n      // If the updated request is currently being viewed, refresh details\n      if (this.currentRequest && this.currentRequest.id === data.request_id) {\n        this.refreshRequestDetails();\n      }\n\n      // Refresh the requests list\n      this.refreshRequestsData();\n    },\n    showToast(title, message, type = 'info') {\n      // Enhanced debugging\n      console.log('üîî showToast called with:', {\n        title: title,\n        titleType: typeof title,\n        message: message,\n        messageType: typeof message,\n        type: type\n      });\n\n      // Handle undefined values\n      const safeTitle = title || 'Notification';\n      const safeMessage = message || 'No message provided';\n\n      // Log to console for debugging\n      console.log(`[${type.toUpperCase()}] ${safeTitle}: ${safeMessage}`);\n\n      // Create a simple toast notification\n      const toast = document.createElement('div');\n      toast.className = `toast-notification toast-${type}`;\n      toast.innerHTML = `\n        <div class=\"toast-header\">\n          <strong>${safeTitle}</strong>\n          <button type=\"button\" class=\"toast-close\" onclick=\"this.parentElement.parentElement.remove()\">√ó</button>\n        </div>\n        <div class=\"toast-body\">${safeMessage}</div>\n      `;\n\n      // Add toast styles if not already added\n      if (!document.getElementById('toast-styles')) {\n        const styles = document.createElement('style');\n        styles.id = 'toast-styles';\n        styles.textContent = `\n          .toast-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 9999;\n            animation: slideIn 0.3s ease;\n          }\n          .toast-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 16px 8px;\n            border-bottom: 1px solid #e9ecef;\n          }\n          .toast-body {\n            padding: 8px 16px 12px;\n            color: #6c757d;\n          }\n          .toast-close {\n            background: none;\n            border: none;\n            font-size: 18px;\n            cursor: pointer;\n            color: #6c757d;\n          }\n          .toast-success { border-left: 4px solid #28a745; }\n          .toast-error { border-left: 4px solid #dc3545; }\n          .toast-info { border-left: 4px solid #17a2b8; }\n          .toast-warning { border-left: 4px solid #ffc107; }\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        `;\n        document.head.appendChild(styles);\n      }\n\n      // Add toast to page\n      document.body.appendChild(toast);\n\n      // Auto-remove after 5 seconds\n      setTimeout(() => {\n        if (toast.parentElement) {\n          toast.style.animation = 'slideIn 0.3s ease reverse';\n          setTimeout(() => toast.remove(), 300);\n        }\n      }, 5000);\n    },\n    // Document handling methods\n    getDocumentTypeDisplayName(type) {\n      const displayNames = {\n        'government_id': 'Government ID',\n        'proof_of_residency': 'Proof of Residency',\n        'cedula': 'Community Tax Certificate (Cedula)',\n        'birth_certificate': 'Birth Certificate',\n        'marriage_certificate': 'Marriage Certificate',\n        'other': 'Other Document'\n      };\n      return displayNames[type] || type;\n    },\n    isImageFile(mimeType) {\n      return mimeType && (mimeType.startsWith('image/') || ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'].includes(mimeType));\n    },\n    isPdfFile(mimeType) {\n      return mimeType === 'application/pdf';\n    },\n    async loadDocumentUrls(documents) {\n      // Filter documents that need loading (images only, not already loaded/loading/failed)\n      const documentsToLoad = documents.filter(doc => this.isImageFile(doc.mime_type) && !this.documentUrls[doc.id] && !this.loadingDocuments.has(doc.id) && !this.failedDocuments.has(doc.id));\n      if (documentsToLoad.length === 0) return;\n\n      // Load documents in parallel with concurrency limit\n      const CONCURRENT_LIMIT = 3;\n      const chunks = this.chunkArray(documentsToLoad, CONCURRENT_LIMIT);\n      for (const chunk of chunks) {\n        await Promise.allSettled(chunk.map(document => this.loadSingleDocument(document)));\n      }\n    },\n    async loadSingleDocument(document, isForModal = false) {\n      const docId = document.id;\n      try {\n        // Mark as loading\n        this.loadingDocuments.add(docId);\n        if (isForModal) this.imageLoadingInModal = true;\n\n        // Use authenticated API call to get the document\n        const response = await api.get(`/documents/view/${docId}`, {\n          responseType: 'blob',\n          timeout: 15000,\n          // Increased timeout for large images\n          onDownloadProgress: progressEvent => {\n            // Optional: Could emit progress events here\n            if (progressEvent.lengthComputable) {\n              const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n              console.log(`Loading ${docId}: ${percentCompleted}%`);\n            }\n          }\n        });\n\n        // Validate response\n        if (!response.data || response.data.size === 0) {\n          throw new Error('Empty response received');\n        }\n\n        // Check file size and optimize if needed\n        const blob = response.data;\n        const optimizedBlob = await this.optimizeImageBlob(blob, document.mime_type, isForModal);\n\n        // Create blob URL using requestIdleCallback for better performance\n        await this.createBlobUrlWhenIdle(docId, optimizedBlob);\n\n        // Remove from failed set if it was there\n        this.failedDocuments.delete(docId);\n        if (isForModal) this.modalImageError = false;\n      } catch (error) {\n        console.warn(`Failed to load document ${docId}:`, error.message);\n        this.failedDocuments.add(docId);\n        if (isForModal) this.modalImageError = true;\n\n        // Optionally retry after a delay for network errors\n        if (error.code === 'NETWORK_ERROR' || error.code === 'ECONNABORTED') {\n          setTimeout(() => {\n            this.failedDocuments.delete(docId);\n          }, 30000); // Retry after 30 seconds\n        }\n      } finally {\n        // Remove from loading set\n        this.loadingDocuments.delete(docId);\n        if (isForModal) this.imageLoadingInModal = false;\n      }\n    },\n    chunkArray(array, size) {\n      const chunks = [];\n      for (let i = 0; i < array.length; i += size) {\n        chunks.push(array.slice(i, i + size));\n      }\n      return chunks;\n    },\n    async getDocumentUrl(document) {\n      // This method is now deprecated in favor of loadDocumentUrls\n      // Keeping for backward compatibility\n      if (this.documentUrls[document.id]) {\n        return this.documentUrls[document.id];\n      }\n      return null;\n    },\n    formatFileSize(bytes) {\n      if (!bytes) return '0 B';\n      const k = 1024;\n      const sizes = ['B', 'KB', 'MB', 'GB'];\n      const i = Math.floor(Math.log(bytes) / Math.log(k));\n      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    },\n    async openImageModal(document) {\n      // Prevent multiple rapid clicks\n      if (this.imageLoadingInModal) return;\n\n      // Don't open modal if document failed to load and we're not retrying\n      if (this.failedDocuments.has(document.id)) {\n        return;\n      }\n\n      // Set modal state immediately for responsiveness\n      this.selectedImage = document;\n      this.showImageModal = true;\n      this.modalImageError = false;\n\n      // Use nextTick to ensure DOM is updated before heavy operations\n      await this.$nextTick();\n\n      // If image isn't loaded yet, try to load it with modal optimization\n      if (!this.documentUrls[document.id] && !this.loadingDocuments.has(document.id)) {\n        await this.loadSingleDocument(document, true);\n      }\n    },\n    async retryLoadDocument(document) {\n      // Remove from failed set and retry loading\n      this.failedDocuments.delete(document.id);\n      this.modalImageError = false;\n      await this.loadSingleDocument(document, true);\n    },\n    onModalImageLoad() {\n      // Called when modal image finishes loading\n      this.imageLoadingInModal = false;\n    },\n    cleanupDocumentUrls() {\n      // Revoke all blob URLs to prevent memory leaks\n      Object.values(this.documentUrls).forEach(url => {\n        if (url) URL.revokeObjectURL(url);\n      });\n\n      // Clear all tracking sets and objects\n      this.documentUrls = {};\n      this.loadingDocuments.clear();\n      this.failedDocuments.clear();\n    },\n    preloadImage(document) {\n      // Preload image on hover for better UX\n      if (!this.documentUrls[document.id] && !this.loadingDocuments.has(document.id) && !this.failedDocuments.has(document.id)) {\n        this.loadSingleDocument(document, false);\n      }\n    },\n    async optimizeImageBlob(blob, mimeType, isForModal = false) {\n      // For very large images, we might want to resize them\n      const MAX_SIZE = isForModal ? 5 * 1024 * 1024 : 2 * 1024 * 1024; // 5MB for modal, 2MB for preview\n\n      if (blob.size <= MAX_SIZE) {\n        return blob; // No optimization needed\n      }\n      try {\n        // Create image element for resizing\n        const img = new Image();\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        return new Promise(resolve => {\n          img.onload = () => {\n            // Calculate new dimensions (maintain aspect ratio)\n            const maxDimension = isForModal ? 1920 : 800;\n            let {\n              width,\n              height\n            } = img;\n            if (width > height && width > maxDimension) {\n              height = height * maxDimension / width;\n              width = maxDimension;\n            } else if (height > maxDimension) {\n              width = width * maxDimension / height;\n              height = maxDimension;\n            }\n\n            // Set canvas size and draw resized image\n            canvas.width = width;\n            canvas.height = height;\n            ctx.drawImage(img, 0, 0, width, height);\n\n            // Convert to blob with compression\n            canvas.toBlob(optimizedBlob => {\n              resolve(optimizedBlob || blob); // Fallback to original if optimization fails\n            }, mimeType, 0.85 // 85% quality\n            );\n          };\n          img.onerror = () => resolve(blob); // Fallback to original\n          img.src = URL.createObjectURL(blob);\n        });\n      } catch (error) {\n        console.warn('Image optimization failed:', error);\n        return blob; // Fallback to original\n      }\n    },\n    async createBlobUrlWhenIdle(docId, blob) {\n      return new Promise(resolve => {\n        const createUrl = () => {\n          this.documentUrls[docId] = URL.createObjectURL(blob);\n          resolve();\n        };\n\n        // Use requestIdleCallback if available, otherwise use setTimeout\n        if (window.requestIdleCallback) {\n          window.requestIdleCallback(createUrl, {\n            timeout: 1000\n          });\n        } else {\n          setTimeout(createUrl, 0);\n        }\n      });\n    },\n    closeImageModal() {\n      // Prevent rapid clicking during image loading\n      if (this.imageLoadingInModal) return;\n      this.showImageModal = false;\n      this.selectedImage = null;\n      this.imageLoadingInModal = false;\n      this.modalImageError = false;\n    },\n    async downloadDocument(documentFile) {\n      try {\n        // Use authenticated API call to download the document\n        const response = await api.get(`/documents/download/${documentFile.id}`, {\n          responseType: 'blob'\n        });\n\n        // Create a download link\n        const blob = new Blob([response.data], {\n          type: documentFile.mime_type\n        });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = documentFile.document_name;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      } catch (error) {\n        console.error('Failed to download document:', error);\n        this.showToast('Error', 'Failed to download document', 'error');\n      }\n    },\n    handleImageError(event) {\n      console.error('Failed to load image:', event.target.src);\n      // You could set a placeholder image here\n      event.target.style.display = 'none';\n\n      // Show error message\n      const errorDiv = document.createElement('div');\n      errorDiv.className = 'text-center text-muted p-3';\n      errorDiv.innerHTML = '<i class=\"fas fa-exclamation-triangle\"></i><br>Failed to load image';\n      event.target.parentNode.appendChild(errorDiv);\n    },\n    // Beneficiary verification status methods\n    getBeneficiaryVerificationStatusClass(status) {\n      switch (status) {\n        case 'approved':\n          return 'bg-success';\n        case 'rejected':\n          return 'bg-danger';\n        case 'pending':\n        default:\n          return 'bg-warning';\n      }\n    },\n    getBeneficiaryVerificationStatusText(status) {\n      switch (status) {\n        case 'approved':\n          return 'Verified';\n        case 'rejected':\n          return 'Rejected';\n        case 'pending':\n        default:\n          return 'Pending';\n      }\n    },\n    // View verification image\n    async viewVerificationImage(requestId, imageType) {\n      try {\n        // Find the request to get the filename - check both requests list and currentRequest\n        let request = this.requests.find(r => r.id === requestId);\n\n        // If not found in requests list, check if it's the current request being viewed\n        if (!request && this.currentRequest && this.currentRequest.id === requestId) {\n          request = this.currentRequest;\n        }\n        if (!request) {\n          this.showToast('Error', 'Request not found', 'error');\n          return;\n        }\n        let filename = '';\n        let documentType = '';\n        switch (imageType) {\n          case 'beneficiary':\n            // Handle both list view (beneficiary_verification_image) and detail view (beneficiary.verification_image_path)\n            filename = request.beneficiary_verification_image || request.beneficiary?.verification_image_path;\n            documentType = 'beneficiary';\n            // For beneficiary documents, we need the beneficiary ID, not the request ID\n            if (request.beneficiary?.id) {\n              requestId = request.beneficiary.id;\n            }\n            break;\n          case 'pickup-id':\n            filename = request.pickup_id_image || request.authorized_pickup?.id_image_path;\n            documentType = 'pickup-id';\n            break;\n          case 'pickup-auth':\n            filename = request.pickup_authorization_letter || request.authorized_pickup?.authorization_letter_path;\n            documentType = 'pickup-auth';\n            break;\n          default:\n            this.showToast('Error', 'Invalid image type', 'error');\n            return;\n        }\n        if (!filename) {\n          this.showToast('Error', 'No image available', 'error');\n          return;\n        }\n\n        // Extract just the filename from the path (handle both forward and back slashes)\n        const filenameOnly = filename.split(/[/\\\\]/).pop();\n\n        // Construct the URL for the verification document service\n        const imageUrl = `/verification-documents/serve/${documentType}/${requestId}/${filenameOnly}`;\n\n        // Fetch the image with authentication headers and display in modal\n        await this.displayImageInModal(imageUrl, `${documentType} verification image`);\n      } catch (error) {\n        console.error('Error viewing verification image:', error);\n        this.showToast('Error', 'Failed to view image', 'error');\n      }\n    },\n    // Display image in modal with authentication\n    async displayImageInModal(imageUrl, title) {\n      try {\n        // Import the API service\n        const api = (await import('@/services/api.js')).default;\n\n        // Fetch the image with authentication headers\n        const response = await api.get(imageUrl, {\n          responseType: 'blob'\n        });\n\n        // Create object URL from blob\n        const imageObjectUrl = URL.createObjectURL(response.data);\n\n        // Create and show modal\n        const modalHtml = `\n          <div class=\"modal fade\" id=\"imageViewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n            <div class=\"modal-dialog modal-lg modal-dialog-centered\">\n              <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                  <h5 class=\"modal-title\">${title}</h5>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body text-center\">\n                  <img src=\"${imageObjectUrl}\" class=\"img-fluid\" alt=\"${title}\" style=\"max-height: 70vh;\">\n                </div>\n                <div class=\"modal-footer\">\n                  <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        `;\n\n        // Remove existing modal if any\n        const existingModal = document.getElementById('imageViewModal');\n        if (existingModal) {\n          existingModal.remove();\n        }\n\n        // Add modal to DOM\n        document.body.insertAdjacentHTML('beforeend', modalHtml);\n\n        // Show modal\n        const modal = new Modal(document.getElementById('imageViewModal'));\n        modal.show();\n\n        // Clean up object URL when modal is hidden\n        document.getElementById('imageViewModal').addEventListener('hidden.bs.modal', () => {\n          URL.revokeObjectURL(imageObjectUrl);\n          document.getElementById('imageViewModal').remove();\n        });\n      } catch (error) {\n        console.error('Error displaying image:', error);\n        this.showToast('Error', 'Failed to load image', 'error');\n      }\n    },\n    // View pickup documents in modal\n    async viewPickupDocuments(request) {\n      try {\n        // Set the selected request and show the modal\n        this.selectedRequestForPickup = request;\n\n        // Show modal using Bootstrap\n        const modal = new Modal(document.getElementById('authorizedPickupDocumentsModal'));\n        modal.show();\n      } catch (error) {\n        console.error('Error opening pickup documents modal:', error);\n        this.showToast('Error', 'Failed to open documents modal', 'error');\n      }\n    },\n    // Verify pickup authorization\n    async verifyPickupAuthorization() {\n      if (!this.selectedRequestForPickup) return;\n      this.processingPickupAction = true;\n      try {\n        // This would call a new API endpoint for pickup authorization verification\n        // const response = await adminDocumentService.verifyPickupAuthorization(this.selectedRequestForPickup.id);\n\n        this.showToast('Success', 'Pickup authorization verified successfully', 'success');\n\n        // Close modal\n        const modal = Modal.getInstance(document.getElementById('authorizedPickupDocumentsModal'));\n        if (modal) {\n          modal.hide();\n        }\n\n        // Refresh requests list\n        await this.loadRequests();\n      } catch (error) {\n        console.error('Error verifying pickup authorization:', error);\n        this.showToast('Error', 'Failed to verify pickup authorization', 'error');\n      } finally {\n        this.processingPickupAction = false;\n      }\n    },\n    // Reject pickup authorization\n    async rejectPickupAuthorization() {\n      if (!this.selectedRequestForPickup) return;\n      this.processingPickupAction = true;\n      try {\n        // This would call a new API endpoint for pickup authorization rejection\n        // const response = await adminDocumentService.rejectPickupAuthorization(this.selectedRequestForPickup.id);\n\n        this.showToast('Success', 'Pickup authorization rejected', 'success');\n\n        // Close modal\n        const modal = Modal.getInstance(document.getElementById('authorizedPickupDocumentsModal'));\n        if (modal) {\n          modal.hide();\n        }\n\n        // Refresh requests list\n        await this.loadRequests();\n      } catch (error) {\n        console.error('Error rejecting pickup authorization:', error);\n        this.showToast('Error', 'Failed to reject pickup authorization', 'error');\n      } finally {\n        this.processingPickupAction = false;\n      }\n    },\n    // Update beneficiary verification status\n    async updateBeneficiaryVerificationStatus(beneficiaryId, status, notes = '') {\n      try {\n        const response = await this.$http.put(`/api/verification-documents/beneficiary/${beneficiaryId}/verification-status`, {\n          status,\n          notes\n        });\n        if (response.data.success) {\n          this.showToast('Success', 'Verification status updated successfully', 'success');\n          // Refresh the requests to show updated status\n          await this.loadRequests();\n        } else {\n          throw new Error(response.data.message || 'Failed to update verification status');\n        }\n      } catch (error) {\n        console.error('Error updating verification status:', error);\n        this.showToast('Error', error.response?.data?.message || 'Failed to update verification status', 'error');\n      }\n    },\n    // Open verification modal\n    openVerificationModal(request) {\n      this.currentVerification = {\n        requestId: request.id,\n        beneficiaryId: request.beneficiary_id,\n        beneficiary_name: request.beneficiary_name,\n        relationship: request.beneficiary_relationship,\n        image_url: request.beneficiary_verification_image ? `/verification-documents/serve/beneficiary/${request.id}/${request.beneficiary_verification_image.split('/').pop()}` : null,\n        current_status: request.beneficiary_verification_status\n      };\n      this.verificationForm = {\n        status: request.beneficiary_verification_status || 'pending',\n        notes: ''\n      };\n\n      // Show the modal using Bootstrap\n      const modal = new Modal(document.getElementById('verificationModal'));\n      modal.show();\n    },\n    // Save verification status from modal\n    async saveVerificationStatus() {\n      if (!this.currentVerification) return;\n      try {\n        await this.updateBeneficiaryVerificationStatus(this.currentVerification.beneficiaryId, this.verificationForm.status, this.verificationForm.notes);\n\n        // Close the modal\n        const modal = Modal.getInstance(document.getElementById('verificationModal'));\n        modal.hide();\n\n        // Reset form\n        this.currentVerification = null;\n        this.verificationForm = {\n          status: 'pending',\n          notes: ''\n        };\n      } catch (error) {\n        // Error handling is done in updateBeneficiaryVerificationStatus\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}