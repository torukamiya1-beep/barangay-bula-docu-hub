{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport documentRequestService from '@/services/documentRequestService';\nimport notificationService from '@/services/notificationService';\nimport paymentService from '@/services/paymentService';\nimport unifiedAuthService from '@/services/unifiedAuthService';\nexport default {\n  name: 'MyRequests',\n  data() {\n    return {\n      requests: [],\n      loading: true,\n      error: null,\n      // Filters\n      searchQuery: '',\n      statusFilter: '',\n      typeFilter: '',\n      sortBy: 'created_at_desc',\n      // Pagination\n      currentPage: 1,\n      itemsPerPage: 10,\n      // Search debounce\n      searchTimeout: null\n    };\n  },\n  computed: {\n    filteredRequests() {\n      // Ensure requests is always an array\n      if (!Array.isArray(this.requests)) {\n        return [];\n      }\n      let filtered = [...this.requests];\n\n      // Apply search filter\n      if (this.searchQuery) {\n        const query = this.searchQuery.toLowerCase();\n        filtered = filtered.filter(request => request.document_type.toLowerCase().includes(query) || request.purpose_category?.toLowerCase().includes(query) || request.id.toString().includes(query));\n      }\n\n      // Apply status filter\n      if (this.statusFilter) {\n        filtered = filtered.filter(request => request.status === this.statusFilter);\n      }\n\n      // Apply type filter\n      if (this.typeFilter) {\n        filtered = filtered.filter(request => request.document_type === this.typeFilter);\n      }\n\n      // Apply sorting\n      filtered.sort((a, b) => {\n        switch (this.sortBy) {\n          case 'created_at_desc':\n            return new Date(b.created_at) - new Date(a.created_at);\n          case 'created_at_asc':\n            return new Date(a.created_at) - new Date(b.created_at);\n          case 'status':\n            return a.status.localeCompare(b.status);\n          case 'type':\n            return a.document_type.localeCompare(b.document_type);\n          default:\n            return 0;\n        }\n      });\n      return filtered;\n    },\n    paginatedRequests() {\n      const start = (this.currentPage - 1) * this.itemsPerPage;\n      const end = start + this.itemsPerPage;\n      return this.filteredRequests.slice(start, end);\n    },\n    totalPages() {\n      return Math.ceil(this.filteredRequests.length / this.itemsPerPage);\n    },\n    visiblePages() {\n      const pages = [];\n      const start = Math.max(1, this.currentPage - 2);\n      const end = Math.min(this.totalPages, this.currentPage + 2);\n      for (let i = start; i <= end; i++) {\n        pages.push(i);\n      }\n      return pages;\n    },\n    totalRequests() {\n      return this.requests.length;\n    },\n    pendingCount() {\n      return this.requests.filter(r => ['pending', 'under_review'].includes(r.status)).length;\n    },\n    completedCount() {\n      return this.requests.filter(r => r.status === 'completed').length;\n    },\n    totalSpent() {\n      return this.requests.filter(r => r.status === 'completed').reduce((sum, r) => sum + parseFloat(r.total_fee || 0), 0);\n    }\n  },\n  async mounted() {\n    await this.loadRequests();\n    await this.initializeRealTimeFeatures();\n  },\n  beforeUnmount() {\n    this.cleanupRealTimeFeatures();\n  },\n  methods: {\n    async loadRequests() {\n      try {\n        this.loading = true;\n        this.error = null;\n        const response = await documentRequestService.getMyRequests();\n\n        // Handle the nested response structure: response.data.requests\n        if (response && response.data && response.data.requests && Array.isArray(response.data.requests)) {\n          this.requests = response.data.requests;\n        } else if (response && response.data && Array.isArray(response.data)) {\n          this.requests = response.data;\n        } else if (response && Array.isArray(response)) {\n          this.requests = response;\n        } else {\n          this.requests = [];\n          console.warn('API response does not contain array data:', response);\n        }\n      } catch (error) {\n        console.error('Error loading requests:', error);\n        this.error = error.response?.data?.message || 'Failed to load requests';\n        this.requests = []; // Ensure requests is always an array even on error\n      } finally {\n        this.loading = false;\n      }\n    },\n    handleSearch() {\n      // Debounce search\n      if (this.searchTimeout) {\n        clearTimeout(this.searchTimeout);\n      }\n      this.searchTimeout = setTimeout(() => {\n        this.currentPage = 1; // Reset to first page when searching\n      }, 300);\n    },\n    applyFilters() {\n      this.currentPage = 1; // Reset to first page when filtering\n    },\n    changePage(page) {\n      if (page >= 1 && page <= this.totalPages) {\n        this.currentPage = page;\n      }\n    },\n    handleItemsPerPageChange() {\n      this.currentPage = 1; // Reset to first page when changing items per page\n    },\n    getShowingStart() {\n      if (this.filteredRequests.length === 0) return 0;\n      return (this.currentPage - 1) * this.itemsPerPage + 1;\n    },\n    getShowingEnd() {\n      const end = this.currentPage * this.itemsPerPage;\n      return Math.min(end, this.filteredRequests.length);\n    },\n    getDocumentIcon(type) {\n      const icons = {\n        'Barangay Clearance': 'fas fa-certificate',\n        'Cedula': 'fas fa-id-card'\n      };\n      return icons[type] || 'fas fa-file-alt';\n    },\n    getStatusClass(status) {\n      const classes = {\n        'pending': 'status-pending',\n        'under_review': 'status-review',\n        'additional_info_required': 'status-info-required',\n        'approved': 'status-approved',\n        'payment_pending': 'status-payment-pending',\n        'payment_confirmed': 'status-payment-confirmed',\n        'payment_failed': 'status-payment-failed',\n        'processing': 'status-processing',\n        'ready_for_pickup': 'status-ready',\n        'pickup_scheduled': 'status-pickup-scheduled',\n        'completed': 'status-completed',\n        'rejected': 'status-rejected',\n        'cancelled': 'status-cancelled'\n      };\n      return classes[status] || 'status-unknown';\n    },\n    formatStatus(status) {\n      const statusMap = {\n        'pending': 'Pending',\n        'under_review': 'Under Review',\n        'additional_info_required': 'Additional Info Required',\n        'approved': 'Approved',\n        'payment_pending': 'Payment Pending',\n        'payment_confirmed': 'Payment Confirmed',\n        'payment_failed': 'Payment Failed',\n        'processing': 'Processing',\n        'ready_for_pickup': 'Ready for Pickup',\n        'pickup_scheduled': 'Pickup Scheduled',\n        'completed': 'Completed',\n        'rejected': 'Rejected',\n        'cancelled': 'Cancelled'\n      };\n      return statusMap[status] || status;\n    },\n    getProgressPercentage(status) {\n      const percentages = {\n        'pending': 10,\n        'under_review': 25,\n        'additional_info_required': 20,\n        'approved': 40,\n        'payment_pending': 45,\n        'payment_confirmed': 50,\n        'payment_failed': 45,\n        'processing': 75,\n        'ready_for_pickup': 90,\n        'pickup_scheduled': 95,\n        'completed': 100,\n        'rejected': 0,\n        'cancelled': 0\n      };\n      return percentages[status] || 0;\n    },\n    getProgressText(status) {\n      const texts = {\n        'pending': 'Waiting for review',\n        'under_review': 'Being reviewed',\n        'additional_info_required': 'Additional information required',\n        'approved': 'Approved, awaiting payment',\n        'payment_pending': 'Payment required',\n        'payment_confirmed': 'Payment confirmed, processing document',\n        'payment_failed': 'Payment failed, please retry',\n        'processing': 'Document being prepared',\n        'ready_for_pickup': 'Ready for pickup',\n        'pickup_scheduled': 'Pickup scheduled',\n        'completed': 'Request completed',\n        'rejected': 'Request rejected',\n        'cancelled': 'Request cancelled'\n      };\n      return texts[status] || 'Unknown status';\n    },\n    canCancelRequest(status) {\n      // Enhanced cancellation rules - allow cancellation until payment is confirmed\n      const cancellableStatuses = ['pending', 'under_review', 'additional_info_required', 'approved', 'payment_pending', 'payment_failed'];\n      return cancellableStatuses.includes(status);\n    },\n    needsPayment(request) {\n      // Check if request needs payment based on enhanced workflow\n      const paymentRequiredStatuses = ['approved', 'payment_pending', 'payment_failed'];\n      const unpaidStatuses = ['pending', 'failed', null, undefined, ''];\n      const needsPayment = paymentRequiredStatuses.includes(request.status) && unpaidStatuses.includes(request.payment_status) && request.payment_method_id &&\n      // Must have a payment method selected\n      request.is_online_payment; // Only show for online payment methods\n\n      return needsPayment;\n    },\n    formatDate(dateString) {\n      if (!dateString) return 'N/A';\n      return new Date(dateString).toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n      });\n    },\n    formatCurrency(amount) {\n      return parseFloat(amount || 0).toFixed(2);\n    },\n    viewRequestDetails(requestId) {\n      this.$router.push({\n        name: 'RequestDetails',\n        params: {\n          id: requestId\n        }\n      });\n    },\n    async cancelRequest(requestId) {\n      // Enhanced cancellation with reason input\n      const reason = prompt('Please provide a reason for cancelling this request (optional):', '');\n\n      // If user clicked cancel on the prompt, don't proceed\n      if (reason === null) return;\n\n      // Confirm cancellation\n      if (!confirm('Are you sure you want to cancel this request?')) return;\n      try {\n        // Find the request to get its current status for debugging\n        const currentRequest = this.requests.find(r => r.id === requestId);\n        console.log('🚫 Cancelling request:', {\n          requestId,\n          reason,\n          currentStatus: currentRequest?.status,\n          currentRequest: currentRequest\n        });\n        const cancellationReason = reason.trim() || 'Cancelled by user';\n        await documentRequestService.cancelRequest(requestId, cancellationReason);\n        this.$toast?.success('Request cancelled successfully. Administrators have been notified.');\n        await this.loadRequests(); // Reload requests\n\n        console.log('✅ Request cancelled successfully');\n      } catch (error) {\n        console.error('❌ Error cancelling request:', error);\n        console.error('❌ Error details:', {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          data: error.response?.data,\n          message: error.message\n        });\n\n        // Show more specific error messages\n        if (error.response?.data?.message) {\n          this.$toast?.error(error.response.data.message);\n        } else if (error.message?.includes('cannot be cancelled')) {\n          this.$toast?.error('This request cannot be cancelled at its current stage');\n        } else {\n          this.$toast?.error('Failed to cancel request. Please try again.');\n        }\n      }\n    },\n    async processPayment(requestId) {\n      try {\n        // Find the request to get payment details\n        const request = this.requests.find(r => r.id === requestId);\n        if (!request) {\n          this.showToast('Error', 'Request not found', 'error');\n          console.error('Request not found:', requestId);\n          return;\n        }\n        console.log('Processing payment for request:', request);\n\n        // Check if request has a payment method selected\n        if (!request.payment_method_id) {\n          this.showToast('Error', 'No payment method selected for this request. Please contact support.', 'error');\n          console.error('No payment method ID for request:', request);\n          return;\n        }\n\n        // Check if it's an online payment method\n        if (!request.is_online_payment) {\n          this.showToast('Info', 'This request uses in-person payment. Please pay at the barangay office.', 'info');\n          return;\n        }\n\n        // Show loading state\n        this.showToast('Info', 'Initiating payment...', 'info');\n\n        // Get current user data from unifiedAuthService\n        const currentUser = unifiedAuthService.getCurrentUser();\n        console.log('Current user:', currentUser);\n\n        // Prepare payment data\n        const paymentData = {\n          request_id: requestId,\n          payment_method_id: request.payment_method_id,\n          customer_email: currentUser?.email || request.email\n        };\n        console.log('Payment data:', paymentData);\n\n        // Initiate payment through PayMongo\n        const response = await paymentService.initiatePayment(paymentData);\n        console.log('Payment response:', response);\n        if (response && response.success && response.data && response.data.checkout_url) {\n          // Redirect to PayMongo checkout page\n          this.showToast('Success', 'Redirecting to payment page...', 'success');\n          paymentService.redirectToPayMongo(response.data.checkout_url);\n        } else {\n          console.error('Invalid payment response:', response);\n          throw new Error(response?.message || 'Failed to initiate payment - invalid response');\n        }\n      } catch (error) {\n        console.error('Payment initiation error:', error);\n        console.error('Error details:', {\n          message: error.message,\n          response: error.response?.data,\n          status: error.response?.status,\n          config: error.config\n        });\n        let errorMessage = 'Failed to initiate payment';\n        if (error.response?.data?.message) {\n          errorMessage = error.response.data.message;\n        } else if (error.response?.status === 401) {\n          errorMessage = 'Please log in to make a payment';\n        } else if (error.response?.status === 404) {\n          errorMessage = 'Payment service not found. Please contact support.';\n        } else if (error.response?.status >= 500) {\n          errorMessage = 'Payment service is temporarily unavailable. Please try again later.';\n        } else if (error.message) {\n          errorMessage = error.message;\n        }\n        this.showToast('Error', errorMessage, 'error');\n      }\n    },\n    createNewRequest() {\n      this.$router.push({\n        name: 'NewDocumentRequest'\n      });\n    },\n    goBack() {\n      this.$router.push({\n        name: 'ClientDashboard'\n      });\n    },\n    showToast(title, message, type = 'info') {\n      // Log to console for debugging\n      console.log(`[${type.toUpperCase()}] ${title}: ${message}`);\n\n      // Create a simple toast notification\n      const toast = document.createElement('div');\n      toast.className = `toast-notification toast-${type}`;\n      toast.innerHTML = `\n        <div class=\"toast-header\">\n          <strong>${title}</strong>\n          <button type=\"button\" class=\"toast-close\" onclick=\"this.parentElement.parentElement.remove()\">×</button>\n        </div>\n        <div class=\"toast-body\">${message}</div>\n      `;\n\n      // Add toast styles if not already added\n      if (!document.getElementById('toast-styles')) {\n        const styles = document.createElement('style');\n        styles.id = 'toast-styles';\n        styles.textContent = `\n          .toast-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            z-index: 9999;\n            animation: slideIn 0.3s ease;\n          }\n          .toast-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px 16px 8px;\n            border-bottom: 1px solid #e9ecef;\n          }\n          .toast-body {\n            padding: 8px 16px 12px;\n            color: #6c757d;\n          }\n          .toast-close {\n            background: none;\n            border: none;\n            font-size: 18px;\n            cursor: pointer;\n            color: #6c757d;\n          }\n          .toast-success { border-left: 4px solid #28a745; }\n          .toast-error { border-left: 4px solid #dc3545; }\n          .toast-info { border-left: 4px solid #17a2b8; }\n          .toast-warning { border-left: 4px solid #ffc107; }\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        `;\n        document.head.appendChild(styles);\n      }\n\n      // Add toast to page\n      document.body.appendChild(toast);\n\n      // Auto-remove after 5 seconds\n      setTimeout(() => {\n        if (toast.parentElement) {\n          toast.style.animation = 'slideIn 0.3s ease reverse';\n          setTimeout(() => toast.remove(), 300);\n        }\n      }, 5000);\n    },\n    // Real-time features\n    async initializeRealTimeFeatures() {\n      console.log('Initializing real-time features for MyRequests');\n      try {\n        // Initialize notification service for client\n        await notificationService.init('client');\n\n        // Listen for status change notifications\n        notificationService.on('notification', this.handleRealTimeNotification);\n        notificationService.on('status_change', this.handleStatusChange);\n        notificationService.on('request_update', this.handleRequestUpdate);\n      } catch (error) {\n        console.error('Failed to initialize real-time features:', error);\n      }\n    },\n    cleanupRealTimeFeatures() {\n      console.log('Cleaning up real-time features for MyRequests');\n\n      // Remove notification listeners\n      notificationService.off('notification', this.handleRealTimeNotification);\n      notificationService.off('status_change', this.handleStatusChange);\n      notificationService.off('request_update', this.handleRequestUpdate);\n\n      // Cleanup notification service\n      notificationService.cleanup();\n    },\n    handleRealTimeNotification(notification) {\n      console.log('Real-time notification received:', notification);\n\n      // Handle different notification types\n      switch (notification.type) {\n        case 'status_change':\n          this.handleStatusChange(notification);\n          break;\n        case 'request_update':\n          this.handleRequestUpdate(notification);\n          break;\n        default:\n          console.log('Unhandled notification type:', notification.type);\n      }\n    },\n    handleStatusChange(notification) {\n      console.log('Request status changed:', notification);\n\n      // Find and update the request in the list\n      const requestIndex = this.requests.findIndex(req => req.id === notification.data?.request_id);\n      if (requestIndex !== -1) {\n        // Update the request status\n        this.requests[requestIndex].status = notification.data.new_status;\n\n        // Show notification to user\n        this.showStatusChangeNotification(notification);\n\n        // Refresh the full request data to get updated details\n        this.loadRequests();\n      }\n    },\n    handleRequestUpdate(notification) {\n      console.log('Request updated:', notification);\n\n      // Refresh requests to show updates\n      this.loadRequests();\n    },\n    showStatusChangeNotification(notification) {\n      const {\n        data\n      } = notification;\n      const statusMessages = {\n        'approved': '✅ Your request has been approved!',\n        'rejected': '❌ Your request has been rejected.',\n        'processing': '⚙️ Your document is being processed.',\n        'ready_for_pickup': '📋 Your document is ready for pickup!',\n        'completed': '🎉 Your request has been completed!'\n      };\n      const message = statusMessages[data.new_status] || `Status updated to ${data.new_status}`;\n\n      // Show browser notification if permission granted\n      if ('Notification' in window && Notification.permission === 'granted') {\n        new Notification(`Request ${data.request_number}`, {\n          body: message,\n          icon: '/favicon.ico',\n          tag: `request-${data.request_id}`\n        });\n      }\n\n      // You can also show an in-app toast notification here\n      console.log(`🔔 ${message}`);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}