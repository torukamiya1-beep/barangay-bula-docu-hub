{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport axios from 'axios';\n\n/**\n * Context-Specific Notification Service\n * Each instance is tied to a specific user type (admin or client)\n */\nclass ContextualNotificationService {\n  constructor(userType) {\n    this.userType = userType;\n    this.eventSource = null;\n    this.listeners = new Map();\n    this.userContexts = new Map(); // Initialize userContexts Map\n    this.activeContext = null;\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.maxReconnectDelay = 30000;\n    this.baseURL = process.env.VUE_APP_API_URL || 'http://localhost:7000/api';\n    this.isConnecting = false;\n    this.pollingInterval = null;\n    this.reconnectTimer = null;\n    console.log(`🔔 Creating ${userType} notification service instance`);\n  }\n\n  /**\n   * Validate that this service can operate for its user type\n   */\n  validateContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      throw new Error('Authentication required');\n    }\n    try {\n      const user = JSON.parse(userData);\n      if (this.userType === 'admin') {\n        if (user.type !== 'admin') {\n          throw new Error('Admin authentication required');\n        }\n        return true;\n      }\n      if (this.userType === 'client') {\n        if (user.type !== 'client') {\n          throw new Error('Client authentication required');\n        }\n        return true;\n      }\n    } catch (error) {\n      throw new Error('Invalid user data format');\n    }\n    throw new Error(`Invalid user type: ${this.userType}`);\n  }\n\n  /**\n   * Get authentication token for this user type\n   */\n  getAuthToken() {\n    return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n  }\n\n  /**\n   * Initialize the notification service for this specific user type\n   */\n  async init() {\n    console.log(`🚀 Initializing ${this.userType} notification service`);\n    try {\n      // Validate context before proceeding\n      this.validateContext();\n\n      // Initialize user context if not exists\n      if (!this.userContexts.has(this.userType)) {\n        this.userContexts.set(this.userType, {\n          isConnected: false,\n          listeners: new Map(),\n          eventSource: null\n        });\n      }\n\n      // Set active context\n      this.activeContext = this.userType;\n\n      // Connect to notification stream\n      await this.connect();\n      console.log(`✅ ${this.userType} notification service initialized successfully`);\n      return Promise.resolve();\n    } catch (error) {\n      console.error(`❌ Failed to initialize ${this.userType} notification service:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect current user context based on authentication state\n   */\n  detectUserContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      console.log('🔍 No authentication found');\n      return null;\n    }\n    try {\n      const user = JSON.parse(userData);\n      if (user && user.type) {\n        console.log('🔍 Detected user context:', user.type);\n        return user.type;\n      }\n    } catch (error) {\n      console.warn('⚠️ Invalid user data in localStorage:', error);\n    }\n    console.log('🔍 No valid user context detected');\n    return null;\n  }\n\n  /**\n   * Validate user context against authentication state\n   */\n  validateUserContext(userType) {\n    if (!userType || !['admin', 'client'].includes(userType)) {\n      return false;\n    }\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n    if (!authToken || !userData) {\n      return false;\n    }\n    try {\n      const user = JSON.parse(userData);\n      return user && user.type === userType;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Switch active user context\n   */\n  switchContext(userType) {\n    if (!this.validateUserContext(userType)) {\n      console.warn('⚠️ Cannot switch to invalid user context:', userType);\n      return false;\n    }\n    const previousContext = this.activeContext;\n    this.activeContext = userType;\n    this.currentUserType = userType;\n    console.log('🔄 Context switched:', {\n      from: previousContext,\n      to: userType\n    });\n\n    // Emit context change event\n    this.emit('context_changed', {\n      previousContext,\n      currentContext: userType\n    });\n    return true;\n  }\n\n  /**\n   * Get current active context\n   */\n  getCurrentContext() {\n    return this.activeContext;\n  }\n\n  /**\n   * Check if a specific user context is connected\n   */\n  isContextConnected(userType) {\n    const context = this.userContexts.get(userType);\n    return context ? context.isConnected : false;\n  }\n\n  /**\n   * Get all available contexts\n   */\n  getAvailableContexts() {\n    const contexts = [];\n    if (this.validateUserContext('admin')) {\n      contexts.push({\n        type: 'admin',\n        connected: this.isContextConnected('admin'),\n        active: this.activeContext === 'admin'\n      });\n    }\n    if (this.validateUserContext('client')) {\n      contexts.push({\n        type: 'client',\n        connected: this.isContextConnected('client'),\n        active: this.activeContext === 'client'\n      });\n    }\n    return contexts;\n  }\n\n  /**\n   * Handle authentication state changes and auto-switch context\n   */\n  handleAuthStateChange() {\n    const detectedContext = this.detectUserContext();\n    if (!detectedContext) {\n      console.log('🔒 No valid authentication detected, cleaning up all contexts');\n      this.cleanup('admin');\n      this.cleanup('client');\n      this.activeContext = null;\n      this.currentUserType = null;\n      return;\n    }\n\n    // If detected context is different from active context, switch\n    if (detectedContext !== this.activeContext) {\n      console.log('🔄 Authentication state changed, switching context:', {\n        from: this.activeContext,\n        to: detectedContext\n      });\n      this.switchContext(detectedContext);\n    }\n  }\n\n  /**\n   * Start monitoring authentication state changes\n   */\n  startAuthStateMonitoring() {\n    // Monitor localStorage changes for token updates\n    window.addEventListener('storage', event => {\n      if (event.key === 'adminToken' || event.key === 'clientToken' || event.key === 'adminData' || event.key === 'clientData') {\n        console.log('🔍 Authentication storage changed:', event.key);\n        setTimeout(() => this.handleAuthStateChange(), 100);\n      }\n    });\n\n    // Also monitor for direct localStorage changes in the same tab\n    const originalSetItem = localStorage.setItem;\n    localStorage.setItem = function (key, value) {\n      originalSetItem.call(this, key, value);\n      if (key === 'adminToken' || key === 'clientToken' || key === 'adminData' || key === 'clientData') {\n        setTimeout(() => {\n          if (window.__notificationServiceInstance) {\n            window.__notificationServiceInstance.handleAuthStateChange();\n          }\n        }, 100);\n      }\n    };\n  }\n\n  /**\n   * Cleanup with context awareness\n   */\n  cleanup(userType = null) {\n    if (userType) {\n      // Clean up specific context\n      const context = this.userContexts.get(userType);\n      if (context) {\n        console.log('🧹 Cleaning up context:', userType);\n\n        // Clean up event source\n        if (context.eventSource) {\n          context.eventSource.close();\n          context.eventSource = null;\n        }\n\n        // Clear context data\n        context.isConnected = false;\n        context.listeners.clear();\n\n        // Remove global reference\n        if (window[`__sseConnection_${userType}`]) {\n          delete window[`__sseConnection_${userType}`];\n        }\n      }\n    } else {\n      console.log('🧹 General notification service cleanup');\n      // Don't disconnect - let connections persist for context switching\n    }\n  }\n\n  /**\n   * Connect to SSE stream for this specific user type\n   */\n  connect() {\n    // Prevent multiple connections\n    if (this.isConnected || this.isConnecting || this.eventSource) {\n      console.log(`🔗 ${this.userType} notification service already connected`);\n      return Promise.resolve();\n    }\n    this.isConnecting = true;\n    console.log(`🔗 Establishing SSE connection for ${this.userType}`);\n    return new Promise((resolve, reject) => {\n      try {\n        // Validate context and get token\n        this.validateContext();\n        const token = this.getAuthToken();\n        if (!token) {\n          this.isConnecting = false;\n          reject(new Error(`No authentication token for ${this.userType}`));\n          return;\n        }\n\n        // Create EventSource with proper URL\n        const url = `${this.baseURL}/notifications/stream?token=${encodeURIComponent(token)}`;\n        console.log(`🔗 SSE URL for ${this.userType}:`, url.replace(/token=[^&]+/, 'token=***'));\n        this.eventSource = new EventSource(url);\n\n        // Store reference with user-specific key to prevent conflicts\n        window[`__sseConnection_${this.userType}`] = this.eventSource;\n\n        // Event handlers for this specific user type\n        this.eventSource.onopen = () => {\n          console.log(`✅ SSE Connection established for ${this.userType}`);\n          this.isConnected = true;\n          this.isConnecting = false;\n          this.reconnectAttempts = 0;\n          this.emit('connected');\n          resolve();\n        };\n        this.eventSource.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            console.log(`📨 SSE Message for ${this.userType}:`, data);\n\n            // CRITICAL: Only process notifications intended for this user type\n            if (data.recipient_type && data.recipient_type !== this.userType) {\n              console.log(`🚫 ${this.userType} service ignoring ${data.recipient_type} notification:`, data.id);\n              return;\n            }\n            this.handleNotification(data);\n          } catch (error) {\n            console.error(`❌ ${this.userType} SSE message parse error:`, error);\n          }\n        };\n\n        // Handle specific event types\n        this.eventSource.addEventListener('connected', () => {\n          console.log(`🎯 Connected event received for ${this.userType}`);\n        });\n        this.eventSource.addEventListener('heartbeat', () => {\n          console.log(`💓 Heartbeat received for ${this.userType}`);\n        });\n        this.eventSource.onerror = event => {\n          console.error(`❌ SSE Error for ${this.userType}:`, event);\n          this.isConnected = false;\n          this.isConnecting = false;\n\n          // Handle different error states\n          if (this.eventSource.readyState === EventSource.CLOSED) {\n            console.log(`🔌 SSE Connection closed by server for ${this.userType}`);\n            this.emit('disconnected');\n          } else if (this.eventSource.readyState === EventSource.CONNECTING) {\n            console.log(`🔄 SSE Reconnecting for ${this.userType}`);\n          }\n\n          // Auto-reconnect with exponential backoff\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          } else {\n            console.error(`🚫 Max reconnection attempts reached for ${this.userType}`);\n            this.emit('max_reconnect_attempts');\n            reject(new Error(`Max reconnection attempts reached for ${this.userType}`));\n          }\n        };\n      } catch (error) {\n        console.error('Failed to create SSE connection:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Poll for new notifications and updates\n   */\n  async pollNotifications(userType = 'admin') {\n    try {\n      const token = userType === 'admin' ? localStorage.getItem('adminToken') : localStorage.getItem('clientToken');\n      if (!token) return;\n\n      // Get unread count\n      const response = await fetch(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const count = data.data?.count || data.count || 0;\n\n        // Only emit if count changed or every 10th poll\n        if (!this.lastCount || this.lastCount !== count || this.pollCount % 10 === 0) {\n          this.emit('notification', {\n            type: 'unread_count_update',\n            count: count,\n            timestamp: new Date().toISOString()\n          });\n          this.lastCount = count;\n        }\n        this.pollCount = (this.pollCount || 0) + 1;\n      }\n    } catch (error) {\n      console.error('Failed to poll notifications:', error);\n    }\n  }\n\n  /**\n   * Disconnect from SSE (Google/Mozilla standard)\n   */\n  disconnect() {\n    console.log('🔌 Disconnecting SSE connection');\n    this.isConnected = false;\n    this.isConnecting = false;\n\n    // Clear any reconnection timers\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    // Close EventSource properly\n    if (this.eventSource) {\n      console.log('🔌 Closing EventSource');\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n\n    // Clear global references\n    if (window.__sseConnection) {\n      delete window.__sseConnection;\n    }\n    if (window.__notificationEventSource) {\n      delete window.__notificationEventSource;\n    }\n\n    // Clean up any polling fallback\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = null;\n    }\n    console.log('✅ SSE Disconnected cleanly');\n    this.emit('disconnected');\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff and user context awareness\n   */\n  scheduleReconnect(userType = null) {\n    const contextType = userType || this.currentUserType || this.detectUserContext();\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('🚫 Max reconnection attempts reached for:', contextType);\n      this.emit('max_reconnect_attempts', {\n        userType: contextType\n      });\n      return;\n    }\n    this.reconnectAttempts++;\n\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s\n    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);\n    console.log(`🔄 Scheduling reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType} in ${delay}ms`);\n    this.reconnectTimer = setTimeout(() => {\n      const context = this.userContexts.get(contextType);\n      if (context && !context.isConnected && !this.isConnecting) {\n        console.log(`🔄 Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType}`);\n        this.connect(contextType).catch(error => {\n          console.error('Reconnection failed for', contextType, ':', error);\n        });\n      }\n    }, delay);\n  }\n\n  /**\n   * Handle incoming notification for this specific user type\n   */\n  handleNotification(notification) {\n    console.log(`📢 ${this.userType} service processing notification:`, notification);\n\n    // Double-check recipient type (should already be filtered in onmessage)\n    if (notification.recipient_type && notification.recipient_type !== this.userType) {\n      console.warn(`🚫 ${this.userType} service received wrong notification type:`, notification.recipient_type);\n      return;\n    }\n\n    // Emit to specific type listeners\n    this.emit(notification.type, notification);\n\n    // Emit to general notification listeners\n    this.emit('notification', notification);\n\n    // Show browser notification if permission granted\n    this.showBrowserNotification(notification);\n  }\n\n  /**\n   * Show browser notification\n   */\n  showBrowserNotification(notification) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const options = {\n        body: notification.message,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: `notification-${notification.id}`,\n        requireInteraction: notification.priority === 'high' || notification.priority === 'urgent'\n      };\n      const browserNotification = new Notification(notification.title, options);\n      browserNotification.onclick = () => {\n        window.focus();\n        this.emit('notification_click', notification);\n        browserNotification.close();\n      };\n\n      // Auto close after 5 seconds for normal priority\n      if (notification.priority !== 'high' && notification.priority !== 'urgent') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n    }\n  }\n\n  /**\n   * Request browser notification permission\n   */\n  async requestNotificationPermission() {\n    if ('Notification' in window) {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  /**\n   * Subscribe to notification events (context-aware)\n   */\n  on(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Use global listeners for backward compatibility\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n\n    // Also store in context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (!context.listeners.has(event)) {\n        context.listeners.set(event, new Set());\n      }\n      context.listeners.get(event).add(callback);\n      console.log('📝 Event listener registered for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Unsubscribe from notification events (context-aware)\n   */\n  off(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Remove from global listeners\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n\n    // Remove from context-specific listeners\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (context.listeners.has(event)) {\n        context.listeners.get(event).delete(callback);\n      }\n      console.log('🗑️ Event listener removed for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Emit event to listeners (context-aware)\n   */\n  emit(event, data = null, context = null) {\n    const contextType = context?.userType || this.activeContext;\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Always emit to global listeners for backward compatibility\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data, context);\n        } catch (error) {\n          console.error(`Error in global notification listener for ${event}:`, error);\n        }\n      });\n    }\n\n    // Also emit to context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const userContext = this.userContexts.get(contextType);\n      if (userContext.listeners.has(event)) {\n        userContext.listeners.get(event).forEach(callback => {\n          try {\n            callback(data, context);\n          } catch (error) {\n            console.error(`Error in ${contextType} notification listener for ${event}:`, error);\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Get notifications for this specific user type\n   */\n  async getNotifications(page = 1, limit = 20, unreadOnly = false) {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      console.log(`🔍 Getting notifications for ${this.userType}:`, {\n        page,\n        limit,\n        unread_only: unreadOnly\n      });\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      const response = await axios.get(`${this.baseURL}/notifications`, {\n        params: {\n          page,\n          limit,\n          unread_only: unreadOnly\n        },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      console.log(`✅ ${this.userType} notifications retrieved:`, response.data);\n      return response.data;\n    } catch (error) {\n      console.error(`❌ Failed to get ${this.userType} notifications:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get unread notification count for this specific user type\n   */\n  async getUnreadCount() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      console.log(`🔍 Getting unread count for ${this.userType}`);\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      const response = await axios.get(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      console.log(`✅ ${this.userType} unread count response:`, response.data);\n\n      // Handle different response formats\n      let count = 0;\n      if (response.data && response.data.data && typeof response.data.data.count !== 'undefined') {\n        count = response.data.data.count;\n        console.log('📊 NotificationService: Found count in data.data.count:', count);\n      } else if (response.data && typeof response.data.count !== 'undefined') {\n        count = response.data.count;\n        console.log('📊 NotificationService: Found count in data.count:', count);\n      } else {\n        count = 0;\n        console.log('⚠️ NotificationService: No count found, defaulting to 0');\n      }\n      return count;\n    } catch (error) {\n      console.error('❌ NotificationService: Failed to get unread count:', error);\n      if (error.response) {\n        console.error('📊 NotificationService: Error response status:', error.response.status);\n        console.error('📊 NotificationService: Error response data:', error.response.data);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Mark notification as read for this specific user type\n   */\n  async markAsRead(notificationId) {\n    try {\n      if (!notificationId || notificationId === 'undefined') {\n        throw new Error('Invalid notification ID provided');\n      }\n      this.validateContext();\n      const token = this.getAuthToken();\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      console.log(`Marking notification as read for ${this.userType}:`, notificationId);\n      const response = await axios.put(`${this.baseURL}/notifications/${notificationId}/read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark ${this.userType} notification as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark all notifications as read for this specific user type\n   */\n  async markAllAsRead() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n      console.log(`Marking all notifications as read for ${this.userType}`);\n      const response = await axios.put(`${this.baseURL}/notifications/mark-all-read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark all ${this.userType} notifications as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send test notification (admin only)\n   */\n  async sendTestNotification(data) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.post(`${this.baseURL}/notifications/test`, data, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to send test notification:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification statistics (admin only)\n   */\n  async getStatistics() {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.get(`${this.baseURL}/notifications/statistics`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get notification statistics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test SSE connection (for debugging)\n   */\n  async testConnection() {\n    console.log('🧪 Testing SSE connection...');\n    try {\n      // Clear any existing connection\n      if (this.eventSource) {\n        console.log('🧪 Clearing existing connection');\n        this.eventSource.close();\n        this.eventSource = null;\n        this.isConnected = false;\n        this.isConnecting = false;\n      }\n\n      // Reset state\n      this.connectionRefs = 1;\n\n      // Test connection\n      await this.connect('admin');\n      console.log('🧪 Test connection established');\n\n      // Keep connection alive for 10 seconds\n      setTimeout(() => {\n        console.log('🧪 Test completed, keeping connection');\n      }, 10000);\n    } catch (error) {\n      console.error('🧪 Test connection failed:', error);\n    }\n  }\n\n  /**\n   * Clean up old notifications (admin only)\n   */\n  async cleanupOldNotifications(days = 90) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.delete(`${this.baseURL}/notifications/cleanup`, {\n        params: {\n          days\n        },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to cleanup old notifications:', error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Factory function to create context-specific notification services\n */\nfunction createNotificationService(userType) {\n  if (!userType || !['admin', 'client'].includes(userType)) {\n    throw new Error(`Invalid user type: ${userType}. Must be 'admin' or 'client'`);\n  }\n  return new ContextualNotificationService(userType);\n}\n\n/**\n * Global service instances (created on demand)\n */\nlet adminNotificationService = null;\nlet clientNotificationService = null;\n\n/**\n * Get or create admin notification service\n */\nfunction getAdminNotificationService() {\n  if (!adminNotificationService) {\n    adminNotificationService = createNotificationService('admin');\n    window.__adminNotificationService = adminNotificationService;\n  }\n  return adminNotificationService;\n}\n\n/**\n * Get or create client notification service\n */\nfunction getClientNotificationService() {\n  if (!clientNotificationService) {\n    clientNotificationService = createNotificationService('client');\n    window.__clientNotificationService = clientNotificationService;\n  }\n  return clientNotificationService;\n}\n\n/**\n * Legacy compatibility - returns service based on current auth state\n */\nfunction getLegacyNotificationService() {\n  const adminToken = localStorage.getItem('adminToken');\n  const clientToken = localStorage.getItem('clientToken');\n\n  // Prioritize admin if both are present\n  if (adminToken) {\n    return getAdminNotificationService();\n  }\n  if (clientToken) {\n    return getClientNotificationService();\n  }\n\n  // Default to admin for backward compatibility\n  return getAdminNotificationService();\n}\n\n// Export the factory and getters\nexport { createNotificationService, getAdminNotificationService, getClientNotificationService, ContextualNotificationService };\n\n// Default export for backward compatibility\nexport default getLegacyNotificationService();\n\n// Make services available globally for debugging\nwindow.__createNotificationService = createNotificationService;\nwindow.__getAdminNotificationService = getAdminNotificationService;\nwindow.__getClientNotificationService = getClientNotificationService;","map":{"version":3,"names":["axios","ContextualNotificationService","constructor","userType","eventSource","listeners","Map","userContexts","activeContext","isConnected","reconnectAttempts","maxReconnectAttempts","reconnectDelay","maxReconnectDelay","baseURL","process","env","VUE_APP_API_URL","isConnecting","pollingInterval","reconnectTimer","console","log","validateContext","authToken","localStorage","getItem","sessionStorage","userData","Error","user","JSON","parse","type","error","getAuthToken","init","has","set","connect","Promise","resolve","detectUserContext","warn","validateUserContext","includes","switchContext","previousContext","currentUserType","from","to","emit","currentContext","getCurrentContext","isContextConnected","context","get","getAvailableContexts","contexts","push","connected","active","handleAuthStateChange","detectedContext","cleanup","startAuthStateMonitoring","window","addEventListener","event","key","setTimeout","originalSetItem","setItem","value","call","__notificationServiceInstance","close","clear","reject","token","url","encodeURIComponent","replace","EventSource","onopen","onmessage","data","recipient_type","id","handleNotification","onerror","readyState","CLOSED","CONNECTING","scheduleReconnect","pollNotifications","response","fetch","headers","ok","json","count","lastCount","pollCount","timestamp","Date","toISOString","disconnect","clearTimeout","__sseConnection","__notificationEventSource","clearInterval","contextType","delay","Math","min","pow","catch","notification","showBrowserNotification","Notification","permission","options","body","message","icon","badge","tag","requireInteraction","priority","browserNotification","title","onclick","focus","requestNotificationPermission","requestPermission","on","callback","Set","add","off","delete","forEach","userContext","getNotifications","page","limit","unreadOnly","unread_only","params","getUnreadCount","status","markAsRead","notificationId","put","markAllAsRead","sendTestNotification","post","getStatistics","testConnection","connectionRefs","cleanupOldNotifications","days","createNotificationService","adminNotificationService","clientNotificationService","getAdminNotificationService","__adminNotificationService","getClientNotificationService","__clientNotificationService","getLegacyNotificationService","adminToken","clientToken","__createNotificationService","__getAdminNotificationService","__getClientNotificationService"],"sources":["D:/brgy_docu_hub/BOSFDR/src/services/notificationService.js"],"sourcesContent":["import axios from 'axios';\n\n/**\n * Context-Specific Notification Service\n * Each instance is tied to a specific user type (admin or client)\n */\nclass ContextualNotificationService {\n  constructor(userType) {\n    this.userType = userType;\n    this.eventSource = null;\n    this.listeners = new Map();\n    this.userContexts = new Map(); // Initialize userContexts Map\n    this.activeContext = null;\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.maxReconnectDelay = 30000;\n    this.baseURL = process.env.VUE_APP_API_URL || 'http://localhost:7000/api';\n    this.isConnecting = false;\n    this.pollingInterval = null;\n    this.reconnectTimer = null;\n\n    console.log(`🔔 Creating ${userType} notification service instance`);\n  }\n\n  /**\n   * Validate that this service can operate for its user type\n   */\n  validateContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n\n    if (!authToken || !userData) {\n      throw new Error('Authentication required');\n    }\n\n    try {\n      const user = JSON.parse(userData);\n\n      if (this.userType === 'admin') {\n        if (user.type !== 'admin') {\n          throw new Error('Admin authentication required');\n        }\n        return true;\n      }\n\n      if (this.userType === 'client') {\n        if (user.type !== 'client') {\n          throw new Error('Client authentication required');\n        }\n        return true;\n      }\n    } catch (error) {\n      throw new Error('Invalid user data format');\n    }\n\n    throw new Error(`Invalid user type: ${this.userType}`);\n  }\n\n  /**\n   * Get authentication token for this user type\n   */\n  getAuthToken() {\n    return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n  }\n\n  /**\n   * Initialize the notification service for this specific user type\n   */\n  async init() {\n    console.log(`🚀 Initializing ${this.userType} notification service`);\n\n    try {\n      // Validate context before proceeding\n      this.validateContext();\n\n      // Initialize user context if not exists\n      if (!this.userContexts.has(this.userType)) {\n        this.userContexts.set(this.userType, {\n          isConnected: false,\n          listeners: new Map(),\n          eventSource: null\n        });\n      }\n\n      // Set active context\n      this.activeContext = this.userType;\n\n      // Connect to notification stream\n      await this.connect();\n\n      console.log(`✅ ${this.userType} notification service initialized successfully`);\n      return Promise.resolve();\n    } catch (error) {\n      console.error(`❌ Failed to initialize ${this.userType} notification service:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect current user context based on authentication state\n   */\n  detectUserContext() {\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n\n    if (!authToken || !userData) {\n      console.log('🔍 No authentication found');\n      return null;\n    }\n\n    try {\n      const user = JSON.parse(userData);\n      if (user && user.type) {\n        console.log('🔍 Detected user context:', user.type);\n        return user.type;\n      }\n    } catch (error) {\n      console.warn('⚠️ Invalid user data in localStorage:', error);\n    }\n\n    console.log('🔍 No valid user context detected');\n    return null;\n  }\n\n  /**\n   * Validate user context against authentication state\n   */\n  validateUserContext(userType) {\n    if (!userType || !['admin', 'client'].includes(userType)) {\n      return false;\n    }\n\n    const authToken = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');\n    const userData = localStorage.getItem('auth_user') || sessionStorage.getItem('auth_user');\n\n    if (!authToken || !userData) {\n      return false;\n    }\n\n    try {\n      const user = JSON.parse(userData);\n      return user && user.type === userType;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Switch active user context\n   */\n  switchContext(userType) {\n    if (!this.validateUserContext(userType)) {\n      console.warn('⚠️ Cannot switch to invalid user context:', userType);\n      return false;\n    }\n\n    const previousContext = this.activeContext;\n    this.activeContext = userType;\n    this.currentUserType = userType;\n\n    console.log('🔄 Context switched:', {\n      from: previousContext,\n      to: userType\n    });\n\n    // Emit context change event\n    this.emit('context_changed', {\n      previousContext,\n      currentContext: userType\n    });\n\n    return true;\n  }\n\n  /**\n   * Get current active context\n   */\n  getCurrentContext() {\n    return this.activeContext;\n  }\n\n  /**\n   * Check if a specific user context is connected\n   */\n  isContextConnected(userType) {\n    const context = this.userContexts.get(userType);\n    return context ? context.isConnected : false;\n  }\n\n  /**\n   * Get all available contexts\n   */\n  getAvailableContexts() {\n    const contexts = [];\n\n    if (this.validateUserContext('admin')) {\n      contexts.push({\n        type: 'admin',\n        connected: this.isContextConnected('admin'),\n        active: this.activeContext === 'admin'\n      });\n    }\n\n    if (this.validateUserContext('client')) {\n      contexts.push({\n        type: 'client',\n        connected: this.isContextConnected('client'),\n        active: this.activeContext === 'client'\n      });\n    }\n\n    return contexts;\n  }\n\n  /**\n   * Handle authentication state changes and auto-switch context\n   */\n  handleAuthStateChange() {\n    const detectedContext = this.detectUserContext();\n\n    if (!detectedContext) {\n      console.log('🔒 No valid authentication detected, cleaning up all contexts');\n      this.cleanup('admin');\n      this.cleanup('client');\n      this.activeContext = null;\n      this.currentUserType = null;\n      return;\n    }\n\n    // If detected context is different from active context, switch\n    if (detectedContext !== this.activeContext) {\n      console.log('🔄 Authentication state changed, switching context:', {\n        from: this.activeContext,\n        to: detectedContext\n      });\n\n      this.switchContext(detectedContext);\n    }\n  }\n\n  /**\n   * Start monitoring authentication state changes\n   */\n  startAuthStateMonitoring() {\n    // Monitor localStorage changes for token updates\n    window.addEventListener('storage', (event) => {\n      if (event.key === 'adminToken' || event.key === 'clientToken' ||\n          event.key === 'adminData' || event.key === 'clientData') {\n        console.log('🔍 Authentication storage changed:', event.key);\n        setTimeout(() => this.handleAuthStateChange(), 100);\n      }\n    });\n\n    // Also monitor for direct localStorage changes in the same tab\n    const originalSetItem = localStorage.setItem;\n    localStorage.setItem = function(key, value) {\n      originalSetItem.call(this, key, value);\n      if (key === 'adminToken' || key === 'clientToken' ||\n          key === 'adminData' || key === 'clientData') {\n        setTimeout(() => {\n          if (window.__notificationServiceInstance) {\n            window.__notificationServiceInstance.handleAuthStateChange();\n          }\n        }, 100);\n      }\n    };\n  }\n\n  /**\n   * Cleanup with context awareness\n   */\n  cleanup(userType = null) {\n    if (userType) {\n      // Clean up specific context\n      const context = this.userContexts.get(userType);\n      if (context) {\n        console.log('🧹 Cleaning up context:', userType);\n\n        // Clean up event source\n        if (context.eventSource) {\n          context.eventSource.close();\n          context.eventSource = null;\n        }\n\n        // Clear context data\n        context.isConnected = false;\n        context.listeners.clear();\n\n        // Remove global reference\n        if (window[`__sseConnection_${userType}`]) {\n          delete window[`__sseConnection_${userType}`];\n        }\n      }\n    } else {\n      console.log('🧹 General notification service cleanup');\n      // Don't disconnect - let connections persist for context switching\n    }\n  }\n\n  /**\n   * Connect to SSE stream for this specific user type\n   */\n  connect() {\n    // Prevent multiple connections\n    if (this.isConnected || this.isConnecting || this.eventSource) {\n      console.log(`🔗 ${this.userType} notification service already connected`);\n      return Promise.resolve();\n    }\n\n    this.isConnecting = true;\n    console.log(`🔗 Establishing SSE connection for ${this.userType}`);\n\n    return new Promise((resolve, reject) => {\n      try {\n        // Validate context and get token\n        this.validateContext();\n        const token = this.getAuthToken();\n\n        if (!token) {\n          this.isConnecting = false;\n          reject(new Error(`No authentication token for ${this.userType}`));\n          return;\n        }\n\n        // Create EventSource with proper URL\n        const url = `${this.baseURL}/notifications/stream?token=${encodeURIComponent(token)}`;\n        console.log(`🔗 SSE URL for ${this.userType}:`, url.replace(/token=[^&]+/, 'token=***'));\n\n        this.eventSource = new EventSource(url);\n\n        // Store reference with user-specific key to prevent conflicts\n        window[`__sseConnection_${this.userType}`] = this.eventSource;\n\n        // Event handlers for this specific user type\n        this.eventSource.onopen = () => {\n          console.log(`✅ SSE Connection established for ${this.userType}`);\n          this.isConnected = true;\n          this.isConnecting = false;\n          this.reconnectAttempts = 0;\n          this.emit('connected');\n          resolve();\n        };\n\n        this.eventSource.onmessage = (event) => {\n          try {\n            const data = JSON.parse(event.data);\n            console.log(`📨 SSE Message for ${this.userType}:`, data);\n\n            // CRITICAL: Only process notifications intended for this user type\n            if (data.recipient_type && data.recipient_type !== this.userType) {\n              console.log(`🚫 ${this.userType} service ignoring ${data.recipient_type} notification:`, data.id);\n              return;\n            }\n\n            this.handleNotification(data);\n          } catch (error) {\n            console.error(`❌ ${this.userType} SSE message parse error:`, error);\n          }\n        };\n\n        // Handle specific event types\n        this.eventSource.addEventListener('connected', () => {\n          console.log(`🎯 Connected event received for ${this.userType}`);\n        });\n\n        this.eventSource.addEventListener('heartbeat', () => {\n          console.log(`💓 Heartbeat received for ${this.userType}`);\n        });\n\n        this.eventSource.onerror = (event) => {\n          console.error(`❌ SSE Error for ${this.userType}:`, event);\n          this.isConnected = false;\n          this.isConnecting = false;\n\n          // Handle different error states\n          if (this.eventSource.readyState === EventSource.CLOSED) {\n            console.log(`🔌 SSE Connection closed by server for ${this.userType}`);\n            this.emit('disconnected');\n          } else if (this.eventSource.readyState === EventSource.CONNECTING) {\n            console.log(`🔄 SSE Reconnecting for ${this.userType}`);\n          }\n\n          // Auto-reconnect with exponential backoff\n          if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          } else {\n            console.error(`🚫 Max reconnection attempts reached for ${this.userType}`);\n            this.emit('max_reconnect_attempts');\n            reject(new Error(`Max reconnection attempts reached for ${this.userType}`));\n          }\n        };\n\n      } catch (error) {\n        console.error('Failed to create SSE connection:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Poll for new notifications and updates\n   */\n  async pollNotifications(userType = 'admin') {\n    try {\n      const token = userType === 'admin'\n        ? localStorage.getItem('adminToken')\n        : localStorage.getItem('clientToken');\n\n      if (!token) return;\n\n      // Get unread count\n      const response = await fetch(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        const count = data.data?.count || data.count || 0;\n\n        // Only emit if count changed or every 10th poll\n        if (!this.lastCount || this.lastCount !== count || this.pollCount % 10 === 0) {\n          this.emit('notification', {\n            type: 'unread_count_update',\n            count: count,\n            timestamp: new Date().toISOString()\n          });\n          this.lastCount = count;\n        }\n\n        this.pollCount = (this.pollCount || 0) + 1;\n      }\n    } catch (error) {\n      console.error('Failed to poll notifications:', error);\n    }\n  }\n\n  /**\n   * Disconnect from SSE (Google/Mozilla standard)\n   */\n  disconnect() {\n    console.log('🔌 Disconnecting SSE connection');\n\n    this.isConnected = false;\n    this.isConnecting = false;\n\n    // Clear any reconnection timers\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    // Close EventSource properly\n    if (this.eventSource) {\n      console.log('🔌 Closing EventSource');\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n\n    // Clear global references\n    if (window.__sseConnection) {\n      delete window.__sseConnection;\n    }\n    if (window.__notificationEventSource) {\n      delete window.__notificationEventSource;\n    }\n\n    // Clean up any polling fallback\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = null;\n    }\n\n    console.log('✅ SSE Disconnected cleanly');\n    this.emit('disconnected');\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff and user context awareness\n   */\n  scheduleReconnect(userType = null) {\n    const contextType = userType || this.currentUserType || this.detectUserContext();\n\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('🚫 Max reconnection attempts reached for:', contextType);\n      this.emit('max_reconnect_attempts', { userType: contextType });\n      return;\n    }\n\n    this.reconnectAttempts++;\n\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s\n    const delay = Math.min(\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n      this.maxReconnectDelay\n    );\n\n    console.log(`🔄 Scheduling reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType} in ${delay}ms`);\n\n    this.reconnectTimer = setTimeout(() => {\n      const context = this.userContexts.get(contextType);\n      if (context && !context.isConnected && !this.isConnecting) {\n        console.log(`🔄 Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts} for ${contextType}`);\n        this.connect(contextType).catch(error => {\n          console.error('Reconnection failed for', contextType, ':', error);\n        });\n      }\n    }, delay);\n  }\n\n  /**\n   * Handle incoming notification for this specific user type\n   */\n  handleNotification(notification) {\n    console.log(`📢 ${this.userType} service processing notification:`, notification);\n\n    // Double-check recipient type (should already be filtered in onmessage)\n    if (notification.recipient_type && notification.recipient_type !== this.userType) {\n      console.warn(`🚫 ${this.userType} service received wrong notification type:`, notification.recipient_type);\n      return;\n    }\n\n    // Emit to specific type listeners\n    this.emit(notification.type, notification);\n\n    // Emit to general notification listeners\n    this.emit('notification', notification);\n\n    // Show browser notification if permission granted\n    this.showBrowserNotification(notification);\n  }\n\n  /**\n   * Show browser notification\n   */\n  showBrowserNotification(notification) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const options = {\n        body: notification.message,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: `notification-${notification.id}`,\n        requireInteraction: notification.priority === 'high' || notification.priority === 'urgent'\n      };\n\n      const browserNotification = new Notification(notification.title, options);\n      \n      browserNotification.onclick = () => {\n        window.focus();\n        this.emit('notification_click', notification);\n        browserNotification.close();\n      };\n\n      // Auto close after 5 seconds for normal priority\n      if (notification.priority !== 'high' && notification.priority !== 'urgent') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n    }\n  }\n\n  /**\n   * Request browser notification permission\n   */\n  async requestNotificationPermission() {\n    if ('Notification' in window) {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  /**\n   * Subscribe to notification events (context-aware)\n   */\n  on(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Use global listeners for backward compatibility\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n\n    // Also store in context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (!context.listeners.has(event)) {\n        context.listeners.set(event, new Set());\n      }\n      context.listeners.get(event).add(callback);\n\n      console.log('📝 Event listener registered for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Unsubscribe from notification events (context-aware)\n   */\n  off(event, callback, userType = null) {\n    const contextType = userType || this.activeContext || this.detectUserContext();\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Remove from global listeners\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n\n    // Remove from context-specific listeners\n    if (contextType && this.userContexts.has(contextType)) {\n      const context = this.userContexts.get(contextType);\n      if (context.listeners.has(event)) {\n        context.listeners.get(event).delete(callback);\n      }\n\n      console.log('🗑️ Event listener removed for', contextType, ':', event);\n    }\n  }\n\n  /**\n   * Emit event to listeners (context-aware)\n   */\n  emit(event, data = null, context = null) {\n    const contextType = context?.userType || this.activeContext;\n\n    // Ensure userContexts is initialized (safety check)\n    if (!this.userContexts) {\n      this.userContexts = new Map();\n    }\n\n    // Always emit to global listeners for backward compatibility\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data, context);\n        } catch (error) {\n          console.error(`Error in global notification listener for ${event}:`, error);\n        }\n      });\n    }\n\n    // Also emit to context-specific listeners if context is available\n    if (contextType && this.userContexts.has(contextType)) {\n      const userContext = this.userContexts.get(contextType);\n      if (userContext.listeners.has(event)) {\n        userContext.listeners.get(event).forEach(callback => {\n          try {\n            callback(data, context);\n          } catch (error) {\n            console.error(`Error in ${contextType} notification listener for ${event}:`, error);\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Get notifications for this specific user type\n   */\n  async getNotifications(page = 1, limit = 20, unreadOnly = false) {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n\n      console.log(`🔍 Getting notifications for ${this.userType}:`, { page, limit, unread_only: unreadOnly });\n\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n\n      const response = await axios.get(`${this.baseURL}/notifications`, {\n        params: { page, limit, unread_only: unreadOnly },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      console.log(`✅ ${this.userType} notifications retrieved:`, response.data);\n      return response.data;\n    } catch (error) {\n      console.error(`❌ Failed to get ${this.userType} notifications:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get unread notification count for this specific user type\n   */\n  async getUnreadCount() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n\n      console.log(`🔍 Getting unread count for ${this.userType}`);\n\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n\n      const response = await axios.get(`${this.baseURL}/notifications/unread-count`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      console.log(`✅ ${this.userType} unread count response:`, response.data);\n\n      // Handle different response formats\n      let count = 0;\n      if (response.data && response.data.data && typeof response.data.data.count !== 'undefined') {\n        count = response.data.data.count;\n        console.log('📊 NotificationService: Found count in data.data.count:', count);\n      } else if (response.data && typeof response.data.count !== 'undefined') {\n        count = response.data.count;\n        console.log('📊 NotificationService: Found count in data.count:', count);\n      } else {\n        count = 0;\n        console.log('⚠️ NotificationService: No count found, defaulting to 0');\n      }\n\n      return count;\n    } catch (error) {\n      console.error('❌ NotificationService: Failed to get unread count:', error);\n      if (error.response) {\n        console.error('📊 NotificationService: Error response status:', error.response.status);\n        console.error('📊 NotificationService: Error response data:', error.response.data);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Mark notification as read for this specific user type\n   */\n  async markAsRead(notificationId) {\n    try {\n      if (!notificationId || notificationId === 'undefined') {\n        throw new Error('Invalid notification ID provided');\n      }\n\n      this.validateContext();\n      const token = this.getAuthToken();\n\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n\n      console.log(`Marking notification as read for ${this.userType}:`, notificationId);\n\n      const response = await axios.put(`${this.baseURL}/notifications/${notificationId}/read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark ${this.userType} notification as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark all notifications as read for this specific user type\n   */\n  async markAllAsRead() {\n    try {\n      this.validateContext();\n      const token = this.getAuthToken();\n\n      if (!token) {\n        throw new Error(`No authentication token found for ${this.userType}`);\n      }\n\n      console.log(`Marking all notifications as read for ${this.userType}`);\n\n      const response = await axios.put(`${this.baseURL}/notifications/mark-all-read`, {}, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to mark all ${this.userType} notifications as read:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send test notification (admin only)\n   */\n  async sendTestNotification(data) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.post(`${this.baseURL}/notifications/test`, data, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to send test notification:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification statistics (admin only)\n   */\n  async getStatistics() {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.get(`${this.baseURL}/notifications/statistics`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get notification statistics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test SSE connection (for debugging)\n   */\n  async testConnection() {\n    console.log('🧪 Testing SSE connection...');\n\n    try {\n      // Clear any existing connection\n      if (this.eventSource) {\n        console.log('🧪 Clearing existing connection');\n        this.eventSource.close();\n        this.eventSource = null;\n        this.isConnected = false;\n        this.isConnecting = false;\n      }\n\n      // Reset state\n      this.connectionRefs = 1;\n\n      // Test connection\n      await this.connect('admin');\n\n      console.log('🧪 Test connection established');\n\n      // Keep connection alive for 10 seconds\n      setTimeout(() => {\n        console.log('🧪 Test completed, keeping connection');\n      }, 10000);\n\n    } catch (error) {\n      console.error('🧪 Test connection failed:', error);\n    }\n  }\n\n  /**\n   * Clean up old notifications (admin only)\n   */\n  async cleanupOldNotifications(days = 90) {\n    try {\n      const token = localStorage.getItem('adminToken');\n      const response = await axios.delete(`${this.baseURL}/notifications/cleanup`, {\n        params: { days },\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to cleanup old notifications:', error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Factory function to create context-specific notification services\n */\nfunction createNotificationService(userType) {\n  if (!userType || !['admin', 'client'].includes(userType)) {\n    throw new Error(`Invalid user type: ${userType}. Must be 'admin' or 'client'`);\n  }\n\n  return new ContextualNotificationService(userType);\n}\n\n/**\n * Global service instances (created on demand)\n */\nlet adminNotificationService = null;\nlet clientNotificationService = null;\n\n/**\n * Get or create admin notification service\n */\nfunction getAdminNotificationService() {\n  if (!adminNotificationService) {\n    adminNotificationService = createNotificationService('admin');\n    window.__adminNotificationService = adminNotificationService;\n  }\n  return adminNotificationService;\n}\n\n/**\n * Get or create client notification service\n */\nfunction getClientNotificationService() {\n  if (!clientNotificationService) {\n    clientNotificationService = createNotificationService('client');\n    window.__clientNotificationService = clientNotificationService;\n  }\n  return clientNotificationService;\n}\n\n/**\n * Legacy compatibility - returns service based on current auth state\n */\nfunction getLegacyNotificationService() {\n  const adminToken = localStorage.getItem('adminToken');\n  const clientToken = localStorage.getItem('clientToken');\n\n  // Prioritize admin if both are present\n  if (adminToken) {\n    return getAdminNotificationService();\n  }\n\n  if (clientToken) {\n    return getClientNotificationService();\n  }\n\n  // Default to admin for backward compatibility\n  return getAdminNotificationService();\n}\n\n// Export the factory and getters\nexport {\n  createNotificationService,\n  getAdminNotificationService,\n  getClientNotificationService,\n  ContextualNotificationService\n};\n\n// Default export for backward compatibility\nexport default getLegacyNotificationService();\n\n// Make services available globally for debugging\nwindow.__createNotificationService = createNotificationService;\nwindow.__getAdminNotificationService = getAdminNotificationService;\nwindow.__getClientNotificationService = getClientNotificationService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}