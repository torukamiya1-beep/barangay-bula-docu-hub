{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport clientAuthService from '@/services/clientAuthService';\nimport { validators, formatApiErrors, clearFieldError } from '@/utils/validation';\nimport AddressSelector from '@/components/common/AddressSelector.vue';\nexport default {\n  name: 'ClientRegistration',\n  components: {\n    AddressSelector\n  },\n  data() {\n    return {\n      currentStep: 1,\n      loading: false,\n      resendLoading: false,\n      resendCooldown: 0,\n      showPassword: false,\n      errorMessage: '',\n      successMessage: '',\n      accountId: null,\n      verificationMethodSelected: false,\n      // Account form data\n      accountForm: {\n        username: '',\n        email: '',\n        password: '',\n        confirmPassword: ''\n      },\n      // Profile form data\n      profileForm: {\n        first_name: '',\n        middle_name: '',\n        last_name: '',\n        suffix: '',\n        birth_date: '',\n        gender: '',\n        civil_status_id: '',\n        nationality: 'Filipino',\n        phone_number: '',\n        email: '',\n        house_number: '',\n        street: '',\n        subdivision: '',\n        barangay: '',\n        city_municipality: '',\n        province: '',\n        region: '',\n        region_code: '',\n        province_code: '',\n        city_code: '',\n        barangay_code: '',\n        postal_code: '',\n        years_of_residency: null,\n        months_of_residency: null\n      },\n      // Document upload data\n      uploadedFiles: {\n        utility_bill: [],\n        barangay_certificate: [],\n        valid_id: [],\n        lease_contract: [],\n        other: []\n      },\n      // Verification form data\n      verificationForm: {\n        otp: ''\n      },\n      // Address data\n      addressData: {\n        region_code: '',\n        province_code: '',\n        city_code: '',\n        barangay_code: '',\n        region_name: '',\n        province_name: '',\n        city_name: '',\n        barangay_name: ''\n      },\n      // Form errors\n      errors: {},\n      addressErrors: {}\n    };\n  },\n  computed: {\n    hasUploadedFiles() {\n      return Object.values(this.uploadedFiles).some(files => files.length > 0);\n    }\n  },\n  mounted() {\n    // Ensure profileForm is properly initialized\n    if (!this.profileForm) {\n      this.profileForm = {\n        first_name: '',\n        middle_name: '',\n        last_name: '',\n        suffix: '',\n        birth_date: '',\n        gender: '',\n        civil_status_id: '',\n        nationality: 'Filipino',\n        phone_number: '',\n        email: '',\n        house_number: '',\n        street: '',\n        subdivision: '',\n        barangay: '',\n        city_municipality: '',\n        province: '',\n        region: '',\n        region_code: '',\n        province_code: '',\n        city_code: '',\n        barangay_code: '',\n        postal_code: '',\n        years_of_residency: null,\n        months_of_residency: null\n      };\n    }\n  },\n  methods: {\n    // Validate individual field\n    validateField(fieldName) {\n      let error = null;\n      const value = this.getFieldValue(fieldName);\n      switch (fieldName) {\n        case 'username':\n          error = validators.required(value, 'Username') || validators.username(value);\n          break;\n        case 'email':\n          error = validators.required(value, 'Email') || validators.email(value);\n          break;\n        case 'password':\n          error = validators.required(value, 'Password') || validators.password(value);\n          break;\n        case 'confirmPassword':\n          error = validators.required(value, 'Confirm Password') || validators.confirmPassword(value, this.accountForm.password);\n          break;\n        case 'first_name':\n          error = validators.required(value, 'First Name') || validators.name(value, 'First Name');\n          break;\n        case 'last_name':\n          error = validators.required(value, 'Last Name') || validators.name(value, 'Last Name');\n          break;\n        case 'birth_date':\n          error = validators.required(value, 'Birth Date') || validators.birthDate(value);\n          break;\n        case 'gender':\n          error = validators.required(value, 'Gender');\n          break;\n        case 'civil_status_id':\n          error = validators.required(value, 'Civil Status');\n          break;\n        case 'nationality':\n          error = validators.required(value, 'Nationality') || validators.name(value, 'Nationality');\n          break;\n        case 'phone_number':\n          error = validators.required(value, 'Phone Number') || validators.phoneNumber(value);\n          break;\n        case 'barangay':\n          error = validators.required(value, 'Barangay') || validators.address(value, 'Barangay');\n          break;\n        case 'city_municipality':\n          error = validators.required(value, 'City/Municipality') || validators.address(value, 'City/Municipality');\n          break;\n        case 'province':\n          error = validators.required(value, 'Province') || validators.address(value, 'Province');\n          break;\n        case 'otp':\n          error = validators.required(value, 'Verification Code') || validators.otp(value);\n          break;\n      }\n      if (error) {\n        this.errors = {\n          ...this.errors,\n          [fieldName]: error\n        };\n      } else {\n        this.clearFieldError(fieldName);\n      }\n      return !error;\n    },\n    // Get field value from appropriate form\n    getFieldValue(fieldName) {\n      if (Object.prototype.hasOwnProperty.call(this.accountForm, fieldName)) {\n        return this.accountForm[fieldName];\n      } else if (Object.prototype.hasOwnProperty.call(this.profileForm, fieldName)) {\n        return this.profileForm[fieldName];\n      } else if (Object.prototype.hasOwnProperty.call(this.verificationForm, fieldName)) {\n        return this.verificationForm[fieldName];\n      }\n      return '';\n    },\n    // Clear field error\n    clearFieldError(fieldName) {\n      this.errors = clearFieldError(this.errors, fieldName);\n    },\n    // Handle gender change - clear suffix field when female is selected\n    handleGenderChange() {\n      this.clearFieldError('gender');\n\n      // Clear suffix field when female is selected\n      if (this.profileForm.gender === 'female') {\n        this.profileForm.suffix = '';\n      }\n    },\n    // Handle phone number input to restrict to digits only\n    handlePhoneInput(event) {\n      const value = event.target.value;\n      // Remove any non-digit characters\n      const digitsOnly = value.replace(/\\D/g, '');\n      // Limit to 11 digits\n      const limitedValue = digitsOnly.substring(0, 11);\n      this.profileForm.phone_number = limitedValue;\n      this.clearFieldError('phone_number');\n    },\n    // Clear all messages\n    clearMessages() {\n      this.errorMessage = '';\n      this.successMessage = '';\n    },\n    // Submit account form (Step 1)\n    async submitAccountForm() {\n      this.clearMessages();\n\n      // Validate all account fields\n      const fieldsToValidate = ['username', 'email', 'password', 'confirmPassword'];\n      let isValid = true;\n      fieldsToValidate.forEach(field => {\n        if (!this.validateField(field)) {\n          isValid = false;\n        }\n      });\n      if (!isValid) {\n        this.errorMessage = 'Please fix the errors above';\n        return;\n      }\n      this.loading = true;\n      try {\n        const response = await clientAuthService.registerAccount({\n          username: this.accountForm.username,\n          email: this.accountForm.email,\n          password: this.accountForm.password,\n          confirmPassword: this.accountForm.confirmPassword\n        });\n        if (response.success) {\n          this.accountId = response.data.accountId;\n          this.profileForm.email = this.accountForm.email;\n          this.successMessage = response.message;\n          this.currentStep = 2;\n        }\n      } catch (error) {\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message;\n        if (errorData.errors && errorData.errors.length > 0) {\n          this.errors = {\n            ...this.errors,\n            ...formatApiErrors(errorData.errors)\n          };\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Submit profile form (Step 2)\n    async submitProfileForm() {\n      this.clearMessages();\n\n      // Validate address selection first\n      if (!this.validateAddressSelection()) {\n        this.errorMessage = 'Please select a complete address (Region, Province, City, and Barangay)';\n        return;\n      }\n\n      // Validate all required profile fields\n      const fieldsToValidate = ['first_name', 'last_name', 'birth_date', 'gender', 'civil_status_id', 'nationality', 'phone_number', 'barangay', 'city_municipality', 'province', 'region'];\n      let isValid = true;\n      fieldsToValidate.forEach(field => {\n        if (!this.validateField(field)) {\n          isValid = false;\n        }\n      });\n      if (!isValid) {\n        this.errorMessage = 'Please fix the errors above';\n        return;\n      }\n      this.loading = true;\n      try {\n        const response = await clientAuthService.completeRegistration(this.accountId, {\n          ...this.profileForm,\n          civil_status_id: parseInt(this.profileForm.civil_status_id)\n        });\n        if (response.success) {\n          this.successMessage = response.message;\n          this.currentStep = 3;\n\n          // Start resend cooldown\n          this.startResendCooldown();\n        }\n      } catch (error) {\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message;\n        if (errorData.errors && errorData.errors.length > 0) {\n          this.errors = {\n            ...this.errors,\n            ...formatApiErrors(errorData.errors)\n          };\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Handle address change from AddressSelector component\n    onAddressChange(addressData) {\n      this.addressData = {\n        region_code: addressData.region.code,\n        province_code: addressData.province.code,\n        city_code: addressData.city.code,\n        barangay_code: addressData.barangay.code,\n        region_name: addressData.region.name,\n        province_name: addressData.province.name,\n        city_name: addressData.city.name,\n        barangay_name: addressData.barangay.name\n      };\n\n      // Update profile form with address data\n      this.profileForm.barangay = addressData.barangay.name;\n      this.profileForm.city_municipality = addressData.city.name;\n      this.profileForm.province = addressData.province.name;\n      this.profileForm.region = addressData.region.name;\n      this.profileForm.region_code = addressData.region.code;\n      this.profileForm.province_code = addressData.province.code;\n      this.profileForm.city_code = addressData.city.code;\n      this.profileForm.barangay_code = addressData.barangay.code;\n\n      // Clear address errors\n      this.addressErrors = {};\n    },\n    // Handle file upload\n    handleFileUpload(event, documentType) {\n      const files = Array.from(event.target.files);\n\n      // Validate file types and sizes\n      const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf', 'image/webp'];\n      const maxSize = 5 * 1024 * 1024; // 5MB\n\n      const validFiles = files.filter(file => {\n        if (!validTypes.includes(file.type)) {\n          this.errorMessage = `Invalid file type: ${file.name}. Only JPG, PNG, PDF, and WebP files are allowed.`;\n          return false;\n        }\n        if (file.size > maxSize) {\n          this.errorMessage = `File too large: ${file.name}. Maximum size is 5MB.`;\n          return false;\n        }\n        return true;\n      });\n      if (validFiles.length > 0) {\n        // For single file types, replace existing files\n        if (['barangay_certificate', 'lease_contract'].includes(documentType)) {\n          this.uploadedFiles[documentType] = validFiles.slice(0, 1);\n        } else {\n          // For multiple file types, add to existing files\n          this.uploadedFiles[documentType] = [...this.uploadedFiles[documentType], ...validFiles];\n        }\n        this.clearMessages();\n      }\n\n      // Clear the input\n      event.target.value = '';\n    },\n    // Remove uploaded file\n    removeFile(documentType, index) {\n      this.uploadedFiles[documentType].splice(index, 1);\n    },\n    // Submit document form (Step 3)\n    async submitDocumentForm() {\n      this.clearMessages();\n      if (!this.hasUploadedFiles) {\n        this.errorMessage = 'Please upload at least one proof of residency document';\n        return;\n      }\n      this.loading = true;\n      try {\n        // Create FormData for file upload\n        const formData = new FormData();\n        formData.append('account_id', this.accountId);\n\n        // Add all uploaded files to FormData\n        Object.keys(this.uploadedFiles).forEach(documentType => {\n          this.uploadedFiles[documentType].forEach(file => {\n            formData.append(documentType, file);\n          });\n        });\n\n        // Upload documents using the residency service\n        const response = await this.uploadResidencyDocuments(formData);\n        if (response.success) {\n          this.successMessage = response.message;\n          this.currentStep = 4; // Move to verification step\n          // Automatically send both email and SMS OTP\n          await this.sendBothOTPs();\n        }\n      } catch (error) {\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message;\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Upload residency documents (API call)\n    async uploadResidencyDocuments(formData) {\n      // Use the proper API base URL to avoid proxy issues\n      const API_BASE_URL = process.env.VUE_APP_API_URL || 'http://localhost:7000/api';\n\n      // Use the registration-specific endpoint that doesn't require authentication\n      const response = await fetch(`${API_BASE_URL}/residency/upload-registration`, {\n        method: 'POST',\n        // No Authorization header needed for registration uploads\n        body: formData\n      });\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.message || 'Failed to upload documents');\n      }\n      return data;\n    },\n    // Submit verification form (Step 4)\n    async submitVerificationForm() {\n      this.clearMessages();\n      if (!this.validateField('otp')) {\n        this.errorMessage = 'Please enter a valid verification code';\n        return;\n      }\n      this.loading = true;\n      try {\n        let response;\n        let verificationSuccessful = false;\n\n        // Try to verify OTP with email first\n        try {\n          response = await clientAuthService.verifyEmail(this.accountForm.email, this.verificationForm.otp);\n          if (response.success) {\n            verificationSuccessful = true;\n            this.successMessage = response.message + ' (verified via email)';\n          }\n        } catch (emailError) {\n          // Email verification failed, try SMS if phone number exists\n          if (this.profileForm.phone_number) {\n            try {\n              response = await clientAuthService.verifySMSOTP(this.profileForm.phone_number, this.verificationForm.otp);\n              if (response.success) {\n                verificationSuccessful = true;\n                this.successMessage = response.message + ' (verified via SMS)';\n              }\n            } catch (smsError) {\n              // Both failed\n              this.errorMessage = `Invalid verification code. Please check your email or SMS for the correct code.`;\n            }\n          } else {\n            // Only email verification available\n            const errorData = clientAuthService.parseError(emailError);\n            this.errorMessage = errorData.message;\n          }\n        }\n        if (verificationSuccessful) {\n          this.currentStep = 5; // Registration complete\n        }\n      } catch (error) {\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message;\n      } finally {\n        this.loading = false;\n      }\n    },\n    // Resend unified verification code (same code via both email and SMS)\n    async resendVerificationCode() {\n      if (this.resendCooldown > 0) return;\n      this.resendLoading = true;\n      this.clearMessages();\n      try {\n        // Resend unified OTP (same code to both email and SMS)\n        const result = await clientAuthService.resendUnifiedOTP(this.accountForm.email, this.profileForm.phone_number, 'email_verification', this.profileForm.first_name);\n        if (result.success) {\n          let successMessages = [];\n          if (result.data.emailSent) {\n            successMessages.push('Email verification code resent');\n          }\n          if (result.data.smsSent) {\n            successMessages.push('SMS verification code resent');\n          }\n          if (successMessages.length > 0) {\n            this.successMessage = `${successMessages.join(' and ')}! The same verification code has been resent to both channels - you can use it from either your email or SMS.`;\n            this.startResendCooldown();\n          } else {\n            this.errorMessage = 'Failed to resend verification codes. Please try again.';\n          }\n        } else {\n          this.errorMessage = result.message || 'Failed to resend verification codes. Please try again.';\n        }\n      } catch (error) {\n        console.error('Failed to resend verification codes:', error);\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to resend verification codes. Please try again.';\n      } finally {\n        this.resendLoading = false;\n      }\n    },\n    // Start resend cooldown timer\n    startResendCooldown() {\n      this.resendCooldown = 60;\n      const timer = setInterval(() => {\n        this.resendCooldown--;\n        if (this.resendCooldown <= 0) {\n          clearInterval(timer);\n        }\n      }, 1000);\n    },\n    // Validate address selection\n    validateAddressSelection() {\n      const addressErrors = {};\n      if (!this.addressData.region_code) {\n        addressErrors.region = 'Region is required';\n      }\n      if (!this.addressData.province_code) {\n        addressErrors.province = 'Province is required';\n      }\n      if (!this.addressData.city_code) {\n        addressErrors.city = 'City/Municipality is required';\n      }\n      if (!this.addressData.barangay_code) {\n        addressErrors.barangay = 'Barangay is required';\n      }\n      this.addressErrors = addressErrors;\n      return Object.keys(addressErrors).length === 0;\n    },\n    // Go to previous step\n    goToPreviousStep() {\n      if (this.currentStep > 1) {\n        this.currentStep--;\n        this.clearMessages();\n      }\n    },\n    // Go to login page\n    goToLogin() {\n      this.$router.push('/client/login');\n    },\n    // Automatically send unified OTP (same code via both email and SMS)\n    async sendBothOTPs() {\n      this.verificationMethodSelected = true;\n      try {\n        this.loading = true;\n        this.errorMessage = '';\n\n        // Send unified OTP (same code to both email and SMS)\n        const result = await clientAuthService.sendUnifiedOTP(this.accountForm.email, this.profileForm.phone_number, 'email_verification', this.profileForm.first_name);\n        if (result.success) {\n          let successMessages = [];\n          if (result.data.emailSent) {\n            successMessages.push('Email verification code sent');\n          }\n          if (result.data.smsSent) {\n            successMessages.push('SMS verification code sent');\n          }\n          if (successMessages.length > 0) {\n            this.successMessage = \"Email verification code sent! Please check your Gmail to retrieve the code.\";\n            // this.successMessage = `${successMessages.join(' and ')}! The same verification code has been sent to both channels - you can use it from either your email or SMS.`;\n            this.startResendCooldown();\n          } else {\n            this.errorMessage = 'Failed to send verification codes. Please try again.';\n          }\n        } else {\n          this.errorMessage = result.message || 'Failed to send verification codes. Please try again.';\n        }\n      } catch (error) {\n        console.error('Failed to send verification codes:', error);\n        const errorData = clientAuthService.parseError(error);\n        this.errorMessage = errorData.message || 'Failed to send verification codes. Please try again.';\n      } finally {\n        this.loading = false;\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}