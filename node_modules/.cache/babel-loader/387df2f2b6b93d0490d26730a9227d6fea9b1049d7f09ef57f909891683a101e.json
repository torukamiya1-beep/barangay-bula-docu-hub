{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\n/**\n * Error Handler Composable\n * Centralized error handling with logging, user notifications, and recovery\n * Implements Google's error handling best practices\n */\n\nimport { ref } from 'vue';\nexport function useErrorHandler() {\n  // Error state\n  const errors = ref([]);\n  const globalError = ref(null);\n  const isErrorModalOpen = ref(false);\n\n  // Error types\n  const ERROR_TYPES = {\n    NETWORK: 'network',\n    VALIDATION: 'validation',\n    AUTHENTICATION: 'authentication',\n    AUTHORIZATION: 'authorization',\n    SERVER: 'server',\n    CLIENT: 'client',\n    UNKNOWN: 'unknown'\n  };\n\n  // Error severity levels\n  const SEVERITY_LEVELS = {\n    LOW: 'low',\n    MEDIUM: 'medium',\n    HIGH: 'high',\n    CRITICAL: 'critical'\n  };\n\n  // Methods\n  const handleError = (error, context = '', options = {}) => {\n    const errorInfo = processError(error, context, options);\n\n    // Log error\n    logError(errorInfo);\n\n    // Store error\n    addError(errorInfo);\n\n    // Show user notification if needed\n    if (options.showToUser !== false) {\n      showErrorToUser(errorInfo);\n    }\n\n    // Report to monitoring service if critical\n    if (errorInfo.severity === SEVERITY_LEVELS.CRITICAL) {\n      reportCriticalError(errorInfo);\n    }\n    return errorInfo;\n  };\n  const processError = (error, context, options) => {\n    const timestamp = new Date().toISOString();\n    const errorId = generateErrorId();\n    let errorInfo = {\n      id: errorId,\n      timestamp,\n      context,\n      severity: options.severity || SEVERITY_LEVELS.MEDIUM,\n      type: ERROR_TYPES.UNKNOWN,\n      message: 'An unexpected error occurred',\n      originalError: error,\n      stack: null,\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      userId: getCurrentUserId(),\n      sessionId: getSessionId()\n    };\n\n    // Process different error types\n    if (error instanceof Error) {\n      errorInfo.message = error.message;\n      errorInfo.stack = error.stack;\n      errorInfo.type = classifyError(error);\n    } else if (typeof error === 'string') {\n      errorInfo.message = error;\n      errorInfo.type = ERROR_TYPES.CLIENT;\n    } else if (error?.response) {\n      // Axios error\n      errorInfo = processAxiosError(error, errorInfo);\n    } else if (error?.code) {\n      // Custom error with code\n      errorInfo.type = error.code;\n      errorInfo.message = error.message || errorInfo.message;\n    }\n    return errorInfo;\n  };\n  const processAxiosError = (axiosError, errorInfo) => {\n    const response = axiosError.response;\n    const request = axiosError.request;\n    if (response) {\n      // Server responded with error status\n      errorInfo.type = response.status >= 500 ? ERROR_TYPES.SERVER : ERROR_TYPES.CLIENT;\n      errorInfo.message = response.data?.message || `HTTP ${response.status}: ${response.statusText}`;\n      errorInfo.statusCode = response.status;\n      errorInfo.responseData = response.data;\n\n      // Set severity based on status code\n      if (response.status >= 500) {\n        errorInfo.severity = SEVERITY_LEVELS.HIGH;\n      } else if (response.status === 401) {\n        errorInfo.type = ERROR_TYPES.AUTHENTICATION;\n        errorInfo.severity = SEVERITY_LEVELS.MEDIUM;\n      } else if (response.status === 403) {\n        errorInfo.type = ERROR_TYPES.AUTHORIZATION;\n        errorInfo.severity = SEVERITY_LEVELS.MEDIUM;\n      }\n    } else if (request) {\n      // Network error\n      errorInfo.type = ERROR_TYPES.NETWORK;\n      errorInfo.message = 'Network error - please check your connection';\n      errorInfo.severity = SEVERITY_LEVELS.HIGH;\n    }\n    return errorInfo;\n  };\n  const classifyError = error => {\n    const message = error.message.toLowerCase();\n    if (message.includes('network') || message.includes('fetch')) {\n      return ERROR_TYPES.NETWORK;\n    } else if (message.includes('validation') || message.includes('invalid')) {\n      return ERROR_TYPES.VALIDATION;\n    } else if (message.includes('unauthorized') || message.includes('authentication')) {\n      return ERROR_TYPES.AUTHENTICATION;\n    } else if (message.includes('forbidden') || message.includes('permission')) {\n      return ERROR_TYPES.AUTHORIZATION;\n    }\n    return ERROR_TYPES.CLIENT;\n  };\n  const logError = errorInfo => {\n    // Console logging with appropriate level\n    const logLevel = getLogLevel(errorInfo.severity);\n    const logMessage = `[${errorInfo.type.toUpperCase()}] ${errorInfo.context}: ${errorInfo.message}`;\n    console[logLevel](logMessage, {\n      errorId: errorInfo.id,\n      timestamp: errorInfo.timestamp,\n      originalError: errorInfo.originalError,\n      stack: errorInfo.stack\n    });\n  };\n  const getLogLevel = severity => {\n    switch (severity) {\n      case SEVERITY_LEVELS.LOW:\n        return 'info';\n      case SEVERITY_LEVELS.MEDIUM:\n        return 'warn';\n      case SEVERITY_LEVELS.HIGH:\n      case SEVERITY_LEVELS.CRITICAL:\n        return 'error';\n      default:\n        return 'warn';\n    }\n  };\n  const addError = errorInfo => {\n    errors.value.unshift(errorInfo);\n\n    // Keep only last 50 errors to prevent memory issues\n    if (errors.value.length > 50) {\n      errors.value = errors.value.slice(0, 50);\n    }\n\n    // Set global error for critical issues\n    if (errorInfo.severity === SEVERITY_LEVELS.CRITICAL) {\n      globalError.value = errorInfo;\n    }\n  };\n  const showErrorToUser = errorInfo => {\n    const userMessage = getUserFriendlyMessage(errorInfo);\n\n    // You can integrate with your notification system here\n    // For now, we'll use a simple approach\n    if (errorInfo.severity === SEVERITY_LEVELS.CRITICAL) {\n      // Show modal for critical errors\n      globalError.value = errorInfo;\n      isErrorModalOpen.value = true;\n    } else {\n      // Show toast notification for other errors\n      showToastNotification(userMessage, errorInfo.severity);\n    }\n  };\n  const getUserFriendlyMessage = errorInfo => {\n    switch (errorInfo.type) {\n      case ERROR_TYPES.NETWORK:\n        return 'Please check your internet connection and try again.';\n      case ERROR_TYPES.AUTHENTICATION:\n        return 'Please log in again to continue.';\n      case ERROR_TYPES.AUTHORIZATION:\n        return 'You do not have permission to perform this action.';\n      case ERROR_TYPES.VALIDATION:\n        return errorInfo.message;\n      // Validation messages are usually user-friendly\n      case ERROR_TYPES.SERVER:\n        return 'Server error. Please try again later.';\n      default:\n        return 'Something went wrong. Please try again.';\n    }\n  };\n  const showToastNotification = (message, severity) => {\n    // Placeholder for toast notification\n    // You would integrate with your actual notification system\n    console.log(`Toast [${severity}]: ${message}`);\n  };\n  const reportCriticalError = errorInfo => {\n    // Report to external monitoring service (e.g., Sentry, LogRocket)\n    // This is a placeholder implementation\n    console.error('CRITICAL ERROR REPORTED:', errorInfo);\n  };\n\n  // Utility functions\n  const generateErrorId = () => {\n    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  };\n  const getCurrentUserId = () => {\n    // Get current user ID from auth service\n    try {\n      const user = JSON.parse(localStorage.getItem('auth_user') || '{}');\n      return user.id || 'anonymous';\n    } catch {\n      return 'anonymous';\n    }\n  };\n  const getSessionId = () => {\n    // Get or generate session ID\n    let sessionId = sessionStorage.getItem('session_id');\n    if (!sessionId) {\n      sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      sessionStorage.setItem('session_id', sessionId);\n    }\n    return sessionId;\n  };\n\n  // Error management\n  const clearErrors = () => {\n    errors.value = [];\n    globalError.value = null;\n  };\n  const clearError = errorId => {\n    errors.value = errors.value.filter(error => error.id !== errorId);\n    if (globalError.value?.id === errorId) {\n      globalError.value = null;\n    }\n  };\n  const closeErrorModal = () => {\n    isErrorModalOpen.value = false;\n    globalError.value = null;\n  };\n  const retryLastAction = () => {\n    // Placeholder for retry functionality\n    console.log('Retrying last action...');\n  };\n\n  // Return public API\n  return {\n    // State\n    errors,\n    globalError,\n    isErrorModalOpen,\n    // Constants\n    ERROR_TYPES,\n    SEVERITY_LEVELS,\n    // Methods\n    handleError,\n    clearErrors,\n    clearError,\n    closeErrorModal,\n    retryLastAction,\n    // Utilities\n    getUserFriendlyMessage\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}